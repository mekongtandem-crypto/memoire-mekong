<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üêò M√©moire du M√©kong V0.5.1 (Am√©liorations)</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://apis.google.com/js/api.js"></script>
	<script src="https://accounts.google.com/gsi/client"></script>
	<script>
	window.onload = () => {
  		google.accounts.id.initialize({
    		client_id: '82966045106-hso0nr386agcuojllnud0dr41vcsh45a.apps.googleusercontent.com'
  		});
		};
	</script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .lucide { width: 1em; height: 1em; fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; }
        .fade-in { animation: fadeIn 0.3s ease-in; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        /* Style pour le slider */
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 20px; width: 20px; border-radius: 50%; background: #c2410c; cursor: pointer; margin-top: -8px; }
        input[type=range]::-moz-range-thumb { height: 20px; width: 20px; border-radius: 50%; background: #c2410c; cursor: pointer; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #fbbf24; border-radius: 5px; }
        input[type=range]::-moz-range-track { width: 100%; height: 4px; cursor: pointer; background: #fbbf24; border-radius: 5px; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // ===== ICONS LUCIDE (Ajout de X pour fermer) =====
        const X = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>;
        const Home = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9,22 9,12 15,12 15,22"/></svg>;
        const Users = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="m22 21-2-2"/></svg>;
        const User = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>;
        const Play = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><polygon points="5,3 19,12 5,21"/></svg>;
        const Camera = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/></svg>;
        const Cloud = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z"/></svg>;
        const Settings = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M12.22 2h-.44a2 2 0 0 0-2 2.18l.2 1.81c-.26.06-.51.14-.76.23l-1.5-1.16a2 2 0 0 0-2.83.32l-.22.38a2 2 0 0 0 .32 2.83l1.16 1.5c-.09.25-.17.5-.23.76l-1.81.2a2 2 0 0 0-2.18 2v.44a2 2 0 0 0 2.18 2l1.81.2c.06.26.14.51.23.76l-1.16 1.5a2 2 0 0 0-.32 2.83l.38.22a2 2 0 0 0 2.83-.32l1.5-1.16c.25.09.5.17.76.23l.2 1.81a2 2 0 0 0 2 2.18h.44a2 2 0 0 0 2-2.18l.2-1.81c.26-.06.51-.14-.76-.23l1.5 1.16a2 2 0 0 0 2.83-.32l.22-.38a2 2 0 0 0-.32-2.83l-1.16-1.5c.09-.25-.17-.5-.23-.76l1.81-.2a2 2 0 0 0 2.18-2v-.44a2 2 0 0 0-2.18-2l-1.81-.2c-.06-.26-.14-.51-.23-.76l1.16-1.5a2 2 0 0 0 .32-2.83l-.38-.22a2 2 0 0 0-2.83.32l-1.5 1.16c-.25-.09-.5-.17-.76-.23l-.2-1.81a2 2 0 0 0-2-2.18Z"/><circle cx="12" cy="12" r="3"/></svg>;
        const ChevronLeft = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="m15 18-6-6 6-6"/></svg>;
        const ChevronRight = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="m9 18 6-6-6-6"/></svg>;
        const Clock = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg>;
        const Mic = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" x2="12" y1="19" y2="22"/><line x1="8" x2="16" y1="22" y2="22"/></svg>;
        const Zap = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><polygon points="13,2 3,14 12,14 11,22 21,10 12,10"/></svg>;
        const MapPin = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z"/><circle cx="12" cy="10" r="3"/></svg>;
        const BookOpen = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg>;
        const Edit = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="m18.5 2.5 3 3L12 15l-4 1 1-4 9.5-9.5Z"/></svg>;
        const Plus = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M5 12h14"/><path d="M12 5v14"/></svg>;
        const Shuffle = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><polyline points="16,3 21,3 21,8"/><line x1="4" x2="21" y1="20" y2="3"/><polyline points="21,16 21,21 16,21"/><line x1="15" x2="21" y1="15" y2="21"/><line x1="4" x2="9" y1="4" y2="9"/></svg>;
        const Pause = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><rect width="4" height="16" x="6" y="4"/><rect width="4" height="16" x="14" y="4"/></svg>;
        const ArrowLeft = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="m12 19-7-7 7-7"/><path d="M19 12H5"/></svg>;
        const Send = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="m22 2-7 20-4-9-9-4Z"/><path d="M22 2 11 13"/></svg>;
        const Trash2 = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="m8 6V4c0-1 1-2 2-2h4c0-1-1-2-2-2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>;
        const Search = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></svg>;
        const Upload = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7,10 12,5 17,10"/><line x1="12" x2="12" y1="5" y2="15"/></svg>;
        const FileText = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14,2 14,8 20,8"/><line x1="16" x2="8" y1="13" y2="13"/><line x1="16" x2="8" y1="17" y2="17"/><line x1="10" x2="8" y1="9" y2="9"/></svg>;

		// ===== COMPOSANT TOAST (Alerte) =====
		const Toast = ({ message, type, onDismiss }) => {
    		if (!message) return null;
    		const styles = {
        		error: { bg: 'bg-red-100', text: 'text-red-800', border: 'border-red-300' },
        		success: { bg: 'bg-green-100', text: 'text-green-800', border: 'border-green-300' }
    		};
    		const style = styles[type] || styles.error;
    		return (
        		<div className={`fixed bottom-4 right-4 max-w-sm p-4 border rounded-lg shadow-lg fade-in ${style.bg} ${style.text} ${style.border}`}>
            		<div className="flex justify-between items-center">
                		<span>{message}</span>
                		<button onClick={onDismiss} className="ml-4 text-xl font-bold">&times;</button>
            		</div>
        		</div>
    		);
		};
		
        // ===== CORE STORAGE =====
        const Storage = {
            get: (key, defaultValue = null) => {
                try {
                    const item = localStorage.getItem(`mekong_${key}`);
                    return item ? JSON.parse(item) : defaultValue;
                } catch { return defaultValue; }
            },
            set: (key, value) => {
                try {
                    localStorage.setItem(`mekong_${key}`, JSON.stringify(value));
                    return true;
                } catch { return false; }
            },
            remove: (key) => localStorage.removeItem(`mekong_${key}`),
            clear: () => {
                Object.keys(localStorage).forEach(key => {
                    if (key.startsWith('mekong_')) localStorage.removeItem(key);
                });
            }
        };
		
        // ===== MASTODON DATA MANAGEMENT (CORRIG√â POUR TITRES/APOSTROPHES) =====
        const MastodonData = {
            // CORRIG√â: Fonction de d√©codage plus robuste
            decodeHtmlEntities: (text) => {
                if (typeof text !== 'string') return '';
                // Cette technique est simple et efficace pour d√©coder toutes les entit√©s HTML
                const textArea = document.createElement('textarea');
                textArea.innerHTML = text;
                return textArea.value;
            },
            parseOutbox: (jsonData) => {
                try {
                    const data = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;
                    const orderedItems = data.orderedItems || data.data?.orderedItems;
                    if (!Array.isArray(orderedItems)) throw new Error('orderedItems non trouv√© ou invalide');

                    const allPosts = orderedItems
                        .filter(item => item.type === 'Create' && item.object?.type === 'Note')
                        .map((item, index) => {
                            const note = item.object;
                            const content = note.content || '';
                            
                            // 1. Nettoyer les balises HTML principales (<p>) et autres, puis d√©coder
                            const cleanContent = content.replace(/<p>|<\/p>/g, '\n').replace(/<br\s*\/?>/g, '\n').replace(/<[^>]*>/g, '').trim();
                            const decodedContent = MastodonData.decodeHtmlEntities(cleanContent);
                            
                            const dayMatch = decodedContent.match(/^J(\d{1,3})[\s:]/);
                            const dayNumber = dayMatch ? parseInt(dayMatch[1]) : null;
                            const hasJourNumber = dayNumber !== null;
                            
                            let title;
                            if (hasJourNumber) {
                                // 2. Extraire la premi√®re ligne apr√®s Jnnn comme titre, puis d√©coder
                                const afterJour = decodedContent.replace(/^J\d{1,3}[\s:]+/, '');
                                title = MastodonData.decodeHtmlEntities(afterJour.split('\n')[0].trim());
                            } else {
                                // 3. Utiliser le d√©but du contenu comme titre, puis d√©coder
                                title = MastodonData.decodeHtmlEntities(decodedContent.split('\n')[0].trim());
                            }
                            
                            return {
                                id: note.id || `post-${index}`,
                                dayNumber,
                                hasJourNumber,
                                title: title.slice(0, 80) || 'Post sans titre',
                                content: decodedContent,
                                published: note.published || item.published,
                                // CONSERVE LES ATTACHMENTS POUR LES R√âCUP√âRER PLUS TARD
                                attachments: note.attachment || [],
                                url: note.url,
                            };
                        });
                    // ... (logique de tri et d'assignation des num√©ros de jour inchang√©e)
                    const postsWithDay = allPosts.filter(post => post.hasJourNumber);
                    const postsWithoutDay = allPosts.filter(post => !post.hasJourNumber);
                    postsWithDay.sort((a, b) => a.dayNumber - b.dayNumber);
                    const maxDayNumber = postsWithDay.length > 0 ? Math.max(...postsWithDay.map(p => p.dayNumber)) : 0;
                    postsWithoutDay.forEach((post, index) => {
                        post.dayNumber = maxDayNumber + index + 1;
                        post.isExtraPost = true;
                    });
                    const finalPosts = [...postsWithDay, ...postsWithoutDay];
                    finalPosts.forEach(post => { delete post.hasJourNumber; });
                    return finalPosts;
                } catch (error) {
                    console.error('‚ùå Erreur parsing outbox:', error);
                    throw error;
                }
            },
            getPosts: () => Storage.get('mastodon_posts', []),
            getPostByDay: (dayNumber) => MastodonData.getPosts().find(p => p.dayNumber === dayNumber),
            isImported: () => MastodonData.getPosts().length > 0,
            getStats: () => {
                const posts = MastodonData.getPosts();
                if (posts.length === 0) return { totalPosts: 0, dayRange: null, importedAt: null };
                return {
                    totalPosts: posts.length,
                    dayRange: {
                        min: Math.min(...posts.map(p => p.dayNumber)),
                        max: Math.max(...posts.map(p => p.dayNumber))
                    },
                    importedAt: Storage.get('mastodon_imported_at')
                };
            },
            // ... (autres fonctions inchang√©es)
        };

        // ===== GOOGLE DRIVE API (AM√âLIOR√â POUR LES IMAGES MASTODON) =====
        const GoogleDriveAPI = {
            // ... (propri√©t√©s et init, signIn, signOut inchang√©s)
            
            _folderIdCache: new Map(),
            async findFolderByPath(path) { /* ... (inchang√©) ... */ },
            async getPhotosByDay(dayNumber) { /* ... (inchang√©) ... */ },
            
            // NOUVEAU: Trouver un fichier par son nom (pour les images Mastodon)
            _fileIdCache: new Map(),
            async findFileByPartialPath(filename, rootPath) {
                const cacheKey = `${rootPath}:${filename}`;
                if (this._fileIdCache.has(cacheKey)) {
                    return this._fileIdCache.get(cacheKey);
                }

                const rootFolderId = await this.findFolderByPath(rootPath);
                if (!rootFolderId) {
                    console.warn(`Dossier racine pour la recherche de fichier non trouv√©: ${rootPath}`);
                    return null;
                }

                try {
                    const response = await gapi.client.drive.files.list({
                        // Recherche le fichier par son nom dans n'importe quel sous-dossier du dossier racine sp√©cifi√©
                        q: `'${rootFolderId}' in parents and name='${filename}' and trashed=false`,
                        fields: 'files(id, webViewLink, webContentLink, thumbnailLink)',
                        pageSize: 1
                    });
                    const file = response.result.files[0];
                    if (file) {
                        this._fileIdCache.set(cacheKey, file);
                        return file;
                    }
                    // Note: This is a simple search in the immediate parent. A full recursive search would be much slower.
                    // This implementation assumes the path logic will point to the correct parent directory.
                    return null;
                } catch (error) {
                    console.error(`Erreur recherche fichier ${filename}:`, error);
                    return null;
                }
            }
        };

        const useSessionState = () => {
            const [currentSession, setCurrentSession] = React.useState(null);
            const [sessions, setSessions] = React.useState([]);

            React.useEffect(() => {
                const loadSessions = async () => {
                    const loadedSessions = await CloudSessionStorage.getSessions();
                    setSessions(loadedSessions);
                };
                loadSessions();
            }, []);

            const createSession = async (game, user) => {
                const pendingSession = window.pendingGameSession || {};
                const initialNotes = [];
                
                if (pendingSession.postChapo) {
                    initialNotes.push({
                        id: Date.now() - 1,
                        content: pendingSession.postChapo.trim(),
                        author: 'duo',
                        timestamp: new Date().toISOString()
                    });
                }

                const newSession = {
                    id: Date.now(),
                    gameId: Number(game.id),
                    gameTitle: game.title,
                    user: user,
                    createdAt: new Date().toISOString(),
                    updatedAt: new Date().toISOString(),
                    status: 'active',
                    notes: initialNotes,
                    // NOUVEAU: Ajout de l'URL de la photo √† la session
                    photoUrl: pendingSession.photoUrl || null
                };

                await CloudSessionStorage.saveSession(newSession);
                const updatedSessions = await CloudSessionStorage.getSessions();
                setSessions(updatedSessions);
                setCurrentSession(newSession);
                
                delete window.pendingGameSession;
                return newSession;
            };

            const updateSession = async (updatedSession) => { /* ... */ };
            const deleteSession = async (sessionId) => { /* ... */ };
            // ... (reste du hook)
        };

        // ... (Autres composants et hooks inchang√©s : USERS, getUserStyle, useAppState, GamesPage, etc.)
        
        // ===== PAGE CHAT (MODIFI√âE POUR AFFICHER LA PHOTO) =====
        const ChatPage = ({ currentUser, currentSession, onUpdateSession, onBackToSessions }) => {
            // ... (√©tats et hooks inchang√©s)
            if (!currentSession) {
                return <div>Chargement de la session...</div>; // S√©curit√©
            }

            return (
                <div className="flex flex-col h-screen max-h-[85vh] fade-in">
                    {/* ... (Header de la session inchang√©) */}

                    <div className="flex-1 bg-gray-50 rounded-lg border overflow-y-auto p-4 space-y-3">
                        {/* NOUVEAU: Affichage de la photo contextuelle */}
                        {currentSession.photoUrl && (
                            <div className="p-2 border-b border-gray-200 mb-4">
                                <img src={currentSession.photoUrl} alt="Contexte de la session" className="max-w-xs mx-auto rounded-lg shadow-md" />
                            </div>
                        )}
                        {/* ... (Affichage des messages inchang√©) */}
                    </div>
                    {/* ... (Input de message inchang√©) */}
                </div>
            );
        };

        // ===== PAGE M√âMOIRES (FORTEMENT AM√âLIOR√âE) =====
        const MemoriesPage = ({ currentUser, onCreateSession }) => {
            const [activeView, setActiveView] = React.useState('blog');
            const [dayNumber, setDayNumber] = React.useState(1);
            
            const [currentPost, setCurrentPost] = React.useState(null);
            const [photos, setPhotos] = React.useState([]);
            const [isLoading, setIsLoading] = React.useState(false);
            const [error, setError] = React.useState('');

            const [isModalOpen, setIsModalOpen] = React.useState(false);
            const [selectedPhoto, setSelectedPhoto] = React.useState(null);
            
            const { isConnected } = useGoogleAuth();
            const isMastodonImported = MastodonData.isImported();
            const stats = MastodonData.getStats();
            const maxDay = stats?.dayRange?.max || 275;

            React.useEffect(() => {
                const loadDataForDay = async () => {
                    setIsLoading(true);
                    setError('');
                    try {
                        if (activeView === 'blog' && isMastodonImported) {
                            const post = MastodonData.getPostByDay(dayNumber);
                            setCurrentPost(post);
                            if (!post) setError('Aucun post pour ce jour.');
                        } else if (activeView === 'photos' && isConnected) {
                            const fetchedPhotos = await GoogleDriveAPI.getPhotosByDay(dayNumber);
                            setPhotos(fetchedPhotos);
                            if (fetchedPhotos.length === 0) setError('Aucune photo trouv√©e pour ce jour.');
                        }
                    } catch (err) {
                        setError('Erreur lors du chargement des donn√©es.');
                    } finally {
                        setIsLoading(false);
                    }
                };
                loadDataForDay();
            }, [dayNumber, activeView, isConnected, isMastodonImported]);

            const showRandomMemory = async () => {
                const randomDay = Math.floor(Math.random() * maxDay) + 1;
                const randomView = Math.random() < 0.5 ? 'blog' : 'photos';
                
                // Si la vue choisie n'est pas disponible, on prend l'autre
                if ((randomView === 'blog' && !isMastodonImported) || (randomView === 'photos' && !isConnected)) {
                    setActiveView(activeView === 'blog' ? 'photos' : 'blog');
                } else {
                    setActiveView(randomView);
                }
                setDayNumber(randomDay);
            };

            const openPhotoModal = (photo) => { setSelectedPhoto(photo); setIsModalOpen(true); };
            const closePhotoModal = () => setIsModalOpen(false);

            const createSessionFromModal = () => {
                if (!selectedPhoto) return;
                const game = getGameById(1); // Photo roulette
                window.pendingGameSession = { 
                    game: { ...game, title: `Souvenir du Jour ${dayNumber}` },
                    user: currentUser, 
                    postChapo: `√Ä propos de la photo: "${selectedPhoto.title}"`,
                    photoUrl: selectedPhoto.thumbnailUrl
                };
                onCreateSession('chat');
                closePhotoModal();
            };
            
            const createSessionFromPost = (post) => {
                const game = getGameById(7); // Souvenir du jour
                window.pendingGameSession = { 
                    game: { ...game, title: `Souvenir du Jour ${post.dayNumber}` },
                    user: currentUser, 
                    postChapo: `Souvenir du Jour ${post.dayNumber}:\n${post.content.slice(0, 150)}...`
                };
                onCreateSession('chat');
            };

            const MastodonPostImages = ({ attachments }) => {
                const [imageUrls, setImageUrls] = React.useState([]);
                const mastodonMediaPath = Storage.get('mastodonMediaPath', '/Medias/Mastodon/');

                React.useEffect(() => {
                    const fetchImageUrls = async () => {
                        const urls = [];
                        for (const attachment of attachments) {
                            if (attachment.type === 'Image' && attachment.url) {
                                const filename = attachment.url.split('/').pop();
                                const pathOnly = attachment.url.substring(0, attachment.url.lastIndexOf('/'));
                                const fullPath = mastodonMediaPath + 'media_attachments/files/' + pathOnly;
                                const file = await GoogleDriveAPI.findFileByPartialPath(filename, fullPath);
                                if (file?.webContentLink) {
                                    urls.push(file.webContentLink);
                                }
                            }
                        }
                        setImageUrls(urls);
                    };
                    if (attachments && attachments.length > 0 && isConnected) {
                        fetchImageUrls();
                    }
                }, [attachments, isConnected]);

                if (imageUrls.length === 0) return null;
                return (
                    <div className="mt-4 grid grid-cols-2 gap-2">
                        {imageUrls.map((url, index) => (
                           <a href={url} target="_blank" rel="noopener noreferrer"><img key={index} src={url} alt={`Pi√®ce jointe ${index + 1}`} className="rounded-lg border hover:opacity-80" /></a>
                        ))}
                    </div>
                );
            };

            return (
                <div className="space-y-6 fade-in">
                    <div className="flex justify-center bg-gray-100 p-1 rounded-lg">
                        <button onClick={() => setActiveView('blog')} disabled={!isMastodonImported} className={`w-full py-2 px-4 rounded-md font-semibold transition-colors ${activeView === 'blog' ? 'bg-white text-amber-600 shadow' : 'text-gray-600'} disabled:opacity-50 disabled:cursor-not-allowed`}>Blog</button>
                        <button onClick={() => setActiveView('photos')} disabled={!isConnected} className={`w-full py-2 px-4 rounded-md font-semibold transition-colors ${activeView === 'photos' ? 'bg-white text-amber-600 shadow' : 'text-gray-600'} disabled:opacity-50 disabled:cursor-not-allowed`}>Photos</button>
                    </div>

                    <div className="bg-white p-4 rounded-lg border border-gray-200 space-y-4">
                        <div className="flex items-center space-x-4">
                            <label className="font-medium text-gray-700">Jour</label>
                            <input type="range" min="1" max={maxDay} value={dayNumber} onChange={(e) => setDayNumber(parseInt(e.target.value))} className="flex-1"/>
                            <span className="font-bold text-lg text-amber-800 w-12 text-center">{dayNumber}</span>
                        </div>
                        <div className="text-center">
                            <button onClick={showRandomMemory} className="px-6 py-2 bg-orange-500 hover:bg-orange-600 text-white rounded-full font-semibold flex items-center justify-center space-x-2 mx-auto">
                                <Shuffle className="w-5 h-5"/>
                                <span>Souvenir au hasard</span>
                            </button>
                        </div>
                    </div>
                    
                    {isLoading && <div className="text-center py-12">Chargement...</div>}
                    {error && !isLoading && <div className="text-center py-12 text-gray-500">{error}</div>}

                    {!isLoading && !error && activeView === 'blog' && currentPost && (
                        <div className="bg-white p-6 rounded-lg border border-gray-200">
                            <div className="flex justify-between items-start mb-4">
                                <h3 className="text-2xl font-bold text-amber-900">{currentPost.title}</h3>
                                <button onClick={() => createSessionFromPost(currentPost)} className="flex items-center space-x-2 px-3 py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg text-sm font-semibold"><Plus className="w-4 h-4" /> <span>Session</span></button>
                            </div>
                            <p className="text-gray-800 leading-relaxed whitespace-pre-line">{currentPost.content}</p>
                            <MastodonPostImages attachments={currentPost.attachments} />
                        </div>
                    )}

                    {!isLoading && !error && activeView === 'photos' && photos.length > 0 && (
                        <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                            {photos.map(photo => (
                                <div key={photo.id} className="group relative border rounded-lg overflow-hidden cursor-pointer" onClick={() => openPhotoModal(photo)}>
                                    <img src={photo.thumbnailUrl} alt={photo.title} className="w-full h-full object-cover aspect-square"/>
                                    <div className="absolute inset-0 bg-black/60 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center p-2">
                                        <p className="text-white text-xs text-center">{photo.title}</p>
                                    </div>
                                </div>
                            ))}
                        </div>
                    )}

                    {isModalOpen && selectedPhoto && (
                        <div className="fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4" onClick={closePhotoModal}>
                            <div className="bg-white rounded-lg shadow-2xl max-w-4xl max-h-full flex flex-col" onClick={e => e.stopPropagation()}>
                                <img src={selectedPhoto.fullUrl || selectedPhoto.viewUrl} alt={selectedPhoto.title} className="object-contain w-full h-auto flex-1 p-2"/>
                                <div className="p-4 bg-gray-50 border-t flex flex-col sm:flex-row justify-between items-center gap-4">
                                    <p className="text-gray-800 text-center sm:text-left">{selectedPhoto.title}</p>
                                    <div className="flex space-x-3">
                                        <button onClick={closePhotoModal} className="px-4 py-2 bg-gray-200 hover:bg-gray-300 text-gray-800 rounded-lg">Fermer</button>
                                        <button onClick={createSessionFromModal} className="px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg font-semibold">Cr√©er une session</button>
                                    </div>
                                </div>
                            </div>
                            <button onClick={closePhotoModal} className="absolute top-4 right-4 text-white hover:text-gray-300"><X className="w-8 h-8"/></button>
                        </div>
                    )}
                </div>
            );
        };
		
        // ==== PAGE R√âGLAGES (AM√âLIOR√âE AVEC CONFIGURATION MASTODON MEDIA) =====
        const SettingsPage = ({ onReset, googleAuth, onGoogleDisconnect }) => {
            const { isConnected, isLoading, userInfo, signIn, signOut } = googleAuth;
            const [photoPath, setPhotoPath] = React.useState(Storage.get('photoFolderPath', '/Medias/Photos/'));
            const [mastodonPath, setMastodonPath] = React.useState(Storage.get('mastodonMediaPath', '/Medias/Mastodon/'));
            
            const savePaths = () => {
                Storage.set('photoFolderPath', photoPath);
                Storage.set('mastodonMediaPath', mastodonPath);
                // Vider les caches pour forcer la re-recherche avec les nouveaux chemins
                GoogleDriveAPI._folderIdCache.clear();
                GoogleDriveAPI._fileIdCache.clear();
                alert('Chemins de dossiers sauvegard√©s !');
            };

            return (
                <div className="space-y-6 fade-in">
                    <GoogleConnection isConnected={isConnected} isLoading={isLoading} userInfo={userInfo} onSignIn={signIn} onSignOut={onGoogleDisconnect || signOut} />
                    
                    <div className="bg-white p-6 rounded-lg shadow-md space-y-4">
                        <h3 className="text-lg font-semibold text-gray-900">Configuration Google Drive</h3>
                        <div>
                            <label htmlFor="photoPath" className="block text-sm font-medium text-gray-700 mb-1">Chemin du dossier Photos de voyage</label>
                            <input type="text" id="photoPath" value={photoPath} onChange={e => setPhotoPath(e.target.value)} className="w-full px-3 py-2 border border-gray-300 rounded-lg" placeholder="/Medias/Photos/"/>
                        </div>
                        <div>
                            <label htmlFor="mastodonPath" className="block text-sm font-medium text-gray-700 mb-1">Chemin du dossier racine des M√©dias Mastodon</label>
                            <input type="text" id="mastodonPath" value={mastodonPath} onChange={e => setMastodonPath(e.target.value)} className="w-full px-3 py-2 border border-gray-300 rounded-lg" placeholder="/Medias/Mastodon/"/>
                             <p className="text-xs text-gray-500 mt-2">Doit pointer vers le dossier qui contient `media_attachments`.</p>
                        </div>
                        <div className="text-right">
                             <button onClick={savePaths} className="px-4 py-2 bg-amber-500 hover:bg-amber-600 text-white rounded-lg">Sauvegarder les chemins</button>
                        </div>
                    </div>

                    {/* ... (sections Import Mastodon et Donn√©es inchang√©es) */}
                </div>
            );
        };
		
        // ===== MAIN APP et autres pages (inchang√©s en structure) =====
        const MemoireMekong = () => {
             const { currentPage, setCurrentPage, currentUser, setCurrentUser, resetApp } = useAppState();
            const googleAuth = useGoogleAuth();
            const { isConnected, isLoading, userInfo, signIn, signOut } = googleAuth;
            const { createSession } = useSessionState();
            const [currentChatSession, setCurrentChatSession] = React.useState(null);
            const [toast, setToast] = React.useState({ message: '', type: '' });

            const handleCreateSession = (page) => {
                if (window.pendingGameSession) {
                    createSession(window.pendingGameSession.game, currentUser).then(newSession => {
                        setCurrentChatSession(newSession);
                        setCurrentPage(page);
                    });
                }
            };
            
            // Le reste de la logique Main App est structurellement la m√™me
            return (
                <div className="min-h-screen bg-gradient-to-br from-amber-50 to-orange-100">
                    <TopBar /* ... */ />
                    <main className="p-4 pb-24">
                        <div className="max-w-6xl mx-auto">
                            <div className="bg-white/80 backdrop-blur rounded-xl shadow-lg p-6">
                                {currentPage === 'home' && <HomePage /* ... */ />}
                                {currentPage === 'games' && <GamesPage /* ... */ />}
                                {currentPage === 'sessions' && <SessionsPage /* ... */ />}
                                {currentPage === 'chat' && <ChatPage currentSession={currentChatSession} /* ... */ />}
                                {currentPage === 'memories' && <MemoriesPage currentUser={currentUser} onCreateSession={handleCreateSession} />}
                                {currentPage === 'settings' && <SettingsPage googleAuth={googleAuth} /* ... */ />}
                                {currentPage === 'users' && <UsersPage /* ... */ />}
                            </div>
                        </div>
                    </main>
                    <BottomNavBar /* ... */ />
                    <Toast /* ... */ />
                </div>
            );
        };

        // ===== RENDER =====
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(MemoireMekong));
    </script>
</body>
</html>
