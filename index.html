<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üêò M√©moire du M√©kong V0.6.4 (Stable Corrig√©)</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://apis.google.com/js/api.js"></script>
	<script src="https://accounts.google.com/gsi/client"></script>
	<script>
	window.onload = () => {
  		google.accounts.id.initialize({
    		client_id: '82966045106-hso0nr386agcuojllnud0dr41vcsh45a.apps.googleusercontent.com'
  		});
		};
	</script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .lucide { width: 1em; height: 1em; fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; }
        .fade-in { animation: fadeIn 0.3s ease-in; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        /* Style pour le slider */
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 20px; width: 20px; border-radius: 50%; background: #c2410c; cursor: pointer; margin-top: -8px; }
        input[type=range]::-moz-range-thumb { height: 20px; width: 20px; border-radius: 50%; background: #c2410c; cursor: pointer; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #fbbf24; border-radius: 5px; }
        input[type=range]::-moz-range-track { width: 100%; height: 4px; cursor: pointer; background: #fbbf24; border-radius: 5px; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // ===== ICONS LUCIDE =====
        const X = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>;
        const Home = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9,22 9,12 15,12 15,22"/></svg>;
        const Users = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="m22 21-2-2"/></svg>;
        const Camera = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/></svg>;
        const Cloud = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z"/></svg>;
        const Settings = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M12.22 2h-.44a2 2 0 0 0-2 2.18l.2 1.81c-.26.06-.51.14-.76.23l-1.5-1.16a2 2 0 0 0-2.83.32l-.22.38a2 2 0 0 0 .32 2.83l1.16 1.5c-.09.25-.17.5-.23.76l-1.81.2a2 2 0 0 0-2.18 2v.44a2 2 0 0 0 2.18 2l1.81.2c.06.26.14.51.23.76l-1.16 1.5a2 2 0 0 0-.32 2.83l.38.22a2 2 0 0 0 2.83-.32l1.5-1.16c.25.09.5.17.76.23l.2 1.81a2 2 0 0 0 2 2.18h.44a2 2 0 0 0 2-2.18l.2-1.81c.26-.06.51-.14-.76-.23l1.5 1.16a2 2 0 0 0 2.83-.32l.22-.38a2 2 0 0 0-.32-2.83l-1.16-1.5c.09-.25-.17-.5-.23-.76l1.81-.2a2 2 0 0 0 2.18-2v-.44a2 2 0 0 0-2.18-2l-1.81-.2c-.06-.26-.14-.51-.23-.76l1.16-1.5a2 2 0 0 0 .32-2.83l-.38-.22a2 2 0 0 0-2.83.32l-1.5 1.16c-.25-.09-.5-.17-.76-.23l-.2-1.81a2 2 0 0 0-2-2.18Z"/><circle cx="12" cy="12" r="3"/></svg>;
        const BookOpen = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg>;
        const Plus = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M5 12h14"/><path d="M12 5v14"/></svg>;
        const Shuffle = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><polyline points="16,3 21,3 21,8"/><line x1="4" x2="21" y1="20" y2="3"/><polyline points="21,16 21,21 16,21"/><line x1="15" x2="21" y1="15" y2="21"/><line x1="4" x2="9" y1="4" y2="9"/></svg>;

		// ===== COMPOSANT TOAST (Alerte) =====
		const Toast = ({ message, type, onDismiss }) => {
    		if (!message) return null;
    		const styles = {
        		error: { bg: 'bg-red-100', text: 'text-red-800', border: 'border-red-300' },
        		success: { bg: 'bg-green-100', text: 'text-green-800', border: 'border-green-300' }
    		};
    		const style = styles[type] || styles.error;
    		return (
        		<div className={`fixed bottom-4 right-4 max-w-sm p-4 border rounded-lg shadow-lg fade-in ${style.bg} ${style.text} ${style.border}`}>
            		<div className="flex justify-between items-center">
                		<span>{message}</span>
                		<button onClick={onDismiss} className="ml-4 text-xl font-bold">&times;</button>
            		</div>
        		</div>
    		);
		};
		
        // ===== CORE STORAGE =====
        const Storage = {
            get: (key, defaultValue = null) => {
                try {
                    const item = localStorage.getItem(`mekong_${key}`);
                    return item ? JSON.parse(item) : defaultValue;
                } catch { return defaultValue; }
            },
            set: (key, value) => {
                try {
                    localStorage.setItem(`mekong_${key}`, JSON.stringify(value));
                    return true;
                } catch { return false; }
            },
            remove: (key) => localStorage.removeItem(`mekong_${key}`),
            clear: () => {
                Object.keys(localStorage).forEach(key => {
                    if (key.startsWith('mekong_')) localStorage.removeItem(key);
                });
            }
        };

        // ===== CORE STATES =====
        const useAppState = () => {
            const [currentPage, setCurrentPage] = React.useState('home');
            const [currentUser, setCurrentUser] = React.useState(Storage.get('currentUser', ''));
            
            React.useEffect(() => {
                Storage.set('currentUser', currentUser);
            }, [currentUser]);

            const resetApp = () => {
                setCurrentPage('home');
                setCurrentUser('');
                Storage.clear();
            };

            return { currentPage, setCurrentPage, currentUser, setCurrentUser, resetApp };
        };
		
        // ===== MASTODON DATA MANAGEMENT =====
        const MastodonData = {
            decodeHtmlEntities: (text) => {
                if (typeof text !== 'string') return '';
                const textArea = document.createElement('textarea');
                textArea.innerHTML = text;
                return textArea.value;
            },
            parseOutbox: (jsonData) => {
                try {
                    const data = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;
                    const orderedItems = data.orderedItems || data.data?.orderedItems;
                    if (!Array.isArray(orderedItems)) throw new Error('orderedItems non trouv√© ou invalide');

                    const allPosts = orderedItems
                        .filter(item => item.type === 'Create' && item.object?.type === 'Note')
                        .map((item, index) => {
                            const note = item.object;
                            const content = note.content || '';
                            
                            const cleanContent = content.replace(/<p>|<\/p>/g, '\n').replace(/<br\s*\/?>/g, '\n').replace(/<[^>]*>/g, '').trim();
                            const decodedContent = MastodonData.decodeHtmlEntities(cleanContent);
                            
                            const dayMatch = decodedContent.match(/^J(\d{1,3})[\s:]/);
                            const dayNumber = dayMatch ? parseInt(dayMatch[1]) : null;
                            const hasJourNumber = dayNumber !== null;
                            
                            let title;
                            if (hasJourNumber) {
                                const afterJour = decodedContent.replace(/^J\d{1,3}[\s:]+/, '');
                                title = MastodonData.decodeHtmlEntities(afterJour.split('\n')[0].trim());
                            } else {
                                title = MastodonData.decodeHtmlEntities(decodedContent.split('\n')[0].trim());
                            }
                            
                            return {
                                id: note.id || `post-${index}`,
                                dayNumber, hasJourNumber,
                                title: title.slice(0, 80) || 'Post sans titre',
                                content: decodedContent,
                                published: note.published || item.published,
                                attachments: note.attachment || [],
                                url: note.url,
                            };
                        });

                    const postsWithDay = allPosts.filter(post => post.hasJourNumber);
                    const postsWithoutDay = allPosts.filter(post => !post.hasJourNumber);
                    postsWithDay.sort((a, b) => a.dayNumber - b.dayNumber);
                    const maxDayNumber = postsWithDay.length > 0 ? Math.max(...postsWithDay.map(p => p.dayNumber)) : 0;
                    postsWithoutDay.forEach((post, index) => {
                        post.dayNumber = maxDayNumber + index + 1;
                        post.isExtraPost = true;
                    });
                    const finalPosts = [...postsWithDay, ...postsWithoutDay];
                    finalPosts.forEach(post => { delete post.hasJourNumber; });
                    return finalPosts;
                } catch (error) {
                    console.error('‚ùå Erreur parsing outbox:', error);
                    throw error;
                }
            },
            getPosts: () => Storage.get('mastodon_posts', []),
            getPostByDay: (dayNumber) => MastodonData.getPosts().find(p => p.dayNumber === dayNumber),
            isImported: () => MastodonData.getPosts().length > 0,
            getStats: () => {
                const posts = MastodonData.getPosts();
                if (posts.length === 0) return { totalPosts: 0, dayRange: null, importedAt: null };
                const dayNumbers = posts.map(p => p.dayNumber).filter(n => n !== null);
                return {
                    totalPosts: posts.length,
                    dayRange: dayNumbers.length > 0 ? {
                        min: Math.min(...dayNumbers),
                        max: Math.max(...dayNumbers)
                    } : null,
                    importedAt: Storage.get('mastodon_imported_at')
                };
            },
        };

        // ===== GOOGLE DRIVE API =====
        const GoogleDriveAPI = {
            isSignedIn: false, isInitialized: false, tokenClient: null,
            _folderIdCache: new Map(), _fileIdCache: new Map(),
            
            async init() {
                if (this.isInitialized) return;
                try {
                    await new Promise((resolve) => gapi.load('client', resolve));
                    await gapi.client.init({
                        apiKey: 'AIzaSyDiyLLN4EsyVREGxF4TzqbuKyugaq4TUXw',
                        discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest']
                    });
                    this.tokenClient = google.accounts.oauth2.initTokenClient({
                        client_id: '82966045106-hso0nr386agcuojllnud0dr41vcsh45a.apps.googleusercontent.com',
                        scope: 'https://www.googleapis.com/auth/drive.readonly https://www.googleapis.com/auth/userinfo.profile https://www.googleapis.com/auth/userinfo.email',
                        callback: ''
                    });
                    this.isInitialized = true;
                } catch (error) {
                    console.error('‚ùå Erreur init Google Drive API:', error);
                    throw error;
                }
            },
            
            async signIn() {
                if (!this.isInitialized) await this.init();
                return new Promise((resolve, reject) => {
                    if (!this.tokenClient) return reject(new Error('Token client non initialis√©'));
                    this.tokenClient.callback = async (response) => {
                        if (response.error) {
                            this.isSignedIn = false;
                            return reject(new Error(`Erreur OAuth: ${response.error}`));
                        }
                        try {
                            await gapi.client.drive.files.list({ pageSize: 1 });
                            this.isSignedIn = true;
                            resolve(true);
                        } catch (error) {
                            this.isSignedIn = false;
                            reject(new Error('Acc√®s API Drive impossible'));
                        }
                    };
                    const token = gapi.client.getToken();
                    if (token) {
                        gapi.client.drive.files.list({ pageSize: 1 })
                            .then(() => { this.isSignedIn = true; resolve(true); })
                            .catch(() => {
                                gapi.client.setToken('');
                                this.tokenClient.requestAccessToken({ prompt: 'consent' });
                            });
                    } else {
                        this.tokenClient.requestAccessToken({ prompt: 'consent' });
                    }
                });
            },
            
            async signOut() {
                const token = gapi.client.getToken();
                if (token) {
                    google.accounts.oauth2.revoke(token.access_token);
                    gapi.client.setToken('');
                }
                this.isSignedIn = false;
            },

            async findFolderByPath(path) {
                if (this._folderIdCache.has(path)) return this._folderIdCache.get(path);
                const parts = path.split('/').filter(p => p);
                let parentId = 'root';
                for (const part of parts) {
                    try {
                        const response = await gapi.client.drive.files.list({
                            q: `'${parentId}' in parents and mimeType='application/vnd.google-apps.folder' and name='${part}' and trashed=false`,
                            fields: 'files(id, name)'
                        });
                        const folder = response.result.files[0];
                        if (!folder) throw new Error(`Dossier non trouv√©: ${part}`);
                        parentId = folder.id;
                    } catch (error) {
                        console.error(`Erreur recherche dossier ${part}:`, error);
                        return null;
                    }
                }
                this._folderIdCache.set(path, parentId);
                return parentId;
            },

            async getPhotosByDay(dayNumber) {
                const photoFolderPath = Storage.get('photoFolderPath', '/Medias/Photos/');
                const parentFolderId = await this.findFolderByPath(photoFolderPath);
                if (!parentFolderId) return [];
                const dayString = String(dayNumber).padStart(3, '0');
                try {
                    const folderResponse = await gapi.client.drive.files.list({
                        q: `'${parentFolderId}' in parents and mimeType='application/vnd.google-apps.folder' and name starts with '${dayString}' and trashed=false`,
                        fields: 'files(id, name)'
                    });
                    const dayFolder = folderResponse.result.files[0];
                    if (!dayFolder) return [];
                    const photosResponse = await gapi.client.drive.files.list({
                        q: `'${dayFolder.id}' in parents and mimeType contains 'image/' and trashed=false`,
                        fields: 'files(id, name, thumbnailLink, webViewLink, webContentLink)',
                        pageSize: 50
                    });
                    return (photosResponse.result.files || []).map(file => ({
                        id: file.id, title: file.name, thumbnailUrl: file.thumbnailLink,
                        fullUrl: file.webContentLink, viewUrl: file.webViewLink
                    }));
                } catch (error) {
                    console.error(`Erreur chargement photos jour ${dayNumber}:`, error);
                    return [];
                }
            },
            
            async findFileByPartialPath(filename, rootPath) {
                const cacheKey = `${rootPath}:${filename}`;
                if (this._fileIdCache.has(cacheKey)) return this._fileIdCache.get(cacheKey);
                const rootFolderId = await this.findFolderByPath(rootPath);
                if (!rootFolderId) return null;
                try {
                    const response = await gapi.client.drive.files.list({
                        q: `'${rootFolderId}' in parents and name='${filename}' and trashed=false`,
                        fields: 'files(id, webViewLink, webContentLink, thumbnailLink)',
                        pageSize: 1
                    });
                    const file = response.result.files[0];
                    if (file) {
                        this._fileIdCache.set(cacheKey, file);
                        return file;
                    }
                    return null;
                } catch (error) {
                    console.error(`Erreur recherche fichier ${filename}:`, error);
                    return null;
                }
            }
        };

        // ===== USER CONFIG =====
        const USERS = { tom: { name: 'Tom le jeune √©l√©phanteau', color: 'blue', emoji: 'üêò' }, lambert: { name: 'Lambert, le Vieux Pachiderme', color: 'green', emoji: 'üêò' }, duo: { name: 'Duo Mekong Tandem', color: 'amber', emoji: 'üêòüêò' } };
        const getUserStyle = (userKey) => { /* ... */ };

        // ===== SESSION MANAGEMENT & HOOKS =====
        const CloudSessionStorage = { /* ... */ };
        const useSessionState = () => {
            const [currentSession, setCurrentSession] = React.useState(null);
            const [sessions, setSessions] = React.useState([]);

            React.useEffect(() => { /* ... */ }, []);

            const createSession = async (game, user) => {
                const pendingSession = window.pendingGameSession || {};
                const newSession = {
                    id: Date.now(),
                    gameId: Number(game.id), gameTitle: game.title, user: user,
                    createdAt: new Date().toISOString(), updatedAt: new Date().toISOString(),
                    status: 'active',
                    notes: pendingSession.postChapo ? [{ id: Date.now() - 1, content: pendingSession.postChapo.trim(), author: 'duo', timestamp: new Date().toISOString() }] : [],
                    photoUrl: pendingSession.photoUrl || null
                };
                await CloudSessionStorage.saveSession(newSession);
                const updatedSessions = await CloudSessionStorage.getSessions();
                setSessions(updatedSessions);
                setCurrentSession(newSession);
                if (window.pendingGameSession) delete window.pendingGameSession;
                return newSession;
            };
            const updateSession = async (updatedSession) => { /* ... */ };
            const deleteSession = async (sessionId) => { /* ... */ };
            return { currentSession, sessions, createSession, updateSession, deleteSession };
        };
        
        const useGoogleAuth = () => {
            const [isConnected, setIsConnected] = React.useState(false);
            const [isLoading, setIsLoading] = React.useState(true);
            const [userInfo, setUserInfo] = React.useState(null);

            React.useEffect(() => {
                const initGoogle = async () => {
                    setIsLoading(true);
                    try {
                        await GoogleDriveAPI.init();
                        const token = gapi.client.getToken();
                        if (token) {
                            try {
                                await new Promise(resolve => setTimeout(resolve, 100));
                                await gapi.client.drive.files.list({ pageSize: 1 });
                                const response = await fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
                                    headers: { 'Authorization': `Bearer ${token.access_token}` }
                                });
                                if (response.ok) {
                                    const profile = await response.json();
                                    setUserInfo({ name: profile.name, email: profile.email, picture: profile.picture });
                                    setIsConnected(true);
                                    GoogleDriveAPI.isSignedIn = true;
                                } else { throw new Error('Token invalide'); }
                            } catch (error) { gapi.client.setToken(''); }
                        }
                    } catch (error) { console.error("Erreur d'initialisation Google", error); } 
                    finally { setIsLoading(false); }
                };
                initGoogle();
            }, []);

            const signIn = async () => {
                setIsLoading(true);
                try {
                    const success = await GoogleDriveAPI.signIn();
                    if (success) {
                        const token = gapi.client.getToken();
                        const response = await fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
                            headers: { 'Authorization': `Bearer ${token.access_token}` }
                        });
                        if (!response.ok) throw new Error('Impossible de r√©cup√©rer le profil utilisateur');
                        const profile = await response.json();
                        setUserInfo({ name: profile.name, email: profile.email, picture: profile.picture });
                        setIsConnected(true);
                        return true;
                    } throw new Error('√âchec de la connexion Google Drive');
                } catch (error) {
                    setIsConnected(false); setUserInfo(null);
                    console.error('Erreur de connexion:', error);
                    return false;
                } finally { setIsLoading(false); }
            };

            const signOut = async () => {
                setIsLoading(true);
                try {
                    await GoogleDriveAPI.signOut();
                    setIsConnected(false); setUserInfo(null);
                } catch (error) { console.error('Erreur d√©connexion:', error); } 
                finally { setIsLoading(false); }
            };

            return { isConnected, isLoading, userInfo, signIn, signOut };
        };

        // ===== UI COMPONENTS =====
        const TopBar = ({ currentPage, currentUser, onUserChange, onPageChange, googleStatus, onGoogleAction }) => { /* ... */ };
        const BottomNavBar = ({ currentPage, onPageChange, currentUser }) => { /* ... */ };
        const GoogleConnection = ({ isConnected, isLoading, userInfo, onSignIn, onSignOut }) => { /* ... */ };
        
        // ===== GAME DATA =====
        const GAMES = [ /* ... */ ];
        const getGameById = (gameId) => GAMES.find(g => g.id === gameId);

        // ===== PAGES =====
        const HomePage = ({ currentUser, onUserChange, onPageChange }) => { /* ... */ };
        const UsersPage = ({ currentUser, onUserChange, onPageChange }) => { /* ... */ };
        const GamesPage = ({ currentUser, onPageChange, onGameSelect }) => { /* ... */ };
        const SessionsPage = ({ currentUser, onPageChange, onSessionSelect }) => { /* ... */ };
        const ChatPage = ({ currentUser, currentSession, onUpdateSession, onBackToSessions }) => { /* ... */ };
        const MemoriesPage = ({ currentUser, onCreateSession }) => {
            const [activeView, setActiveView] = React.useState('blog');
            const [dayNumber, setDayNumber] = React.useState(1);
            const [currentPost, setCurrentPost] = React.useState(null);
            const [photos, setPhotos] = React.useState([]);
            const [isLoading, setIsLoading] = React.useState(false);
            const [error, setError] = React.useState('');
            const [isModalOpen, setIsModalOpen] = React.useState(false);
            const [selectedPhoto, setSelectedPhoto] = React.useState(null);
            const { isConnected } = useGoogleAuth();
            const isMastodonImported = MastodonData.isImported();
            const stats = MastodonData.getStats();
            const maxDay = stats?.dayRange?.max || 275;

            React.useEffect(() => {
                const loadDataForDay = async () => {
                    setIsLoading(true); setError('');
                    try {
                        if (activeView === 'blog' && isMastodonImported) {
                            const post = MastodonData.getPostByDay(dayNumber);
                            setCurrentPost(post); setPhotos([]);
                            if (!post) setError('Aucun post pour ce jour.');
                        } else if (activeView === 'photos' && isConnected) {
                            const fetchedPhotos = await GoogleDriveAPI.getPhotosByDay(dayNumber);
                            setPhotos(fetchedPhotos); setCurrentPost(null);
                            if (fetchedPhotos.length === 0) setError('Aucune photo trouv√©e pour ce jour.');
                        }
                    } catch (err) { setError('Erreur lors du chargement des donn√©es.'); console.error(err); } 
                    finally { setIsLoading(false); }
                };
                loadDataForDay();
            }, [dayNumber, activeView, isConnected, isMastodonImported]);

            const showRandomMemory = async () => {
                const randomDay = Math.floor(Math.random() * maxDay) + 1;
                const availableViews = [];
                if (isMastodonImported) availableViews.push('blog');
                if (isConnected) availableViews.push('photos');
                if (availableViews.length === 0) return;
                const randomView = availableViews[Math.floor(Math.random() * availableViews.length)];
                setActiveView(randomView);
                setDayNumber(randomDay);
            };

            const openPhotoModal = (photo) => { setSelectedPhoto(photo); setIsModalOpen(true); };
            const closePhotoModal = () => setIsModalOpen(false);

            const createSessionFromModal = () => {
                if (!selectedPhoto) return;
                const game = getGameById(1);
                window.pendingGameSession = { 
                    game: { ...game, title: `Souvenir du Jour ${dayNumber}` },
                    user: currentUser, 
                    postChapo: `√Ä propos de la photo: "${selectedPhoto.title}"`,
                    photoUrl: selectedPhoto.thumbnailUrl
                };
                onCreateSession('chat');
                closePhotoModal();
            };
            
            const createSessionFromPost = (post) => {
                const game = getGameById(7);
                window.pendingGameSession = { 
                    game: { ...game, title: `Souvenir du Jour ${post.dayNumber}` },
                    user: currentUser, 
                    postChapo: `Souvenir du Jour ${post.dayNumber}:\n${post.content.slice(0, 150)}...`
                };
                onCreateSession('chat');
            };

            const MastodonPostImages = ({ attachments }) => {
                const [imageUrls, setImageUrls] = React.useState([]);
                const mastodonMediaPath = Storage.get('mastodonMediaPath', '/Medias/Mastodon/');

                React.useEffect(() => {
                    const fetchImageUrls = async () => {
                        const urls = new Map();
                        for (const attachment of attachments) {
                            if (attachment.type === 'Image' && attachment.url) {
                                const filename = attachment.url.split('/').pop();
                                const pathOnly = attachment.url.substring(0, attachment.url.lastIndexOf('/'));
                                const fullPath = mastodonMediaPath + 'media_attachments/files/' + pathOnly;
                                const file = await GoogleDriveAPI.findFileByPartialPath(filename, fullPath);
                                if (file?.webContentLink) {
                                    urls.set(attachment.id, file.webContentLink);
                                }
                            }
                        }
                        setImageUrls(Array.from(urls.values()));
                    };
                    if (attachments && attachments.length > 0 && isConnected) {
                        fetchImageUrls();
                    }
                }, [attachments, isConnected]);

                if (imageUrls.length === 0) return null;
                return (
                    <div className="mt-4 grid grid-cols-2 gap-2">
                        {imageUrls.map((url, index) => (
                           <a key={index} href={url} target="_blank" rel="noopener noreferrer"><img src={url} alt={`Pi√®ce jointe ${index + 1}`} className="rounded-lg border hover:opacity-80" /></a>
                        ))}
                    </div>
                );
            };

            return (
                <div className="space-y-6 fade-in">
                    <div className="flex justify-center bg-gray-100 p-1 rounded-lg">
                        <button onClick={() => setActiveView('blog')} disabled={!isMastodonImported} className={`w-full py-2 px-4 rounded-md font-semibold transition-colors ${activeView === 'blog' ? 'bg-white text-amber-600 shadow' : 'text-gray-600'} disabled:opacity-50 disabled:cursor-not-allowed`}>Blog</button>
                        <button onClick={() => setActiveView('photos')} disabled={!isConnected} className={`w-full py-2 px-4 rounded-md font-semibold transition-colors ${activeView === 'photos' ? 'bg-white text-amber-600 shadow' : 'text-gray-600'} disabled:opacity-50 disabled:cursor-not-allowed`}>Photos</button>
                    </div>

                    <div className="bg-white p-4 rounded-lg border border-gray-200 space-y-4">
                        <div className="flex items-center space-x-4">
                            <label className="font-medium text-gray-700">Jour</label>
                            <input type="range" min="1" max={maxDay} value={dayNumber} onChange={(e) => setDayNumber(parseInt(e.target.value))} className="flex-1"/>
                            <span className="font-bold text-lg text-amber-800 w-12 text-center">{dayNumber}</span>
                        </div>
                        <div className="text-center">
                            <button onClick={showRandomMemory} className="px-6 py-2 bg-orange-500 hover:bg-orange-600 text-white rounded-full font-semibold flex items-center justify-center space-x-2 mx-auto">
                                <Shuffle className="w-5 h-5"/>
                                <span>Souvenir au hasard</span>
                            </button>
                        </div>
                    </div>
                    
                    {isLoading && <div className="text-center py-12">Chargement...</div>}
                    {error && !isLoading && <div className="text-center py-12 text-gray-500">{error}</div>}

                    {!isLoading && !error && activeView === 'blog' && currentPost && (
                        <div className="bg-white p-6 rounded-lg border border-gray-200">
                            <div className="flex justify-between items-start mb-4">
                                <h3 className="text-2xl font-bold text-amber-900">{currentPost.title}</h3>
                                <button onClick={() => createSessionFromPost(currentPost)} className="flex items-center space-x-2 px-3 py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg text-sm font-semibold"><Plus className="w-4 h-4" /> <span>Session</span></button>
                            </div>
                            <p className="text-gray-800 leading-relaxed whitespace-pre-line">{currentPost.content}</p>
                            <MastodonPostImages attachments={currentPost.attachments} />
                        </div>
                    )}

                    {!isLoading && !error && activeView === 'photos' && photos.length > 0 && (
                        <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                            {photos.map(photo => (
                                <div key={photo.id} className="group relative border rounded-lg overflow-hidden cursor-pointer" onClick={() => openPhotoModal(photo)}>
                                    <img src={photo.thumbnailUrl} alt={photo.title} className="w-full h-full object-cover aspect-square"/>
                                    <div className="absolute inset-0 bg-black/60 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center p-2">
                                        <p className="text-white text-xs text-center">{photo.title}</p>
                                    </div>
                                </div>
                            ))}
                        </div>
                    )}

                    {isModalOpen && selectedPhoto && (
                        <div className="fixed inset-0 bg-black/80 z-50 flex items-center justify-center p-4" onClick={closePhotoModal}>
                            <div className="bg-white rounded-lg shadow-2xl max-w-4xl max-h-full flex flex-col" onClick={e => e.stopPropagation()}>
                                <img src={selectedPhoto.fullUrl || selectedPhoto.viewUrl} alt={selectedPhoto.title} className="object-contain w-full h-auto flex-1 p-2"/>
                                <div className="p-4 bg-gray-50 border-t flex flex-col sm:flex-row justify-between items-center gap-4">
                                    <p className="text-gray-800 text-center sm:text-left">{selectedPhoto.title}</p>
                                    <div className="flex space-x-3">
                                        <button onClick={closePhotoModal} className="px-4 py-2 bg-gray-200 hover:bg-gray-300 text-gray-800 rounded-lg">Fermer</button>
                                        <button onClick={createSessionFromModal} className="px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg font-semibold">Cr√©er une session</button>
                                    </div>
                                </div>
                            </div>
                            <button onClick={closePhotoModal} className="absolute top-4 right-4 text-white hover:text-gray-300"><X className="w-8 h-8"/></button>
                        </div>
                    )}
                </div>
            );
        };
		
        const SettingsPage = ({ onReset, googleAuth, onGoogleDisconnect }) => {
            const { isConnected, isLoading, userInfo, signIn, signOut } = googleAuth;
            const [photoPath, setPhotoPath] = React.useState(Storage.get('photoFolderPath', '/Medias/Photos/'));
            const [mastodonPath, setMastodonPath] = React.useState(Storage.get('mastodonMediaPath', '/Medias/Mastodon/'));
            
            const savePaths = () => {
                Storage.set('photoFolderPath', photoPath);
                Storage.set('mastodonMediaPath', mastodonPath);
                GoogleDriveAPI._folderIdCache.clear();
                GoogleDriveAPI._fileIdCache.clear();
                alert('Chemins de dossiers sauvegard√©s !');
            };

            return (
                <div className="space-y-6 fade-in">
                    <GoogleConnection isConnected={isConnected} isLoading={isLoading} userInfo={userInfo} onSignIn={signIn} onSignOut={onGoogleDisconnect || signOut} />
                    <div className="bg-white p-6 rounded-lg shadow-md space-y-4">
                        <h3 className="text-lg font-semibold text-gray-900">Configuration Google Drive</h3>
                        <div>
                            <label htmlFor="photoPath" className="block text-sm font-medium text-gray-700 mb-1">Chemin du dossier Photos de voyage</label>
                            <input type="text" id="photoPath" value={photoPath} onChange={e => setPhotoPath(e.target.value)} className="w-full px-3 py-2 border border-gray-300 rounded-lg" placeholder="/Medias/Photos/"/>
                        </div>
                        <div>
                            <label htmlFor="mastodonPath" className="block text-sm font-medium text-gray-700 mb-1">Chemin du dossier racine des M√©dias Mastodon</label>
                            <input type="text" id="mastodonPath" value={mastodonPath} onChange={e => setMastodonPath(e.target.value)} className="w-full px-3 py-2 border border-gray-300 rounded-lg" placeholder="/Medias/Mastodon/"/>
                             <p className="text-xs text-gray-500 mt-2">Doit pointer vers le dossier qui contient `media_attachments`.</p>
                        </div>
                        <div className="text-right">
                             <button onClick={savePaths} className="px-4 py-2 bg-amber-500 hover:bg-amber-600 text-white rounded-lg">Sauvegarder les chemins</button>
                        </div>
                    </div>
                    {/* ... (sections Import Mastodon et Donn√©es) */}
                </div>
            );
        };
		
        const MemoireMekong = () => {
            const { currentPage, setCurrentPage, currentUser, setCurrentUser, resetApp } = useAppState();
            const googleAuth = useGoogleAuth();
            const { isConnected, isLoading, userInfo, signIn, signOut } = googleAuth;
            const sessionHook = useSessionState();
            const [currentChatSession, setCurrentChatSession] = React.useState(null);
            const [toast, setToast] = React.useState({ message: '', type: '' });

            const handleSessionSelect = (session) => {
                setCurrentChatSession(session);
                setCurrentPage('chat');
            };

            const handleCreateSessionAndNavigate = (page) => {
                if (window.pendingGameSession) {
                    sessionHook.createSession(window.pendingGameSession.game, currentUser).then(newSession => {
                        if(newSession) {
                            setCurrentChatSession(newSession);
                            setCurrentPage(page);
                        }
                    });
                } else {
                    setCurrentPage(page);
                }
            };
            
            return (
                <div className="min-h-screen bg-gradient-to-br from-amber-50 to-orange-100">
                    <TopBar 
                        currentPage={currentPage} 
                        currentUser={currentUser} 
                        onPageChange={setCurrentPage} 
                        onUserChange={setCurrentUser}
                        googleStatus={{ isConnected, isLoading, userInfo }} 
                        onGoogleAction={() => { isConnected ? setCurrentPage('settings') : signIn(); }} 
                    />
                    <main className="p-4 pb-24">
                        <div className="max-w-6xl mx-auto">
                            <div className="bg-white/80 backdrop-blur rounded-xl shadow-lg p-6">
                                {currentPage === 'home' && <HomePage currentUser={currentUser} onUserChange={setCurrentUser} onPageChange={setCurrentPage} />}
                                {currentPage === 'games' && <GamesPage currentUser={currentUser} onPageChange={setCurrentPage} onGameSelect={(game) => { window.pendingGameSession = { game, user: currentUser }; handleCreateSessionAndNavigate('chat'); }} />}
                                {currentPage === 'sessions' && <SessionsPage currentUser={currentUser} onPageChange={setCurrentPage} onSessionSelect={handleSessionSelect} />}
                                {currentPage === 'chat' && <ChatPage currentUser={currentUser} currentSession={currentChatSession || sessionHook.currentSession} onUpdateSession={sessionHook.updateSession} onBackToSessions={() => setCurrentPage('sessions')} />}
                                {currentPage === 'memories' && <MemoriesPage currentUser={currentUser} onCreateSession={(page) => handleCreateSessionAndNavigate(page)} />}
                                {currentPage === 'settings' && <SettingsPage onReset={resetApp} googleAuth={googleAuth} onGoogleDisconnect={signOut} />}
                                {currentPage === 'users' && <UsersPage currentUser={currentUser} onUserChange={setCurrentUser} onPageChange={setCurrentPage} />}
                            </div>
                        </div>
                    </main>
                    <BottomNavBar 
                        currentPage={currentPage} 
                        onPageChange={setCurrentPage} 
                        currentUser={currentUser} 
                    />
                    <Toast 
                        message={toast.message} 
                        type={toast.type} 
                        onDismiss={() => setToast({ message: '', type: '' })} 
                    />
                </div>
            );
        };

        // ===== RENDER =====
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(MemoireMekong));
    </script>
</body>
</html>
