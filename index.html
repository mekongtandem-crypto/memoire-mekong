<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M√©moire du M√©kong - V0.5.1</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <style>
        .pulse-warning { animation: pulse-warning 2s infinite; }
        @keyframes pulse-warning { 0%, 100% { opacity: 1; } 50% { opacity: 0.7; } }
        .gradient-border { background: linear-gradient(45deg, #f59e0b, #d97706) padding-box, linear-gradient(45deg, #f59e0b, #d97706) border-box; }
        .chat-bubble { max-width: 80%; word-wrap: break-word; }
        .loading-spinner { border: 2px solid #f3f3f3; border-top: 2px solid #3498db; border-radius: 50%; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        
        /* NOUVEAU : Styles Timeline */
        .timeline-container { 
            overflow-x: auto; 
            scrollbar-width: thin;
        }
        .timeline-track {
            background: linear-gradient(to right, #fbbf24 0%, #f59e0b 50%, #d97706 100%);
            height: 6px;
            border-radius: 3px;
        }
        .timeline-thumb {
            background: #dc2626;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 3px solid white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            margin-top: -7px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .timeline-thumb:hover {
            transform: scale(1.2);
            background: #b91c1c;
        }
        
        /* Styles photos */
        .photo-thumbnail {
            aspect-ratio: 1;
            object-fit: cover;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .photo-thumbnail:hover {
            transform: scale(1.05);
            box-shadow: 0 4px 12px rgba(0,0,0,0.3);
        }
    </style>
</head>
<body class="bg-gray-50">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo } = React;

        // ===== CONFIGURATION ET STORAGE =====
        const Storage = {
            get: (key, defaultValue = null) => {
                try {
                    const item = localStorage.getItem(`mekong_${key}`);
                    return item ? JSON.parse(item) : defaultValue;
                } catch { return defaultValue; }
            },
            set: (key, value) => {
                try {
                    localStorage.setItem(`mekong_${key}`, JSON.stringify(value));
                    return true;
                } catch { return false; }
            },
            remove: (key) => localStorage.removeItem(`mekong_${key}`),
            clear: () => {
                Object.keys(localStorage).forEach(key => {
                    if (key.startsWith('mekong_')) localStorage.removeItem(key);
                });
            }
        };

        // ===== GOOGLE DRIVE API - VERSION PHOTOS 0.5.0 =====
        const GOOGLE_CONFIG = {
            API_KEY: 'AIzaSyDiyLLN4EsyVREGxF4TzqbuKyugaq4TUXw',
            CLIENT_ID: '82966045106-hso0nr386agcuojllnud0dr41vcsh45a.apps.googleusercontent.com',
            // NOUVEAU : Scope readonly pour acc√©der aux photos existantes
            SCOPES: 'https://www.googleapis.com/auth/drive.readonly https://www.googleapis.com/auth/userinfo.profile https://www.googleapis.com/auth/userinfo.email'
        };

        const GoogleDriveAPI = {
            isSignedIn: false,
            isInitialized: false,
            tokenClient: null,
            
            async init() {
                if (this.isInitialized) return;
                
                try {
                    console.log('üìÑ Initialisation Google Drive API Photos...');
                    
                    await new Promise((resolve) => {
                        gapi.load('client', resolve);
                    });
                    
                    await gapi.client.init({
                        apiKey: GOOGLE_CONFIG.API_KEY,
                        discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest']
                    });
                    
                    this.tokenClient = google.accounts.oauth2.initTokenClient({
                        client_id: GOOGLE_CONFIG.CLIENT_ID,
                        scope: GOOGLE_CONFIG.SCOPES,
                        callback: ''
                    });
                    
                    this.isInitialized = true;
                    console.log('‚úÖ Google Drive API Photos initialis√©e');
                } catch (error) {
                    console.error('‚ùå Erreur init Google Drive API:', error);
                    throw error;
                }
            },
            
            async signIn() {
                if (!this.isInitialized) await this.init();
                
                return new Promise((resolve, reject) => {
                    if (!this.tokenClient) {
                        reject(new Error('Token client non initialis√©'));
                        return;
                    }
                    
                    this.tokenClient.callback = async (response) => {
                        if (response.error) {
                            console.error('‚ùå Erreur OAuth:', response);
                            this.isSignedIn = false;
                            reject(new Error(`Erreur OAuth: ${response.error}`));
                            return;
                        }
                        
                        console.log('‚úÖ Token OAuth re√ßu');
                        
                        try {
                            await new Promise(resolve => setTimeout(resolve, 200));
                            await gapi.client.drive.files.list({ pageSize: 1 });
                            console.log('‚úÖ API Drive fonctionnelle');
                            this.isSignedIn = true;
                            resolve(true);
                        } catch (error) {
                            console.error('‚ùå Test API Drive √©chou√©:', error);
                            this.isSignedIn = false;
                            reject(new Error('Acc√®s API Drive impossible'));
                        }
                    };
                    
                    const token = gapi.client.getToken();
                    if (token) {
                        console.log('üìÑ Token existant trouv√©...');
                        gapi.client.drive.files.list({ pageSize: 1 })
                            .then(() => {
                                this.isSignedIn = true;
                                console.log('‚úÖ Token existant valide');
                                resolve(true);
                            })
                            .catch(() => {
                                console.log('üìÑ Token expir√©, nouveau token...');
                                gapi.client.setToken('');
                                this.tokenClient.requestAccessToken({ prompt: 'consent' });
                            });
                    } else {
                        console.log('üìÑ Demande autorisation...');
                        this.tokenClient.requestAccessToken({ prompt: 'consent' });
                    }
                });
            },
            
            async signOut() {
                const token = gapi.client.getToken();
                if (token) {
                    google.accounts.oauth2.revoke(token.access_token);
                    gapi.client.setToken('');
                }
                this.isSignedIn = false;
                console.log('‚úÖ D√©connect√© de Google Drive');
            },

            // NOUVEAU : Trouver dossier Photos dans Google Drive
            async findPhotosRootFolder() {
                if (!this.isSignedIn) throw new Error('Non connect√© √† Google Drive');
                
                try {
                    // Chercher le dossier "Photos" dans "Medias"
                    const response = await gapi.client.drive.files.list({
                        q: `name='Photos' and mimeType='application/vnd.google-apps.folder' and trashed=false`,
                        fields: 'files(id, name, parents)'
                    });
                    
                    // V√©rifier que c'est bien dans le dossier Medias
                    for (const folder of response.result.files) {
                        const parentResponse = await gapi.client.drive.files.get({
                            fileId: folder.parents[0],
                            fields: 'name'
                        });
                        
                        if (parentResponse.result.name === 'Medias') {
                            console.log('‚úÖ Dossier Photos trouv√©:', folder.id);
                            return folder.id;
                        }
                    }
                    
                    throw new Error('Dossier Photos/Medias non trouv√©');
                } catch (error) {
                    console.error('‚ùå Erreur recherche dossier Photos:', error);
                    throw error;
                }
            },

            // NOUVEAU : Lister tous les fichiers d'un dossier photos par nom
            async listPhotosInFolder(folderName) {
                if (!this.isSignedIn) throw new Error('Non connect√© √† Google Drive');
                
                try {
                    // D'abord trouver le dossier Photos racine
                    const photosRootId = await this.findPhotosRootFolder();
                    
                    // Chercher le sous-dossier sp√©cifique (ex: "001.Paris-Bangkok")
                    const folderResponse = await gapi.client.drive.files.list({
                        q: `name='${folderName}' and '${photosRootId}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
                        fields: 'files(id, name)'
                    });
                    
                    if (folderResponse.result.files.length === 0) {
                        console.log(`‚ö†Ô∏è Dossier ${folderName} non trouv√©`);
                        return [];
                    }
                    
                    const folderId = folderResponse.result.files[0].id;
                    
                    // Lister toutes les photos du dossier
                    const photosResponse = await gapi.client.drive.files.list({
                        q: `'${folderId}' in parents and (mimeType contains 'image/' or name contains '.jpg' or name contains '.jpeg' or name contains '.png') and trashed=false`,
                        fields: 'files(id, name, webContentLink, thumbnailLink, size)',
                        orderBy: 'name',
                        pageSize: 100 // Maximum pour √©viter pagination pour l'instant
                    });
                    
                    console.log(`üì∏ ${photosResponse.result.files.length} photos trouv√©es dans ${folderName}`);
                    return photosResponse.result.files;
                } catch (error) {
                    console.error(`‚ùå Erreur liste photos ${folderName}:`, error);
                    return [];
                }
            },

            // NOUVEAU : Obtenir URL thumbnail optimis√©
            getThumbnailUrl(thumbnailLink, size = 's220') {
                if (!thumbnailLink) return null;
                // Remplacer =s220 par la taille souhait√©e (s220, s400, s800, etc.)
                return thumbnailLink.replace(/=s\d+/, `=${size}`);
            },

            // M√©thodes existantes...
            async findMekongFile() {
                if (!this.isSignedIn) return null;
                try {
                    const response = await gapi.client.drive.files.list({
                        q: "name='mekong_sessions.json' and trashed=false",
                        fields: 'files(id, name)'
                    });
                    return response.result.files[0] || null;
                } catch (error) {
                    console.error('‚ùå Erreur recherche fichier:', error);
                    throw error;
                }
            },

            async saveFile(content) {
                if (!this.isSignedIn) throw new Error('Non connect√© √† Google Drive');
                
                try {
                    const fileMetadata = { name: 'mekong_sessions.json' };
                    const form = new FormData();
                    form.append('metadata', new Blob([JSON.stringify(fileMetadata)], {type: 'application/json'}));
                    form.append('file', new Blob([content], {type: 'application/json'}));

                    const response = await fetch('https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart', {
                        method: 'POST',
                        headers: new Headers({ 'Authorization': `Bearer ${gapi.client.getToken().access_token}` }),
                        body: form
                    });

                    if (!response.ok) throw new Error('Upload √©chou√©');
                    return await response.json();
                } catch (error) {
                    console.error('‚ùå Erreur sauvegarde:', error);
                    throw error;
                }
            },

            async updateFile(fileId, content) {
                if (!this.isSignedIn) throw new Error('Non connect√© √† Google Drive');
                
                try {
                    const response = await fetch(`https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=media`, {
                        method: 'PATCH',
                        headers: {
                            'Authorization': `Bearer ${gapi.client.getToken().access_token}`,
                            'Content-Type': 'application/json'
                        },
                        body: content
                    });

                    if (!response.ok) throw new Error('Update √©chou√©');
                    return await response.json();
                } catch (error) {
                    console.error('‚ùå Erreur update:', error);
                    throw error;
                }
            },

            async loadFile(fileId) {
                if (!this.isSignedIn) throw new Error('Non connect√© √† Google Drive');
                
                try {
                    const response = await gapi.client.drive.files.get({
                        fileId: fileId,
                        alt: 'media'
                    });
                    return response.body;
                } catch (error) {
                    console.error('‚ùå Erreur chargement:', error);
                    throw error;
                }
            },

            // NOUVEAU : Test de connexion p√©riodique
            async testConnection() {
                if (!this.isSignedIn) return false;
                try {
                    await gapi.client.drive.files.list({ pageSize: 1 });
                    return true;
                } catch (error) {
                    console.error('‚ùå Test connexion √©chou√©:', error);
                    this.isSignedIn = false;
                    return false;
                }
            },

            // NOUVEAU : Force disconnect pour gestion d'erreurs
            forceDisconnect() {
                this.isSignedIn = false;
                gapi.client.setToken('');
                console.log('üîå D√©connexion forc√©e Google Drive');
            }
        };

        // ===== NOUVEAU : CACHE D'IMAGES =====
        const ImageCache = {
            cache: new Map(),
            maxSize: 50, // Maximum 50 images en cache
            
            // Ajouter une image au cache
            set(key, data) {
                if (this.cache.size >= this.maxSize) {
                    // Supprimer la plus ancienne entr√©e
                    const firstKey = this.cache.keys().next().value;
                    this.cache.delete(firstKey);
                }
                this.cache.set(key, {
                    ...data,
                    cachedAt: Date.now()
                });
            },
            
            // R√©cup√©rer une image du cache
            get(key) {
                return this.cache.get(key);
            },
            
            // V√©rifier si une image est en cache
            has(key) {
                return this.cache.has(key);
            },
            
            // Nettoyer le cache (images > 10 minutes)
            cleanup() {
                const now = Date.now();
                const maxAge = 10 * 60 * 1000; // 10 minutes
                
                for (const [key, data] of this.cache.entries()) {
                    if (now - data.cachedAt > maxAge) {
                        this.cache.delete(key);
                    }
                }
            }
        };

        // ===== NOUVEAU : COMPOSANT IMAGE OPTIMIS√âE =====
        const DriveImage = ({ driveFile, size = 's220', className, onClick, alt }) => {
            const [imageUrl, setImageUrl] = useState(null);
            const [isLoading, setIsLoading] = useState(true);
            const [hasError, setHasError] = useState(false);

            useEffect(() => {
                if (!driveFile) return;
                
                const loadImage = async () => {
                    const cacheKey = `${driveFile.id}_${size}`;
                    
                    // V√©rifier le cache d'abord
                    if (ImageCache.has(cacheKey)) {
                        const cached = ImageCache.get(cacheKey);
                        setImageUrl(cached.url);
                        setIsLoading(false);
                        return;
                    }
                    
                    try {
                        let url;
                        if (driveFile.thumbnailLink) {
                            // Utiliser thumbnail avec taille optimis√©e
                            url = GoogleDriveAPI.getThumbnailUrl(driveFile.thumbnailLink, size);
                        } else if (driveFile.webContentLink) {
                            // Fallback sur webContentLink
                            url = driveFile.webContentLink;
                        } else {
                            throw new Error('Aucun lien image disponible');
                        }
                        
                        // Mettre en cache
                        ImageCache.set(cacheKey, { url, driveFile });
                        setImageUrl(url);
                        setIsLoading(false);
                    } catch (error) {
                        console.error('‚ùå Erreur chargement image:', error);
                        setHasError(true);
                        setIsLoading(false);
                    }
                };
                
                loadImage();
            }, [driveFile, size]);

            if (hasError) {
                return (
                    <div className={`bg-gray-200 flex items-center justify-center ${className}`}>
                        <div className="text-center text-gray-500">
                            <Camera className="w-6 h-6 mx-auto mb-1" />
                            <span className="text-xs">Erreur</span>
                        </div>
                    </div>
                );
            }

            if (isLoading || !imageUrl) {
                return (
                    <div className={`bg-gray-200 flex items-center justify-center ${className}`}>
                        <LoadingSpinner size="w-6 h-6" color="border-gray-400" />
                    </div>
                );
            }

            return (
                <img
                    src={imageUrl}
                    alt={alt || driveFile.name}
                    className={className}
                    onClick={onClick}
                    onError={() => setHasError(true)}
                />
            );
        };
        const PhotoData = {
            // Import de l'index photos depuis un fichier JSON
            async importPhotosIndex(file) {
                try {
                    const text = await file.text();
                    let photosIndex = JSON.parse(text);
                    
                    // Valider la structure
                    if (!photosIndex || typeof photosIndex !== 'object') {
                        throw new Error('Format index photos invalide');
                    }
                    
                    // Nettoyer l'index : supprimer entr√©es vides et invalides
                    const cleanIndex = {};
                    Object.keys(photosIndex).forEach(key => {
                        // Ignorer les entr√©es vides ou invalides
                        if (key && key !== '' && key !== '.' && photosIndex[key].folderName && photosIndex[key].folderName !== '.') {
                            // G√©rer les doublons en prenant la premi√®re occurrence
                            if (!cleanIndex[key]) {
                                cleanIndex[key] = photosIndex[key];
                            } else {
                                console.log(`‚ö†Ô∏è Doublon d√©tect√© pour le jour ${key}, conservation de la premi√®re occurrence`);
                            }
                        }
                    });
                    
                    // Sauvegarder dans le cache
                    Storage.set('photos_index', cleanIndex);
                    Storage.set('photos_imported_at', new Date().toISOString());
                    
                    console.log(`‚úÖ Index photos import√© : ${Object.keys(cleanIndex).length} jours`);
                    console.log(`üìä Premi√®re photo: jour ${Math.min(...Object.keys(cleanIndex).map(k => parseInt(k)))}`);
                    console.log(`üìä Derni√®re photo: jour ${Math.max(...Object.keys(cleanIndex).map(k => parseInt(k)))}`);
                    return cleanIndex;
                } catch (error) {
                    console.error('‚ùå Erreur import index photos:', error);
                    throw error;
                }
            },

            // R√©cup√©rer l'index photos du cache
            getPhotosIndex() {
                return Storage.get('photos_index', {});
            },

            // V√©rifier si l'index photos est import√©
            isPhotosImported() {
                const index = this.getPhotosIndex();
                return Object.keys(index).length > 0;
            },

            // Obtenir les photos d'un jour sp√©cifique
            getPhotosForDay(dayNumber) {
                const index = this.getPhotosIndex();
                const dayKey = String(dayNumber).padStart(3, '0');
                return index[dayKey] || null;
            },

            // Obtenir une photo al√©atoire
            getRandomPhoto() {
                const index = this.getPhotosIndex();
                const days = Object.keys(index);
                if (days.length === 0) return null;
                
                const randomDay = days[Math.floor(Math.random() * days.length)];
                const dayPhotos = index[randomDay];
                if (!dayPhotos || !dayPhotos.photos || dayPhotos.photos.length === 0) return null;
                
                const randomPhoto = dayPhotos.photos[Math.floor(Math.random() * dayPhotos.photos.length)];
                return {
                    dayNumber: parseInt(randomDay),
                    folderName: dayPhotos.folderName,
                    fileName: randomPhoto,
                    driveId: dayPhotos.driveIds ? dayPhotos.driveIds[dayPhotos.photos.indexOf(randomPhoto)] : null
                };
            },

            // Statistiques photos
            getPhotosStats() {
                const index = this.getPhotosIndex();
                const importedAt = Storage.get('photos_imported_at');
                const days = Object.keys(index);
                const totalPhotos = days.reduce((total, day) => {
                    const dayData = index[day];
                    return total + (dayData.photos ? dayData.photos.length : 0);
                }, 0);

                return {
                    totalDays: days.length,
                    totalPhotos,
                    importedAt,
                    dayRange: days.length > 0 ? {
                        min: Math.min(...days.map(d => parseInt(d))),
                        max: Math.max(...days.map(d => parseInt(d)))
                    } : null
                };
            }
        };

        // ===== COMPOSANT TIMELINE NAVIGATION =====
        const PhotoTimeline = ({ currentDay, onDayChange, totalDays = 275 }) => {
            const [isDragging, setIsDragging] = useState(false);
            const timelineRef = useRef(null);

            const handleTimelineClick = (e) => {
                if (!timelineRef.current) return;
                
                const rect = timelineRef.current.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const percentage = clickX / rect.width;
                const newDay = Math.max(1, Math.min(totalDays, Math.round(percentage * totalDays)));
                
                onDayChange(newDay);
            };

            const currentPosition = ((currentDay - 1) / (totalDays - 1)) * 100;

            return (
                <div className="mb-6 px-4">
                    <div className="flex items-center justify-between mb-2">
                        <span className="text-sm font-medium text-gray-600">Jour {currentDay}</span>
                        <span className="text-sm text-gray-500">/ {totalDays}</span>
                    </div>
                    
                    <div 
                        ref={timelineRef}
                        className="relative timeline-container cursor-pointer"
                        onClick={handleTimelineClick}
                    >
                        <div className="timeline-track"></div>
                        <div 
                            className="timeline-thumb absolute"
                            style={{ left: `${currentPosition}%`, transform: 'translateX(-50%)' }}
                        ></div>
                    </div>
                    
                    <div className="flex justify-between text-xs text-gray-400 mt-1">
                        <span>Paris</span>
                        <span>Voyage</span>
                        <span>Bangkok</span>
                    </div>
                </div>
            );
        };

        // ===== GALERIE PHOTOS AVEC VRAIES IMAGES =====
        const PhotoGallery = ({ dayNumber, photosData, googleAuth }) => {
            const [selectedPhoto, setSelectedPhoto] = useState(null);
            const [drivePhotosData, setDrivePhotosData] = useState(null);
            const [isLoadingDrive, setIsLoadingDrive] = useState(false);

            // Charger les m√©tadonn√©es Google Drive pour ce jour
            useEffect(() => {
                const loadDriveData = async () => {
                    if (!photosData || !googleAuth.isConnected) return;
                    
                    setIsLoadingDrive(true);
                    try {
                        const driveData = await PhotoData.loadDrivePhotosForDay(dayNumber);
                        setDrivePhotosData(driveData);
                        console.log(`üì∏ Photos Drive charg√©es pour jour ${dayNumber}:`, driveData);
                    } catch (error) {
                        console.error('‚ùå Erreur chargement photos Drive:', error);
                        setDrivePhotosData({ hasError: true, errorMessage: error.message });
                    } finally {
                        setIsLoadingDrive(false);
                    }
                };
                
                loadDriveData();
            }, [dayNumber, photosData, googleAuth.isConnected]);

            // Nettoyer le cache p√©riodiquement
            useEffect(() => {
                const cleanup = setInterval(() => {
                    ImageCache.cleanup();
                }, 5 * 60 * 1000); // Toutes les 5 minutes
                
                return () => clearInterval(cleanup);
            }, []);

            if (!photosData) {
                return (
                    <div className="bg-gray-50 p-8 rounded-lg text-center">
                        <Camera className="w-12 h-12 text-gray-300 mx-auto mb-3" />
                        <h3 className="text-lg font-medium text-gray-600 mb-2">Aucune photo ce jour</h3>
                        <p className="text-gray-500">Jour {dayNumber} - Essayez un autre jour</p>
                    </div>
                );
            }

            if (!googleAuth.isConnected) {
                return (
                    <div className="bg-orange-50 p-8 rounded-lg text-center border border-orange-200">
                        <Cloud className="w-12 h-12 text-orange-400 mx-auto mb-3" />
                        <h3 className="text-lg font-medium text-orange-700 mb-2">Connexion Google Drive requise</h3>
                        <p className="text-orange-600">Connectez-vous pour voir les photos</p>
                    </div>
                );
            }

            if (isLoadingDrive) {
                return (
                    <div className="bg-blue-50 p-8 rounded-lg text-center border border-blue-200">
                        <LoadingSpinner size="w-12 h-12" color="border-blue-500" />
                        <h3 className="text-lg font-medium text-blue-700 mt-4 mb-2">Chargement photos</h3>
                        <p className="text-blue-600">Connexion √† Google Drive...</p>
                    </div>
                );
            }

            if (drivePhotosData?.hasError) {
                return (
                    <div className="bg-red-50 p-8 rounded-lg text-center border border-red-200">
                        <Camera className="w-12 h-12 text-red-400 mx-auto mb-3" />
                        <h3 className="text-lg font-medium text-red-700 mb-2">Erreur chargement photos</h3>
                        <p className="text-red-600 text-sm">{drivePhotosData.errorMessage}</p>
                    </div>
                );
            }

            const handlePhotoClick = (photo, index) => {
                if (photo.driveFile) {
                    setSelectedPhoto({ ...photo, index });
                }
            };

            const handleModalNavigation = (direction) => {
                if (!selectedPhoto || !drivePhotosData?.photosWithDrive) return;
                
                const currentIndex = selectedPhoto.index;
                let newIndex;
                
                if (direction === 'prev') {
                    newIndex = currentIndex > 0 ? currentIndex - 1 : drivePhotosData.photosWithDrive.length - 1;
                } else {
                    newIndex = currentIndex < drivePhotosData.photosWithDrive.length - 1 ? currentIndex + 1 : 0;
                }
                
                const newPhoto = drivePhotosData.photosWithDrive[newIndex];
                if (newPhoto.driveFile) {
                    setSelectedPhoto({ ...newPhoto, index: newIndex });
                }
            };

            const photosToDisplay = drivePhotosData?.photosWithDrive || photosData.photos.map((photo, index) => ({
                name: photo,
                driveFile: null,
                hasError: true,
                index
            }));

            return (
                <div>
                    <div className="flex items-center justify-between mb-4">
                        <div>
                            <h3 className="font-semibold text-gray-900">Jour {dayNumber}</h3>
                            <p className="text-sm text-gray-600">{photosData.folderName}</p>
                        </div>
                        <div className="text-sm text-gray-500">
                            {drivePhotosData ? (
                                <span>
                                    {drivePhotosData.totalFound || 0}/{drivePhotosData.totalExpected || 0} photos
                                </span>
                            ) : (
                                <span>{photosData.photos?.length || 0} photos</span>
                            )}
                        </div>
                    </div>

                    {/* Grille photos thumbnails */}
                    <div className="grid grid-cols-3 md:grid-cols-4 lg:grid-cols-6 gap-2">
                        {photosToDisplay.map((photo, index) => (
                            <div 
                                key={photo.name}
                                className={`photo-thumbnail bg-gray-200 ${photo.driveFile ? 'cursor-pointer' : 'cursor-not-allowed opacity-50'}`}
                                onClick={() => handlePhotoClick(photo, index)}
                            >
                                {photo.driveFile ? (
                                    <DriveImage
                                        driveFile={photo.driveFile}
                                        size="s220"
                                        className="photo-thumbnail w-full h-full object-cover"
                                        alt={`Photo ${index + 1} - Jour ${dayNumber}`}
                                    />
                                ) : (
                                    <div className="w-full h-full flex items-center justify-center text-gray-400">
                                        <Camera className="w-6 h-6" />
                                        <span className="text-xs ml-1">{index + 1}</span>
                                    </div>
                                )}
                            </div>
                        ))}
                    </div>

                    {/* Stats de chargement */}
                    {drivePhotosData && drivePhotosData.totalFound !== drivePhotosData.totalExpected && (
                        <div className="mt-2 text-xs text-amber-600 bg-amber-50 p-2 rounded">
                            ‚ö†Ô∏è {drivePhotosData.totalFound}/{drivePhotosData.totalExpected} photos trouv√©es sur Google Drive
                        </div>
                    )}

                    {/* Modal zoom photo plein √©cran */}
                    {selectedPhoto && selectedPhoto.driveFile && (
                        <div 
                            className="fixed inset-0 bg-black bg-opacity-90 flex items-center justify-center z-50"
                            onClick={() => setSelectedPhoto(null)}
                        >
                            <div className="max-w-6xl max-h-full w-full h-full flex flex-col">
                                {/* Header modal */}
                                <div className="flex items-center justify-between p-4 text-white">
                                    <div>
                                        <h3 className="font-semibold">{selectedPhoto.name}</h3>
                                        <p className="text-sm text-gray-300">
                                            Photo {selectedPhoto.index + 1} - Jour {dayNumber} - {photosData.folderName}
                                        </p>
                                    </div>
                                    <button 
                                        onClick={() => setSelectedPhoto(null)}
                                        className="text-white hover:text-gray-300 text-2xl"
                                    >
                                        √ó
                                    </button>
                                </div>

                                {/* Image principale */}
                                <div className="flex-1 flex items-center justify-center px-4 pb-4">
                                    <DriveImage
                                        driveFile={selectedPhoto.driveFile}
                                        size="s800"
                                        className="max-w-full max-h-full object-contain rounded"
                                        alt={selectedPhoto.name}
                                    />
                                </div>

                                {/* Navigation en bas */}
                                <div className="flex items-center justify-center space-x-6 pb-4">
                                    <button
                                        onClick={() => handleModalNavigation('prev')}
                                        className="flex items-center space-x-2 px-4 py-2 bg-white bg-opacity-20 hover:bg-opacity-30 text-white rounded-lg"
                                    >
                                        <ChevronLeft />
                                        <span>Pr√©c√©dente</span>
                                    </button>
                                    
                                    <span className="text-white text-sm">
                                        {selectedPhoto.index + 1} / {photosToDisplay.length}
                                    </span>
                                    
                                    <button
                                        onClick={() => handleModalNavigation('next')}
                                        className="flex items-center space-x-2 px-4 py-2 bg-white bg-opacity-20 hover:bg-opacity-30 text-white rounded-lg"
                                    >
                                        <span>Suivante</span>
                                        <ChevronRight />
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}
                </div>
            );
        };

        // ===== MASTODON DATA =====
        const MastodonData = {
            parseOutbox: (jsonText) => {
                try {
                    console.log('üìÑ Parsing outbox Mastodon...');
                    const data = JSON.parse(jsonText);
                    
                    if (!data.orderedItems || !Array.isArray(data.orderedItems)) {
                        throw new Error('Format outbox invalide : orderedItems manquant');
                    }

                    const posts = data.orderedItems
                        .map((item, index) => {
                            const note = item.object || item;
                            if (!note.content) return null;

                            let cleanContent = note.content
                                .replace(/<[^>]*>/g, '')
                                .replace(/&nbsp;/g, ' ')
                                .replace(/&lt;/g, '<')
                                .replace(/&gt;/g, '>')
                                .replace(/&amp;/g, '&')
                                .trim();

                            const dayMatch = cleanContent.match(/^J(\d+)/);
                            const dayNumber = dayMatch ? parseInt(dayMatch[1]) : null;
                            
                            return {
                                id: note.id || `post-${index}`,
                                dayNumber,
                                content: cleanContent,
                                published: note.published || item.published,
                                attachments: note.attachment || [],
                                url: note.url
                            };
                        })
                        .filter(post => post && post.dayNumber !== null)
                        .sort((a, b) => a.dayNumber - b.dayNumber);

                    console.log(`‚úÖ ${posts.length} posts Mastodon import√©s`);
                    return posts;
                } catch (error) {
                    console.error('‚ùå Erreur parsing outbox:', error);
                    throw error;
                }
            },

            savePosts: (posts) => {
                Storage.set('mastodon_posts', posts);
                Storage.set('mastodon_imported_at', new Date().toISOString());
            },

            getPosts: () => Storage.get('mastodon_posts', []),
            
            searchPosts: (query) => {
                const posts = MastodonData.getPosts();
                if (!query.trim()) return posts;
                
                const searchTerms = query.toLowerCase().trim().split(/\s+/);
                return posts.filter(post => 
                    searchTerms.every(term => 
                        post.content.toLowerCase().includes(term)
                    )
                );
            },

            getPostByDay: (dayNumber) => {
                const posts = MastodonData.getPosts();
                return posts.find(post => post.dayNumber === dayNumber);
            },

            getRandomPost: () => {
                const posts = MastodonData.getPosts();
                if (posts.length === 0) return null;
                return posts[Math.floor(Math.random() * posts.length)];
            },

            isImported: () => MastodonData.getPosts().length > 0,

            getStats: () => {
                const posts = MastodonData.getPosts();
                const importedAt = Storage.get('mastodon_imported_at');
                return {
                    totalPosts: posts.length,
                    dayRange: posts.length > 0 ? {
                        min: Math.min(...posts.map(p => p.dayNumber)),
                        max: Math.max(...posts.map(p => p.dayNumber))
                    } : null,
                    importedAt
                };
            }
        };

        // ===== AUTRES COMPOSANTS (ICONES, STORAGE, ETC.) =====
        const LoadingSpinner = ({ size = 'w-6 h-6', color = 'border-blue-600' }) => (
            <div className={`${size} border-2 ${color} border-t-transparent rounded-full animate-spin`}></div>
        );

        // Ic√¥nes Lucide (inline)
        const Home = () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z" /><polyline points="9,22 9,12 15,12 15,22" /></svg>;
        const BookOpen = () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.746 0 3.332.477 4.5 1.253v13C19.832 18.477 18.246 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" /></svg>;
        const Settings = () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" /></svg>;
        const Cloud = () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M9 19l3 3m0 0l3-3m-3 3V10" /></svg>;
        const Camera = () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M3 9a2 2 0 012-2h.93a2 2 0 001.664-.89l.812-1.22A2 2 0 0110.07 4h3.86a2 2 0 011.664.89l.812 1.22A2 2 0 0018.07 7H19a2 2 0 012 2v9a2 2 0 01-2 2H5a2 2 0 01-2-2V9z" /><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 13a3 3 0 11-6 0 3 3 0 016 0z" /></svg>;
        const Calendar = () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M8 7V3m8 4V3m-9 8h10M5 21h14a2 2 0 002-2V7a2 2 0 00-2-2H5a2 2 0 00-2 2v12a2 2 0 002 2z" /></svg>;
        const Search = () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="m21 21-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z" /></svg>;
        const Shuffle = () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M16 3h5m0 0v5m0-5l-6 6M8 3H3m0 0v5m0-5l6 6M16 21h5m0 0v-5m0 5l-6-6M8 21H3m0 0v-5m0 5l6-6" /></svg>;
        const ChevronLeft = () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 19l-7-7 7-7" /></svg>;
        const ChevronRight = () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" /></svg>;
        const Plus = () => <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M12 6v6m0 0v6m0-6h6m-6 0H6" /></svg>;

        // ===== GESTION UTILISATEURS =====
        const USERS = {
            'tom': { name: 'Tom, le jeune √©l√©phantau', emoji: 'üêò', color: 'blue' },
            'lambert': { name: 'Lambert, le vieux pachyderme', emoji: 'ü¶£', color: 'green' },
            'duo': { name: 'Duo M√©kong Tandem', emoji: 'üë•', color: 'purple' }
        };

        const getUserStyle = (userId) => {
            const colors = {
                blue: { bg: 'bg-blue-100', text: 'text-blue-800', border: 'border-blue-300' },
                green: { bg: 'bg-green-100', text: 'text-green-800', border: 'border-green-300' },
                purple: { bg: 'bg-purple-100', text: 'text-purple-800', border: 'border-purple-300' }
            };
            return colors[USERS[userId]?.color] || colors.blue;
        };

        // ===== HOOK GOOGLE AUTH =====
        const useGoogleAuth = () => {
            const [isConnected, setIsConnected] = useState(false);
            const [isLoading, setIsLoading] = useState(false);
            const [userInfo, setUserInfo] = useState(null);
            const [connectionMode, setConnectionMode] = useState('checking');
            const [hasEverBeenConnected, setHasEverBeenConnected] = useState(false);
            const [lastConnectionError, setLastConnectionError] = useState(null);

            useEffect(() => {
                const initGoogle = async () => {
                    setIsLoading(true);
                    const everConnected = Storage.get('ever_connected_to_drive', false);
                    setHasEverBeenConnected(everConnected);

                    try {
                        await GoogleDriveAPI.init();
                        
                        const token = gapi.client.getToken();
                        if (token) {
                            const isValid = await GoogleDriveAPI.testConnection();
                            if (isValid) {
                                setIsConnected(true);
                                setConnectionMode('connected');
                                
                                const response = await fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
                                    headers: { 'Authorization': `Bearer ${token.access_token}` }
                                });
                                const profile = await response.json();
                                setUserInfo({
                                    name: profile.name,
                                    email: profile.email,
                                    picture: profile.picture
                                });
                            } else {
                                setConnectionMode(everConnected ? 'disconnected' : 'never-connected');
                                setLastConnectionError('Token expir√©');
                            }
                        } else {
                            setConnectionMode(everConnected ? 'disconnected' : 'never-connected');
                        }
                    } catch (error) {
                        console.error('Erreur init Google:', error);
                        const everConnected = Storage.get('ever_connected_to_drive', false);
                        setConnectionMode(everConnected ? 'disconnected' : 'never-connected');
                        setLastConnectionError(error.message);
                    } finally {
                        setIsLoading(false);
                    }
                };
                initGoogle();
            }, []);

            const signIn = async () => {
                setIsLoading(true);
                setLastConnectionError(null);
                
                try {
                    const success = await GoogleDriveAPI.signIn();
                    if (success) {
                        const token = gapi.client.getToken();
                        const response = await fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
                            headers: { 'Authorization': `Bearer ${token.access_token}` }
                        });
                        
                        if (!response.ok) {
                            throw new Error('Impossible de r√©cup√©rer le profil utilisateur');
                        }
                        
                        const profile = await response.json();
                        setUserInfo({
                            name: profile.name,
                            email: profile.email,
                            picture: profile.picture
                        });
                        setIsConnected(true);
                        setConnectionMode('connected');
                        setLastConnectionError(null);
                        
                        if (!hasEverBeenConnected) {
                            Storage.set('ever_connected_to_drive', true);
                            setHasEverBeenConnected(true);
                        }
                        
                        console.log('Connexion r√©ussie:', profile.name);
                        return true;
                    } else {
                        throw new Error('√âchec de la connexion Google Drive');
                    }
                } catch (error) {
                    console.error('Erreur connexion:', error);
                    setIsConnected(false);
                    setUserInfo(null);
                    setConnectionMode(hasEverBeenConnected ? 'disconnected' : 'never-connected');
                    setLastConnectionError(error.message);
                    return false;
                } finally {
                    setIsLoading(false);
                }
            };

            const signOut = async () => {
                setIsLoading(true);
                try {
                    await GoogleDriveAPI.signOut();
                    setIsConnected(false);
                    setUserInfo(null);
                    setConnectionMode('disconnected');
                    setLastConnectionError(null);
                } catch (error) {
                    console.error('Erreur d√©connexion:', error);
                } finally {
                    setIsLoading(false);
                }
            };

            const forceDisconnect = () => {
                GoogleDriveAPI.forceDisconnect();
                setIsConnected(false);
                setUserInfo(null);
                setConnectionMode('disconnected');
                setLastConnectionError('Connexion perdue');
            };

            const testConnection = async () => {
                if (!isConnected) return false;
                const isValid = await GoogleDriveAPI.testConnection();
                if (!isValid) {
                    forceDisconnect();
                }
                return isValid;
            };

            return {
                isConnected,
                isLoading,
                userInfo,
                connectionMode,
                hasEverBeenConnected,
                lastConnectionError,
                signIn,
                signOut,
                forceDisconnect,
                testConnection
            };
        };

        // ===== CLOUD SESSION STORAGE =====
        const CloudSessionStorage = {
            async saveToCloud(sessions) {
                if (!GoogleDriveAPI.isSignedIn) {
                    throw new Error('Google Drive non connect√©');
                }

                try {
                    const content = JSON.stringify(sessions, null, 2);
                    const existingFile = await GoogleDriveAPI.findMekongFile();
                    
                    if (existingFile) {
                        await GoogleDriveAPI.updateFile(existingFile.id, content);
                        console.log('‚úÖ Sessions mises √† jour sur Drive');
                    } else {
                        await GoogleDriveAPI.saveFile(content);
                        console.log('‚úÖ Fichier sessions cr√©√© sur Drive');
                    }
                    
                    Storage.set('last_cloud_sync', new Date().toISOString());
                    return true;
                } catch (error) {
                    console.error('‚ùå Erreur sauvegarde cloud:', error);
                    throw error;
                }
            },

            async loadFromCloud() {
                if (!GoogleDriveAPI.isSignedIn) {
                    throw new Error('Google Drive non connect√©');
                }

                try {
                    const file = await GoogleDriveAPI.findMekongFile();
                    if (!file) {
                        console.log('‚ÑπÔ∏è Aucun fichier sessions sur Drive');
                        return [];
                    }

                    const content = await GoogleDriveAPI.loadFile(file.id);
                    const sessions = JSON.parse(content);
                    
                    console.log(`‚úÖ ${sessions.length} sessions charg√©es depuis Drive`);
                    Storage.set('last_cloud_sync', new Date().toISOString());
                    return sessions;
                } catch (error) {
                    console.error('‚ùå Erreur chargement cloud:', error);
                    throw error;
                }
            }
        };

        // ===== NAVIGATION : TOP BAR =====
        const TopBar = ({ currentPage, currentUser, onUserChange, onPageChange, connectionMode, googleAuth, onGoogleAction }) => {
            const PAGE_TITLES = {
                home: "M√©moire du M√©kong",
                sessions: "Vos Sessions", 
                games: "Choisir un jeu",
                chat: "Conversation",
                memories: "M√©moires du Voyage",
                settings: "R√©glages",
                users: "Gestion des Utilisateurs"
            };

            const getConnectionButtonStyle = () => {
                if (googleAuth.isLoading) {
                    return 'bg-blue-100 text-blue-700 cursor-wait border-2 border-blue-300';
                }
                
                switch(connectionMode) {
                    case 'connected':
                        return 'bg-green-100 text-green-700 hover:bg-green-200 border-2 border-green-300';
                    case 'disconnected':
                        return 'bg-red-100 text-red-700 hover:bg-red-200 border-2 border-red-400 pulse-warning';
                    case 'never-connected':
                        return 'bg-orange-100 text-orange-700 hover:bg-orange-200 border-2 border-orange-300';
                    default:
                        return 'bg-gray-100 text-gray-700 border-2 border-gray-300';
                }
            };

            const getConnectionButtonText = () => {
                if (googleAuth.isLoading) return 'Connexion...';
                
                switch(connectionMode) {
                    case 'connected':
                        return googleAuth.userInfo?.name?.split(' ')[0] || 'Connect√©';
                    case 'disconnected':
                        return 'Reconnecter';
                    case 'never-connected':
                        return 'Se connecter';
                    default:
                        return 'Google Drive';
                }
            };

            return (
                <header className="bg-white border-b border-gray-200 px-4 py-3 sticky top-0 z-20">
                    <div className="flex items-center justify-between">
                        <h1 className="text-xl font-bold text-gray-900">
                            {PAGE_TITLES[currentPage] || "M√©moire du M√©kong"}
                        </h1>
                        
                        <div className="flex items-center space-x-3">
                            <button
                                onClick={onGoogleAction}
                                className={`flex items-center space-x-2 px-3 py-2 rounded-lg font-medium transition-all ${getConnectionButtonStyle()}`}
                                title={connectionMode === 'connected' ? `Connect√©: ${googleAuth.userInfo?.email}` : 'Se connecter √† Google Drive'}
                            >
                                {googleAuth.isLoading ? (
                                    <LoadingSpinner size="w-4 h-4" color="border-blue-600" />
                                ) : (
                                    <Cloud />
                                )}
                                <span className="hidden sm:inline">{getConnectionButtonText()}</span>
                            </button>
                            
                            {currentUser && (
                                <button
                                    onClick={() => onUserChange('')}
                                    className={`flex items-center justify-center w-10 h-10 rounded-full border ${getUserStyle(currentUser).bg} ${getUserStyle(currentUser).border}`}
                                    title={`Connect√© en tant que ${USERS[currentUser]?.name}. Cliquer pour changer.`}
                                >
                                    <span className="text-xl">{USERS[currentUser]?.emoji}</span>
                                </button>
                            )}
                        </div>
                    </div>
                </header>
            );
        };

        // ===== BOTTOM NAV BAR =====
        const BottomNavBar = ({ currentPage, onPageChange, currentUser }) => {
            const navItems = [
                { id: 'home', icon: Home, label: 'Accueil' },
                { id: 'sessions', icon: BookOpen, label: 'Sessions' },
                { id: 'memories', icon: Camera, label: 'M√©moires' },
                { id: 'settings', icon: Settings, label: 'R√©glages' },
            ];

            return (
                <div className="fixed bottom-0 left-0 right-0 h-16 bg-white/90 backdrop-blur-md border-t border-gray-200 shadow-t-lg z-10">
                    <div className="flex justify-around items-center h-full">
                        {navItems.map((item) => {
                            const Icon = item.icon;
                            const isActive = currentPage === item.id;
                            const isDisabled = !currentUser && item.id !== 'home';
                            
                            return (
                                <button
                                    key={item.id}
                                    onClick={() => onPageChange(item.id)}
                                    disabled={isDisabled}
                                    className={`flex flex-col items-center justify-center w-full h-full transition-colors duration-200 ${
                                        isActive ? 'text-amber-600' : 'text-gray-500 hover:text-amber-500'
                                    } ${isDisabled ? 'opacity-50 cursor-not-allowed' : ''}`}
                                >
                                    <Icon />
                                    <span className="text-xs mt-1">{item.label}</span>
                                </button>
                            );
                        })}
                    </div>
                </div>
            );
        };

        // ===== NOUVELLE PAGE M√âMOIRES AVEC VRAIES IMAGES =====
        const MemoriesPage = ({ currentUser, onCreateSession, googleAuth }) => {
            const [activeTab, setActiveTab] = useState('blog'); // 'blog' ou 'photos'
            const [currentDay, setCurrentDay] = useState(1);
            const [isImportingPhotos, setIsImportingPhotos] = useState(false);
            const photosIndexInputRef = useRef(null);

            // √âtat des donn√©es
            const mastodonStats = MastodonData.getStats();
            const photosStats = PhotoData.getPhotosStats();
            const isPhotosImported = PhotoData.isPhotosImported();
            
            // Post Mastodon du jour actuel
            const currentPost = MastodonData.getPostByDay(currentDay);
            
            // Photos du jour actuel
            const currentPhotos = PhotoData.getPhotosForDay(currentDay);

            // Import index photos
            const handlePhotosIndexImport = async (event) => {
                const file = event.target.files[0];
                if (!file) return;

                setIsImportingPhotos(true);
                try {
                    await PhotoData.importPhotosIndex(file);
                    console.log('‚úÖ Index photos import√© avec succ√®s');
                } catch (error) {
                    console.error('‚ùå Erreur import photos:', error);
                    alert(`Erreur import photos: ${error.message}`);
                } finally {
                    setIsImportingPhotos(false);
                    // Reset input
                    if (photosIndexInputRef.current) {
                        photosIndexInputRef.current.value = '';
                    }
                }
            };

            // Navigation timeline
            const handleDayChange = (newDay) => {
                setCurrentDay(Math.max(1, Math.min(275, newDay)));
            };

            const handleRandomDay = () => {
                if (activeTab === 'blog') {
                    const randomPost = MastodonData.getRandomPost();
                    if (randomPost) {
                        setCurrentDay(randomPost.dayNumber);
                    }
                } else {
                    const randomPhoto = PhotoData.getRandomPhoto();
                    if (randomPhoto) {
                        setCurrentDay(randomPhoto.dayNumber);
                    }
                }
            };

            const handleCreateSession = () => {
                if (activeTab === 'blog' && currentPost) {
                    onCreateSession({
                        type: 'blog',
                        data: currentPost,
                        dayNumber: currentDay
                    });
                } else if (activeTab === 'photos' && currentPhotos) {
                    onCreateSession({
                        type: 'photos',
                        data: currentPhotos,
                        dayNumber: currentDay
                    });
                }
            };

            return (
                <div className="pb-20 px-4 space-y-6">
                    {/* Header avec stats */}
                    <div className="bg-gradient-to-r from-amber-100 to-orange-100 p-4 rounded-lg border border-amber-200">
                        <h2 className="font-bold text-amber-900 mb-2">üó∫Ô∏è Exploration des M√©moires</h2>
                        <div className="grid grid-cols-2 gap-4 text-sm">
                            <div className="text-amber-700">
                                <span className="font-medium">Blog:</span> {mastodonStats.totalPosts} posts
                            </div>
                            <div className="text-amber-700">
                                <span className="font-medium">Photos:</span> {photosStats.totalPhotos} photos
                            </div>
                        </div>
                    </div>

                    {/* Timeline Navigation */}
                    <PhotoTimeline 
                        currentDay={currentDay}
                        onDayChange={handleDayChange}
                        totalDays={275}
                    />

                    {/* Contr√¥les navigation */}
                    <div className="flex items-center justify-between bg-white p-3 rounded-lg border border-gray-200">
                        <div className="flex items-center space-x-2">
                            <button
                                onClick={() => handleDayChange(currentDay - 1)}
                                disabled={currentDay <= 1}
                                className="p-2 rounded-lg bg-gray-100 hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed"
                            >
                                <ChevronLeft />
                            </button>
                            
                            <input
                                type="number"
                                min="1"
                                max="275"
                                value={currentDay}
                                onChange={(e) => handleDayChange(parseInt(e.target.value) || 1)}
                                className="w-16 px-2 py-1 text-center border border-gray-300 rounded"
                            />
                            
                            <button
                                onClick={() => handleDayChange(currentDay + 1)}
                                disabled={currentDay >= 275}
                                className="p-2 rounded-lg bg-gray-100 hover:bg-gray-200 disabled:opacity-50 disabled:cursor-not-allowed"
                            >
                                <ChevronRight />
                            </button>
                        </div>

                        <button
                            onClick={handleRandomDay}
                            className="flex items-center space-x-2 px-3 py-2 bg-amber-500 hover:bg-amber-600 text-white rounded-lg"
                        >
                            <Shuffle />
                            <span>Hasard</span>
                        </button>
                    </div>

                    {/* Switch Blog/Photos */}
                    <div className="flex bg-gray-100 p-1 rounded-lg">
                        <button
                            onClick={() => setActiveTab('blog')}
                            className={`flex-1 py-2 px-4 rounded-md font-medium transition-all ${
                                activeTab === 'blog' 
                                    ? 'bg-white text-amber-600 shadow-sm' 
                                    : 'text-gray-600 hover:text-amber-600'
                            }`}
                        >
                            üìù Blog
                        </button>
                        <button
                            onClick={() => setActiveTab('photos')}
                            className={`flex-1 py-2 px-4 rounded-md font-medium transition-all ${
                                activeTab === 'photos' 
                                    ? 'bg-white text-amber-600 shadow-sm' 
                                    : 'text-gray-600 hover:text-amber-600'
                            }`}
                        >
                            üì∏ Photos
                        </button>
                    </div>

                    {/* Contenu selon onglet actif */}
                    {activeTab === 'blog' ? (
                        /* ENCART BLOG (existant) */
                        <div className="bg-white p-6 rounded-lg border border-gray-200">
                            {currentPost ? (
                                <div>
                                    <div className="flex items-center justify-between mb-4">
                                        <div>
                                            <h3 className="font-semibold text-gray-900">Jour {currentPost.dayNumber}</h3>
                                            <p className="text-sm text-gray-500">
                                                {new Date(currentPost.published).toLocaleDateString('fr-FR')}
                                            </p>
                                        </div>
                                        {currentPost.attachments && currentPost.attachments.length > 0 && (
                                            <span className="flex items-center space-x-1 text-sm text-amber-600 font-medium">
                                                <Camera className="w-4 h-4"/>
                                                <span>{currentPost.attachments.length}</span>
                                            </span>
                                        )}
                                    </div>
                                    
                                    <div className="prose prose-sm max-w-none text-gray-700 mb-4">
                                        {currentPost.content.split('\n').map((line, index) => (
                                            <p key={index} className="mb-2">{line}</p>
                                        ))}
                                    </div>

                                    <button
                                        onClick={handleCreateSession}
                                        className="w-full py-3 bg-amber-500 hover:bg-amber-600 text-white rounded-lg font-medium"
                                    >
                                        <Plus className="w-5 h-5 inline mr-2" />
                                        Cr√©er une session depuis ce post
                                    </button>
                                </div>
                            ) : (
                                <div className="bg-gray-50 p-8 rounded-lg text-center">
                                    <BookOpen className="w-12 h-12 text-gray-300 mx-auto mb-3" />
                                    <h3 className="text-lg font-medium text-gray-600 mb-2">Aucun post ce jour</h3>
                                    <p className="text-gray-500">Jour {currentDay} - Essayez un autre jour</p>
                                </div>
                            )}
                        </div>
                    ) : (
                        /* ENCART PHOTOS AVEC VRAIES IMAGES */
                        <div className="bg-white p-6 rounded-lg border border-gray-200">
                            {!isPhotosImported ? (
                                /* Interface import index photos */
                                <div className="text-center py-8">
                                    <Camera className="w-16 h-16 text-gray-300 mx-auto mb-4" />
                                    <h3 className="text-lg font-semibold text-gray-700 mb-2">
                                        Import des photos requis
                                    </h3>
                                    <p className="text-gray-500 mb-6">
                                        Veuillez importer l'index des photos pour acc√©der √† la galerie
                                    </p>
                                    
                                    <input
                                        ref={photosIndexInputRef}
                                        type="file"
                                        accept=".json"
                                        onChange={handlePhotosIndexImport}
                                        className="hidden"
                                    />
                                    
                                    <button
                                        onClick={() => photosIndexInputRef.current?.click()}
                                        disabled={isImportingPhotos}
                                        className="px-6 py-3 bg-blue-500 hover:bg-blue-600 disabled:bg-blue-300 text-white rounded-lg font-medium"
                                    >
                                        {isImportingPhotos ? (
                                            <>
                                                <LoadingSpinner size="w-4 h-4" color="border-white" />
                                                <span className="ml-2">Import en cours...</span>
                                            </>
                                        ) : (
                                            'S√©lectionner photos_index.json'
                                        )}
                                    </button>
                                    
                                    <div className="mt-4 p-3 bg-blue-50 rounded text-sm text-blue-700">
                                        <p className="font-medium mb-1">üìã Instructions :</p>
                                        <p>1. Cr√©ez l'index avec la commande Terminal fournie</p>
                                        <p>2. Importez le fichier photos_index.json g√©n√©r√©</p>
                                    </div>
                                </div>
                            ) : (
                                /* Galerie photos avec vraies images */
                                <div>
                                    <PhotoGallery 
                                        dayNumber={currentDay}
                                        photosData={currentPhotos}
                                        googleAuth={googleAuth}
                                    />
                                    
                                    {currentPhotos && (
                                        <button
                                            onClick={handleCreateSession}
                                            className="w-full mt-6 py-3 bg-emerald-500 hover:bg-emerald-600 text-white rounded-lg font-medium"
                                        >
                                            <Plus className="w-5 h-5 inline mr-2" />
                                            Cr√©er une session depuis ces photos
                                        </button>
                                    )}
                                </div>
                            )}
                        </div>
                    )}

                    {/* Stats debug (mode d√©veloppeur) */}
                    <div className="bg-gray-50 p-3 rounded-lg border border-gray-200 text-xs text-gray-600">
                        <div className="grid grid-cols-2 gap-2">
                            <div>Blog: {mastodonStats.totalPosts} posts</div>
                            <div>Photos: {photosStats.totalDays} jours</div>
                            <div>Jour actuel: {currentDay}</div>
                            <div>Onglet: {activeTab}</div>
                        </div>
                    </div>
                </div>
            );
        };

        // ===== AUTRES PAGES (simplifi√©es pour l'exemple) =====
        const HomePage = ({ connectionMode, onPageChange }) => (
            <div className="p-4 text-center">
                <div className="bg-gradient-to-br from-amber-50 to-orange-50 p-8 rounded-lg border border-amber-200">
                    <h2 className="text-2xl font-bold text-amber-900 mb-4">
                        üêò M√©moire du M√©kong V0.5.0
                    </h2>
                    <p className="text-amber-700 mb-6">
                        Timeline Photos int√©gr√©e !
                    </p>
                    
                    {connectionMode === 'connected' ? (
                        <button
                            onClick={() => onPageChange('memories')}
                            className="px-6 py-3 bg-amber-500 hover:bg-amber-600 text-white rounded-lg font-medium"
                        >
                            üó∫Ô∏è Explorer les M√©moires
                        </button>
                    ) : (
                        <p className="text-amber-600">
                            Connectez-vous √† Google Drive pour commencer
                        </p>
                    )}
                </div>
            </div>
        );

        const SessionsPage = () => (
            <div className="p-4 text-center text-gray-600">
                Page Sessions - √Ä venir
            </div>
        );

        const SettingsPage = ({ onReset }) => {
            const photosStats = PhotoData.getPhotosStats();
            
            return (
                <div className="p-4 space-y-6">
                    <div className="bg-white p-6 rounded-lg border border-gray-200">
                        <h3 className="font-semibold text-gray-900 mb-4">üìä Statistiques</h3>
                        <div className="grid grid-cols-2 gap-4 text-sm">
                            <div>
                                <span className="text-gray-600">Posts Mastodon:</span>
                                <div className="font-medium">{MastodonData.getStats().totalPosts}</div>
                            </div>
                            <div>
                                <span className="text-gray-600">Photos index√©es:</span>
                                <div className="font-medium">{photosStats.totalPhotos}</div>
                            </div>
                        </div>
                    </div>

                    <div className="bg-red-50 p-6 rounded-lg border border-red-200">
                        <h3 className="font-semibold text-red-900 mb-4">‚ö†Ô∏è Actions dangereuses</h3>
                        <button
                            onClick={onReset}
                            className="px-4 py-2 bg-red-500 hover:bg-red-600 text-white rounded-lg"
                        >
                            R√©initialiser l'application
                        </button>
                    </div>
                </div>
            );
        };

        // ===== APP PRINCIPALE =====
        const App = () => {
            const [currentPage, setCurrentPage] = useState('home');
            const [currentUser, setCurrentUser] = useState(Storage.get('current_user', ''));
            const [toastMessage, setToastMessage] = useState('');
            
            const googleAuth = useGoogleAuth();

            // Toast auto-dismiss
            useEffect(() => {
                if (toastMessage) {
                    const timer = setTimeout(() => setToastMessage(''), 4000);
                    return () => clearTimeout(timer);
                }
            }, [toastMessage]);

            // Sauvegarde utilisateur
            useEffect(() => {
                Storage.set('current_user', currentUser);
            }, [currentUser]);

            const handleGoogleAction = async () => {
                if (googleAuth.connectionMode === 'connected') {
                    await googleAuth.signOut();
                    setToastMessage('D√©connect√© de Google Drive');
                } else {
                    const success = await googleAuth.signIn();
                    if (success) {
                        setToastMessage('Connect√© √† Google Drive !');
                    }
                }
            };

            const handleCreateSession = (sessionData) => {
                // TODO: Impl√©menter cr√©ation session depuis m√©moire
                console.log('Cr√©er session:', sessionData);
                setToastMessage(`Session cr√©√©e depuis ${sessionData.type} jour ${sessionData.dayNumber}`);
                setCurrentPage('sessions');
            };

            const handleReset = () => {
                if (confirm('√ätes-vous s√ªr de vouloir r√©initialiser toutes les donn√©es ?')) {
                    Storage.clear();
                    window.location.reload();
                }
            };

            const renderPage = () => {
                switch (currentPage) {
                    case 'memories':
                        return (
                            <MemoriesPage 
                                currentUser={currentUser}
                                onCreateSession={handleCreateSession}
                            />
                        );
                    case 'sessions':
                        return <SessionsPage />;
                    case 'settings':
                        return <SettingsPage onReset={handleReset} />;
                    default:
                        return (
                            <HomePage 
                                connectionMode={googleAuth.connectionMode}
                                onPageChange={setCurrentPage}
                            />
                        );
                }
            };

            return (
                <div className="min-h-screen bg-gray-50">
                    <TopBar
                        currentPage={currentPage}
                        currentUser={currentUser}
                        onUserChange={setCurrentUser}
                        onPageChange={setCurrentPage}
                        connectionMode={googleAuth.connectionMode}
                        googleAuth={googleAuth}
                        onGoogleAction={handleGoogleAction}
                    />

                    {/* Toast Messages */}
                    {toastMessage && (
                        <div className="fixed top-20 left-1/2 transform -translate-x-1/2 bg-blue-500 text-white px-4 py-2 rounded-lg shadow-lg z-30">
                            {toastMessage}
                        </div>
                    )}

                    {/* Banni√®re d√©connexion */}
                    {googleAuth.connectionMode === 'disconnected' && (
                        <div className="bg-red-500 text-white text-center py-2 pulse-warning">
                            ‚ö†Ô∏è Connexion Google Drive perdue - Reconnectez-vous
                        </div>
                    )}

                    {/* Contenu principal */}
                    <main>
                        {renderPage()}
                    </main>

                    <BottomNavBar
                        currentPage={currentPage}
                        onPageChange={setCurrentPage}
                        currentUser={currentUser}
                    />
                </div>
            );
        };

        // ===== RENDU =====
        ReactDOM.render(<App />, document.getElementById('root'));
    </script>
</body>
</html>
