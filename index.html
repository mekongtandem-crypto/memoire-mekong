<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M√©moire du M√©kong V0.5.6</title>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gradient-to-br from-orange-50 to-amber-50">

<div id="root"></div>

<script type="text/babel">

// ===== STORAGE =====
const Storage = {
    get: (key, defaultValue = null) => {
        try {
            const item = localStorage.getItem(`mekong_${key}`);
            return item ? JSON.parse(item) : defaultValue;
        } catch { return defaultValue; }
    },
    set: (key, value) => {
        try {
            localStorage.setItem(`mekong_${key}`, JSON.stringify(value));
            return true;
        } catch { return false; }
    },
    remove: (key) => localStorage.removeItem(`mekong_${key}`),
    clear: () => {
        Object.keys(localStorage).forEach(key => {
            if (key.startsWith('mekong_')) localStorage.removeItem(key);
        });
    }
};

// ===== GOOGLE DRIVE API - V0.5.0 AVEC PHOTOS =====
const GOOGLE_CONFIG = {
    API_KEY: 'AIzaSyDiyLLN4EsyVREGxF4TzqbuKyugaq4TUXw',
    CLIENT_ID: '82966045106-hso0nr386agcuojllnud0dr41vcsh45a.apps.googleusercontent.com',
    SCOPES: 'https://www.googleapis.com/auth/drive.readonly https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/userinfo.profile https://www.googleapis.com/auth/userinfo.email'
};

const GoogleDriveAPI = {
    isSignedIn: false,
    isInitialized: false,
    tokenClient: null,
    
    // Cache pour √©viter les appels r√©p√©t√©s
    _photoCache: {
        folders: null,
        mastodonPhotos: null,
        contentIndex: null,
        lastRefresh: null
    },
    
    async init() {
        if (this.isInitialized) return;
        
        try {
            console.log('üîÑ Initialisation Google Drive API v0.5.0...');
            
            await new Promise((resolve) => {
                gapi.load('client', resolve);
            });
            
            await gapi.client.init({
                apiKey: GOOGLE_CONFIG.API_KEY,
                discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest']
            });
            
            this.tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: GOOGLE_CONFIG.CLIENT_ID,
                scope: GOOGLE_CONFIG.SCOPES,
                callback: ''
            });
            
            this.isInitialized = true;
            console.log('‚úÖ Google Drive API initialis√©e');
        } catch (error) {
            console.error('‚ùå Erreur init Google Drive API:', error);
            throw error;
        }
    },
    
    async signIn() {
        if (!this.isInitialized) await this.init();
        
        return new Promise((resolve, reject) => {
            if (!this.tokenClient) {
                reject(new Error('Token client non initialis√©'));
                return;
            }
            
            this.tokenClient.callback = async (response) => {
                if (response.error) {
                    console.error('‚ùå Erreur OAuth:', response);
                    this.isSignedIn = false;
                    reject(new Error(`Erreur OAuth: ${response.error}`));
                    return;
                }
                
                console.log('‚úÖ Token OAuth re√ßu');
                
                try {
                    await new Promise(resolve => setTimeout(resolve, 200));
                    await gapi.client.drive.files.list({ pageSize: 1 });
                    console.log('‚úÖ API Drive fonctionnelle');
                    this.isSignedIn = true;
                    
                    // Invalidation du cache √† la reconnexion
                    this._photoCache = {
                        folders: null,
                        mastodonPhotos: null,
                        contentIndex: null,
                        lastRefresh: null
                    };
                    
                    resolve(true);
                } catch (error) {
                    console.error('‚ùå Test API Drive √©chou√©:', error);
                    this.isSignedIn = false;
                    reject(new Error('Acc√®s API Drive impossible - Permissions insuffisantes'));
                }
            };
            
            const token = gapi.client.getToken();
            if (token) {
                console.log('üîÑ Token existant trouv√©, test de validit√©...');
                gapi.client.drive.files.list({ pageSize: 1 })
                    .then(() => {
                        this.isSignedIn = true;
                        console.log('‚úÖ Token existant valide');
                        resolve(true);
                    })
                    .catch(() => {
                        console.log('üîÑ Token expir√©, demande de nouveau token...');
                        gapi.client.setToken('');
                        this.tokenClient.requestAccessToken({ prompt: 'consent' });
                    });
            } else {
                console.log('üîÑ Aucun token, demande d\'autorisation...');
                this.tokenClient.requestAccessToken({ prompt: 'consent' });
            }
        });
    },
    
    async signOut() {
        const token = gapi.client.getToken();
        if (token) {
            google.accounts.oauth2.revoke(token.access_token);
            gapi.client.setToken('');
        }
        this.isSignedIn = false;
        
        // Vider le cache
        this._photoCache = {
            folders: null,
            mastodonPhotos: null,
            contentIndex: null,
            lastRefresh: null
        };
        
        console.log('‚úÖ D√©connect√© de Google Drive');
    },

    // ===== M√âTHODES SESSIONS (existantes, inchang√©es) =====
    async findMekongFile() {
        if (!this.isSignedIn) return null;
        try {
            const response = await gapi.client.drive.files.list({
                q: "name='mekong_sessions.json' and trashed=false",
                fields: 'files(id, name)'
            });
            return response.result.files[0] || null;
        } catch (error) {
            console.error('‚ùå Erreur recherche fichier:', error);
            throw new Error('Impossible de rechercher le fichier sessions');
        }
    },
    
    async loadSessions() {
        const file = await this.findMekongFile();
        if (!file) {
            console.log('üìÑ Aucun fichier sessions trouv√©, retour tableau vide');
            return [];
        }
        
        try {
            const response = await gapi.client.drive.files.get({
                fileId: file.id,
                alt: 'media'
            });
            return JSON.parse(response.body);
        } catch (error) {
            console.error('‚ùå Erreur lecture sessions:', error);
            throw new Error('Impossible de lire le fichier sessions');
        }
    },
    
    async saveSessions(sessions) {
        const file = await this.findMekongFile();
        const content = JSON.stringify(sessions, null, 2);
        
        if (file) {
            try {
                await gapi.client.request({
                    path: `https://www.googleapis.com/upload/drive/v3/files/${file.id}`,
                    method: 'PATCH',
                    params: { uploadType: 'media' },
                    headers: { 'Content-Type': 'application/json' },
                    body: content
                });
                console.log('‚úÖ Sessions mises √† jour dans Google Drive');
            } catch (error) {
                console.error('‚ùå Erreur mise √† jour sessions:', error);
                throw new Error('Impossible de mettre √† jour le fichier sessions');
            }
        } else {
            try {
                await gapi.client.request({
                    path: 'https://www.googleapis.com/upload/drive/v3/files',
                    method: 'POST',
                    params: { uploadType: 'media' },
                    headers: { 'Content-Type': 'application/json' },
                    body: content
                });
                console.log('‚úÖ Nouveau fichier sessions cr√©√© dans Google Drive');
            } catch (error) {
                console.error('‚ùå Erreur cr√©ation sessions:', error);
                throw new Error('Impossible de cr√©er le fichier sessions');
            }
        }
    },

    // ===== NOUVELLES M√âTHODES PHOTOS V0.5.0 =====
    
    /**
     * Trouve le dossier Medias dans Mon Drive/
     */
    async findMediasFolder() {
        try {
            // Chercher directement "Medias" dans la racine (Mon Drive)
            const response = await gapi.client.drive.files.list({
                q: "name='Medias' and mimeType='application/vnd.google-apps.folder' and trashed=false and 'root' in parents",
                fields: 'files(id, name, parents)'
            });
            
            const folders = response.result.files;
            if (folders.length === 0) {
                throw new Error('Dossier "Medias" non trouv√© dans Mon Drive');
            }
            
            console.log(`üìÅ Dossier Medias trouv√©: ${folders[0].id} (${folders[0].name})`);
            return folders[0];
        } catch (error) {
            console.error('‚ùå Erreur recherche dossier Medias:', error);
            throw new Error('Impossible de localiser Mon Drive/Medias');
        }
    },
    
    /**
     * Scan tous les dossiers photos principaux (Medias/photos/) - AVEC PAGINATION
     */
    async scanPhotoFolders() {
        if (this._photoCache.folders && this._isCacheValid()) {
            console.log('üìã Cache dossiers photos utilis√©');
            return this._photoCache.folders;
        }
        
        try {
            console.log('üîç Scan dossiers photos avec pagination...');
            
            const mediasFolder = await this.findMediasFolder();
            
            // Chercher le sous-dossier "photos"
            const photosResponse = await gapi.client.drive.files.list({
                q: `name='photos' and '${mediasFolder.id}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
                fields: 'files(id, name)'
            });
            
            if (photosResponse.result.files.length === 0) {
                throw new Error('Sous-dossier "photos" non trouv√©');
            }
            
            const photosFolder = photosResponse.result.files[0];
            
            // Lister TOUS les sous-dossiers jour avec pagination
            let allFolders = [];
            let nextPageToken = null;
            
            do {
                const dayFoldersResponse = await gapi.client.drive.files.list({
                    q: `'${photosFolder.id}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
                    fields: 'files(id, name, createdTime), nextPageToken',
                    orderBy: 'name',
                    pageSize: 1000, // Maximum autoris√©
                    pageToken: nextPageToken
                });
                
                allFolders.push(...dayFoldersResponse.result.files);
                nextPageToken = dayFoldersResponse.result.nextPageToken;
                
                console.log(`üìÅ ${dayFoldersResponse.result.files.length} dossiers suppl√©mentaires trouv√©s (total: ${allFolders.length})`);
                
            } while (nextPageToken);
            
            const folders = allFolders.map(folder => {
                // Parser le nom du dossier - formats accept√©s : "025-Bangkok", "025.Bangkok", "025 Bangkok"
                const matchTiret = folder.name.match(/^(\d+)-(.+)$/);
                const matchPoint = folder.name.match(/^(\d+)\.(.+)$/);
                const matchEspace = folder.name.match(/^(\d+)\s+(.+)$/);
                
                const match = matchTiret || matchPoint || matchEspace;
                
                return {
                    id: folder.id,
                    name: folder.name,
                    dayNumber: match ? parseInt(match[1]) : null,
                    location: match ? match[2] : folder.name,
                    createdTime: folder.createdTime,
                    type: 'day-folder',
                    parsed: !!match // Pour debug
                };
            });
            
            console.log(`üìÅ ${folders.length} dossiers photos trouv√©s TOTAL`);
            
            // Debug - afficher les dossiers non pars√©s
            const unparsedFolders = folders.filter(f => !f.parsed);
            if (unparsedFolders.length > 0) {
                console.log(`‚ö†Ô∏è ${unparsedFolders.length} dossiers non pars√©s:`, unparsedFolders.map(f => f.name));
            }
            
            this._photoCache.folders = folders;
            this._photoCache.lastRefresh = Date.now();
            
            return folders;
        } catch (error) {
            console.error('‚ùå Erreur scan dossiers photos:', error);
            throw new Error(`Scan dossiers photos √©chou√©: ${error.message}`);
        }
    },
    
    /**
     * Scan photos Mastodon (media_attachments) - AVEC PAGINATION
     */
    async scanMastodonPhotos() {
        if (this._photoCache.mastodonPhotos && this._isCacheValid()) {
            console.log('üìã Cache photos Mastodon utilis√©');
            return this._photoCache.mastodonPhotos;
        }
        
        try {
            console.log('üîç Scan photos Mastodon avec pagination...');
            
            const mediasFolder = await this.findMediasFolder();
            
            // Chercher Medias/Mastodon/
            const mastodonResponse = await gapi.client.drive.files.list({
                q: `name='Mastodon' and '${mediasFolder.id}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
                fields: 'files(id, name)'
            });
            
            if (mastodonResponse.result.files.length === 0) {
                console.log('‚ö†Ô∏è Dossier Mastodon non trouv√©, retour liste vide');
                this._photoCache.mastodonPhotos = [];
                return [];
            }
            
            const mastodonFolder = mastodonResponse.result.files[0];
            
            // Chercher media_attachments/
            const attachmentsResponse = await gapi.client.drive.files.list({
                q: `name='media_attachments' and '${mastodonFolder.id}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
                fields: 'files(id, name)'
            });
            
            if (attachmentsResponse.result.files.length === 0) {
                console.log('‚ö†Ô∏è Dossier media_attachments non trouv√©');
                this._photoCache.mastodonPhotos = [];
                return [];
            }
            
            const attachmentsFolder = attachmentsResponse.result.files[0];
            
            // Lister toutes les images avec pagination - REQU√äTE SIMPLIFI√âE
            let allPhotos = [];
            let nextPageToken = null;
            
            do {
                const photosResponse = await gapi.client.drive.files.list({
                    q: `'${attachmentsFolder.id}' in parents and trashed=false and mimeType contains 'image/'`,
                    fields: 'files(id, name, createdTime, size, mimeType, webViewLink), nextPageToken',
                    pageSize: 1000,
                    pageToken: nextPageToken
                });
                
                allPhotos.push(...photosResponse.result.files);
                nextPageToken = photosResponse.result.nextPageToken;
                
            } while (nextPageToken);
            
            const photos = allPhotos.map(photo => ({
                id: photo.id,
                name: photo.name,
                createdTime: photo.createdTime,
                size: photo.size,
                mimeType: photo.mimeType,
                webViewLink: photo.webViewLink,
                type: 'mastodon-photo'
            }));
            
            console.log(`üì∏ ${photos.length} photos Mastodon trouv√©es TOTAL`);
            this._photoCache.mastodonPhotos = photos;
            this._photoCache.lastRefresh = Date.now();
            
            return photos;
        } catch (error) {
            console.error('‚ùå Erreur scan photos Mastodon:', error);
            throw new Error(`Scan photos Mastodon √©chou√©: ${error.message}`);
        }
    },
    
    /**
     * R√©cup√®re TOUTES les photos d'un dossier jour sp√©cifique - AVEC DEBUG D√âTAILL√â
     */
    async getPhotosFromDayFolder(folderId) {
        try {
            let allPhotos = [];
            let nextPageToken = null;
            let pageCount = 0;
            
            do {
                pageCount++;
                const response = await gapi.client.drive.files.list({
                    q: `'${folderId}' in parents and trashed=false and (mimeType contains 'image' or name contains '.jpg' or name contains '.jpeg' or name contains '.png' or name contains '.gif' or name contains '.heic' or name contains '.heif' or name contains '.webp' or name contains '.bmp' or name contains '.tiff')`,
                    fields: 'files(id, name, createdTime, size, mimeType, webViewLink), nextPageToken',
                    orderBy: 'name',
                    pageSize: 1000,
                    pageToken: nextPageToken
                });
                
                const pagePhotos = response.result.files;
                allPhotos.push(...pagePhotos);
                nextPageToken = response.result.nextPageToken;
                
                // Debug pour dossiers suspects
                if (pageCount > 1 || pagePhotos.length > 50) {
                    console.log(`üîç Dossier ${folderId} - Page ${pageCount}: ${pagePhotos.length} photos (total: ${allPhotos.length})`);
                }
                
            } while (nextPageToken);
            
            // Log sp√©cial pour debug
            if (allPhotos.length === 0) {
                console.log(`‚ö†Ô∏è AUCUNE photo trouv√©e dans dossier ${folderId} - v√©rifier contenu`);
            } else if (allPhotos.length < 5) {
                console.log(`üîç PEU de photos (${allPhotos.length}) dans dossier ${folderId} - Types MIME:`, 
                    [...new Set(allPhotos.map(p => p.mimeType))]);
            }
            
            return allPhotos.map(photo => ({
                id: photo.id,
                name: photo.name,
                createdTime: photo.createdTime,
                size: photo.size,
                mimeType: photo.mimeType,
                webViewLink: photo.webViewLink,
                type: 'day-photo'
            }));
        } catch (error) {
            console.error(`‚ùå Erreur lecture photos dossier ${folderId}:`, error);
            return [];
        }
    },
    
    /**
     * Cr√©e l'index unifi√© : jours ‚Üí contenu consolid√© - APPELS S√âQUENTIELS
     */
    async buildContentIndex() {
        if (this._photoCache.contentIndex && this._isCacheValid()) {
            console.log('üìã Cache index contenu utilis√©');
            return this._photoCache.contentIndex;
        }
        
        try {
            console.log('üèóÔ∏è Construction index contenu...');
            
            // R√©cup√©rer les donn√©es existantes
            const posts = Storage.get('mastodonPosts', []);
            const folders = await this.scanPhotoFolders();
            const mastodonPhotos = await this.scanMastodonPhotos();
            
            console.log(`üìä Donn√©es de base: ${posts.length} posts, ${folders.length} dossiers, ${mastodonPhotos.length} photos Mastodon`);
            
            // Cr√©er l'index par jour
            const index = {};
            
            // 1. Indexer les posts par jour
            posts.forEach(post => {
                if (post.dayNumber) {
                    const key = `day-${post.dayNumber.toString().padStart(3, '0')}`;
                    if (!index[key]) {
                        index[key] = { 
                            dayNumber: post.dayNumber,
                            posts: [],
                            photos: { main: [], mastodon: [] },
                            completeness: 'empty'
                        };
                    }
                    index[key].posts.push(post);
                }
            });
            
            // 2. Indexer les dossiers photos par jour - S√âQUENTIELLEMENT
            console.log('üîÑ R√©cup√©ration photos par dossier (s√©quentiel)...');
            let processedFolders = 0;
            
            for (const folder of folders) {
                if (folder.dayNumber) {
                    const key = `day-${folder.dayNumber.toString().padStart(3, '0')}`;
                    if (!index[key]) {
                        index[key] = {
                            dayNumber: folder.dayNumber,
                            posts: [],
                            photos: { main: [], mastodon: [] },
                            completeness: 'empty'
                        };
                    }
                    
                    // R√©cup√©rer les photos de ce dossier - AVEC D√âLAI
                    try {
                        const dayPhotos = await this.getPhotosFromDayFolder(folder.id);
                        index[key].photos.main = dayPhotos;
                        index[key].location = folder.location;
                        
                        processedFolders++;
                        
                        // Debug d√©taill√© pour Kampot-Kep et autres cas probl√©matiques
                        if (folder.name.includes('Kampot') || folder.name.includes('114') || dayPhotos.length < 10) {
                            console.log(`üîç DETAIL ${folder.name}: ${dayPhotos.length} photos trouv√©es`);
                        }
                        
                        // Petit d√©lai pour √©viter le throttling (tous les 10 dossiers)
                        if (processedFolders % 10 === 0) {
                            console.log(`‚è≥ Pause anti-throttle (${processedFolders}/${folders.length})`);
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        }
                        
                    } catch (error) {
                        console.error(`‚ùå Erreur dossier ${folder.name}:`, error);
                        index[key].photos.main = [];
                    }
                }
            }
            
            console.log(`‚úÖ ${processedFolders} dossiers trait√©s`);
            
            // 3. Associer photos Mastodon aux jours (via metadata posts si possible)
            // Pour l'instant, on les met dans orphans, l'association sera affin√©e plus tard
            
            // 4. Calculer completeness pour chaque jour
            Object.values(index).forEach(dayData => {
                const hasPosts = dayData.posts.length > 0;
                const hasPhotos = dayData.photos.main.length > 0 || dayData.photos.mastodon.length > 0;
                
                if (hasPosts && hasPhotos) {
                    dayData.completeness = 'full';
                } else if (hasPosts || hasPhotos) {
                    dayData.completeness = 'partial';
                } else {
                    dayData.completeness = 'empty';
                }
            });
            
            // 5. G√©rer les orphelins
            const orphanPosts = posts.filter(p => !p.dayNumber);
            const orphanFolders = folders.filter(f => !f.dayNumber);
            
            index['orphans'] = {
                posts: orphanPosts,
                photos: { 
                    main: [], // Sera peupl√© si n√©cessaire
                    mastodon: mastodonPhotos // Toutes les photos Mastodon pour l'instant
                },
                folders: orphanFolders,
                completeness: 'orphan'
            };
            
            console.log(`‚úÖ Index contenu construit: ${Object.keys(index).length - 1} jours + orphelins`);
            this._photoCache.contentIndex = index;
            
            return index;
        } catch (error) {
            console.error('‚ùå Erreur construction index:', error);
            throw new Error(`Construction index √©chou√©e: ${error.message}`);
        }
    },
    
    /**
     * R√©cup√®re l'URL de t√©l√©chargement direct d'une photo
     */
    async getPhotoUrl(photoId) {
        try {
            const response = await gapi.client.drive.files.get({
                fileId: photoId,
                fields: 'webContentLink'
            });
            
            // Convertir en URL d'affichage direct
            const directUrl = response.result.webContentLink?.replace('&export=download', '&export=view') || 
                             `https://drive.google.com/uc?id=${photoId}`;
            
            return directUrl;
        } catch (error) {
            console.error(`‚ùå Erreur r√©cup√©ration URL photo ${photoId}:`, error);
            return null;
        }
    },
    
    /**
     * Helper pour v√©rifier validit√© du cache (5 minutes)
     */
    _isCacheValid() {
        return this._photoCache.lastRefresh && 
               (Date.now() - this._photoCache.lastRefresh) < 5 * 60 * 1000;
    },
    
    /**
     * Debug : Explorer le contenu d√©taill√© d'un dossier sp√©cifique
     */
    async debugFolderContent(folderId, folderName = 'Unknown') {
        try {
            console.log(`üîç DEBUG dossier "${folderName}" (${folderId})`);
            
            // Lister TOUT le contenu du dossier
            const allContentResponse = await gapi.client.drive.files.list({
                q: `'${folderId}' in parents and trashed=false`,
                fields: 'files(id, name, mimeType, size, createdTime)',
                pageSize: 1000
            });
            
            const allFiles = allContentResponse.result.files;
            console.log(`üìÅ Contenu total dossier "${folderName}": ${allFiles.length} √©l√©ments`);
            
            // Analyser par type
            const byType = {};
            allFiles.forEach(file => {
                const type = file.mimeType || 'unknown';
                if (!byType[type]) byType[type] = [];
                byType[type].push(file.name);
            });
            
            console.log(`üìä Types MIME dans "${folderName}":`, byType);
            
            // Compter les images avec diff√©rents crit√®res
            const imagesByMime = allFiles.filter(f => f.mimeType && f.mimeType.includes('image'));
            const imagesByExt = allFiles.filter(f => 
                f.name.match(/\.(jpg|jpeg|png|gif|heic|webp|bmp|tiff)$/i)
            );
            
            console.log(`üñºÔ∏è Images "${folderName}": ${imagesByMime.length} par MIME, ${imagesByExt.length} par extension`);
            
            return {
                totalFiles: allFiles.length,
                imagesByMime: imagesByMime.length,
                imagesByExt: imagesByExt.length,
                mimeTypes: Object.keys(byType)
            };
            
        } catch (error) {
            console.error(`‚ùå Debug dossier ${folderName} √©chou√©:`, error);
            return null;
        }
    },
};

// ===== MASTODON DATA =====
const MastodonData = {
    posts: [],
    stats: null,
    
    loadPosts() {
        const stored = Storage.get('mastodonPosts');
        if (stored) {
            this.posts = stored;
            this.updateStats();
            console.log(`üìñ ${this.posts.length} posts Mastodon charg√©s du cache`);
        }
        return this.posts;
    },
    
    savePosts(posts) {
        this.posts = posts;
        Storage.set('mastodonPosts', posts);
        this.updateStats();
        console.log(`üíæ ${posts.length} posts sauvegard√©s`);
    },
    
    updateStats() {
        if (this.posts.length === 0) {
            this.stats = null;
            return;
        }
        
        const postsWithDays = this.posts.filter(p => p.dayNumber);
        const importedAt = Storage.get('mastodonImportedAt');
        
        this.stats = {
            total: this.posts.length,
            withDayNumber: postsWithDays.length,
            withoutDayNumber: this.posts.length - postsWithDays.length,
            dateRange: postsWithDays.length > 0 ? {
                min: Math.min(...postsWithDays.map(p => p.dayNumber)),
                max: Math.max(...postsWithDays.map(p => p.dayNumber))
            } : null,
            importedAt
        };
    }
};

// ===== CLOUD SESSION STORAGE =====
const CloudSessionStorage = {
    async getSessions() {
        try {
            if (!GoogleDriveAPI.isSignedIn) {
                console.log('üì± Pas connect√© au cloud, utilisation cache local');
                return Storage.get('sessions', []);
            }
            
            const cloudSessions = await GoogleDriveAPI.loadSessions();
            if (cloudSessions) {
                Storage.set('sessions', cloudSessions);
                console.log(`‚úÖ ${cloudSessions.length} sessions charg√©es depuis Google Drive`);
                return cloudSessions;
            }
        } catch (error) {
            console.warn('‚ö†Ô∏è Erreur chargement cloud:', error.message);
        }
        return Storage.get('sessions', []);
    },
    
    async saveSession(session) {
        const sessions = Storage.get('sessions', []);
        const existingIndex = sessions.findIndex(s => s.id === session.id);
        
        if (existingIndex >= 0) {
            sessions[existingIndex] = session;
        } else {
            sessions.unshift(session);
        }
        
        Storage.set('sessions', sessions);
        
        if (!GoogleDriveAPI.isSignedIn) {
            console.log('üì± Session sauvegard√©e localement (cloud d√©connect√©)');
            return;
        }
        
        try {
            await GoogleDriveAPI.saveSessions(sessions);
            console.log('‚úÖ Session sauvegard√©e localement + cloud');
        } catch (error) {
            console.warn('‚ö†Ô∏è Erreur sauvegarde cloud:', error.message);
            throw new Error(`Sauvegarde cloud √©chou√©e: ${error.message}. Session sauvegard√©e localement.`);
        }
    },
    
    async deleteSession(sessionId) {
        const sessions = Storage.get('sessions', []).filter(s => s.id !== sessionId);
        Storage.set('sessions', sessions);
        
        if (!GoogleDriveAPI.isSignedIn) {
            console.log('üóëÔ∏è Session supprim√©e localement (cloud d√©connect√©)');
            return;
        }
        
        try {
            await GoogleDriveAPI.saveSessions(sessions);
            console.log('‚úÖ Session supprim√©e localement + cloud');
        } catch (error) {
            console.warn('‚ö†Ô∏è Erreur suppression cloud:', error.message);
            throw new Error(`Suppression cloud √©chou√©e: ${error.message}. Session supprim√©e localement.`);
        }
    }
};

// ===== COMPOSANTS UTILITAIRES =====
const LoadingSpinner = ({ size = 'md', color = 'orange' }) => {
    const sizeClasses = {
        sm: 'w-4 h-4',
        md: 'w-6 h-6', 
        lg: 'w-8 h-8'
    };
    
    const colorClasses = {
        orange: 'border-orange-500',
        blue: 'border-blue-500',
        green: 'border-green-500'
    };
    
    return (
        <div className={`${sizeClasses[size]} ${colorClasses[color]} border-2 border-t-transparent rounded-full animate-spin`}></div>
    );
};

// ===== NOUVEAU COMPOSANT : PHOTO CONTENT INDEX =====
const PhotoContentIndex = () => {
    const [contentIndex, setContentIndex] = React.useState(null);
    const [loading, setLoading] = React.useState(false);
    const [error, setError] = React.useState(null);
    
    // Charger l'index de contenu
    const loadContentIndex = async () => {
        if (!GoogleDriveAPI.isSignedIn) {
            setError('Connexion Google Drive requise');
            return;
        }
        
        setLoading(true);
        setError(null);
        
        try {
            const index = await GoogleDriveAPI.buildContentIndex();
            setContentIndex(index);
            console.log('‚úÖ Index contenu charg√©:', index);
        } catch (err) {
            setError(err.message);
            console.error('‚ùå Erreur chargement index:', err);
        } finally {
            setLoading(false);
        }
    };
    
    React.useEffect(() => {
        if (GoogleDriveAPI.isSignedIn) {
            loadContentIndex();
        }
    }, [GoogleDriveAPI.isSignedIn]);
    
    if (!GoogleDriveAPI.isSignedIn) {
        return (
            <div className="bg-yellow-100 border-l-4 border-yellow-500 p-4 rounded-r">
                <div className="flex items-center">
                    <span className="text-yellow-600">‚ö†Ô∏è Connexion Google Drive requise pour les photos</span>
                </div>
            </div>
        );
    }
    
    if (loading) {
        return (
            <div className="flex flex-col items-center justify-center p-8 space-y-4">
                <LoadingSpinner size="lg" />
                <div className="text-center">
                    <div className="text-gray-600 font-medium">Construction de l'index des photos...</div>
                    <div className="text-sm text-gray-500 mt-1 space-y-1">
                        <div>‚è≥ Scan s√©quentiel pour √©viter throttling Google Drive</div>
                        <div>üîç Debug d√©taill√© activ√© (voir console)</div>
                        <div>‚ö° Dur√©e estim√©e : 1-2 minutes</div>
                    </div>
                </div>
            </div>
        );
    }
    
    if (error) {
        return (
            <div className="bg-red-100 border-l-4 border-red-500 p-4 rounded-r">
                <div className="flex items-center justify-between">
                    <span className="text-red-700">‚ùå {error}</span>
                    <button 
                        onClick={loadContentIndex}
                        className="px-3 py-1 bg-red-500 text-white rounded hover:bg-red-600 text-sm"
                    >
                        R√©essayer
                    </button>
                </div>
            </div>
        );
    }
    
    if (!contentIndex) return null;
    
    // Calculer statistiques
    const days = Object.keys(contentIndex).filter(key => key.startsWith('day-'));
    const stats = {
        totalDays: days.length,
        fullDays: days.filter(day => contentIndex[day].completeness === 'full').length,
        partialDays: days.filter(day => contentIndex[day].completeness === 'partial').length,
        emptyDays: days.filter(day => contentIndex[day].completeness === 'empty').length,
        orphans: contentIndex.orphans
    };
    
    return (
        <div className="space-y-4">
            {/* Header avec stats */}
            <div className="bg-white rounded-lg p-4 border border-orange-200">
                <h3 className="text-lg font-semibold text-orange-800 mb-3">üì∏ Index Photos & Contenu</h3>
                
                <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                    <div className="text-center p-2 bg-green-50 rounded">
                        <div className="text-2xl font-bold text-green-600">{stats.fullDays}</div>
                        <div className="text-green-700">Jours complets</div>
                        <div className="text-xs text-green-600">(posts + photos)</div>
                    </div>
                    
                    <div className="text-center p-2 bg-yellow-50 rounded">
                        <div className="text-2xl font-bold text-yellow-600">{stats.partialDays}</div>
                        <div className="text-yellow-700">Jours partiels</div>
                        <div className="text-xs text-yellow-600">(posts ou photos)</div>
                    </div>
                    
                    <div className="text-center p-2 bg-gray-50 rounded">
                        <div className="text-2xl font-bold text-gray-600">{stats.emptyDays}</div>
                        <div className="text-gray-700">Jours vides</div>
                        <div className="text-xs text-gray-600">(ni posts ni photos)</div>
                    </div>
                    
                    <div className="text-center p-2 bg-purple-50 rounded">
                        <div className="text-2xl font-bold text-purple-600">
                            {(stats.orphans.posts.length + stats.orphans.photos.mastodon.length + stats.orphans.folders.length)}
                        </div>
                        <div className="text-purple-700">Orphelins</div>
                        <div className="text-xs text-purple-600">(sans jour)</div>
                    </div>
                </div>
                
                <button 
                    onClick={() => GoogleDriveAPI.refreshPhotoCache().then(setContentIndex)}
                    className="mt-3 px-3 py-1 bg-orange-500 text-white rounded hover:bg-orange-600 text-sm mr-2"
                >
                    üîÑ Actualiser
                </button>
                
                <button 
                    onClick={async () => {
                        // Test sp√©cial Kampot-Kep
                        const folders = await GoogleDriveAPI.scanPhotoFolders();
                        const kampotFolder = folders.find(f => f.name.includes('Kampot') || f.name.includes('114'));
                        if (kampotFolder) {
                            console.log('üîç TEST KAMPOT-KEP:');
                            await GoogleDriveAPI.debugFolderContent(kampotFolder.id, kampotFolder.name);
                        } else {
                            console.log('‚ùå Dossier Kampot-Kep non trouv√©');
                        }
                    }}
                    className="mt-3 px-3 py-1 bg-red-500 text-white rounded hover:bg-red-600 text-sm"
                >
                    üîç Debug Kampot-Kep
                </button>
            </div>
            
            {/* Liste d√©taill√©e */}
            <div className="bg-white rounded-lg border border-orange-200">
                <div className="p-4 border-b border-orange-200">
                    <h4 className="font-semibold text-orange-800">D√©tail par jour</h4>
                </div>
                
                <div className="max-h-96 overflow-y-auto">
                    {days.sort().map(dayKey => {
                        const dayData = contentIndex[dayKey];
                        const statusIcon = {
                            'full': 'üü¢',
                            'partial': 'üü°', 
                            'empty': 'üî¥'
                        }[dayData.completeness];
                        
                        return (
                            <div key={dayKey} className="p-3 border-b border-gray-100 hover:bg-orange-50">
                                <div className="flex items-center justify-between">
                                    <div className="flex items-center space-x-3">
                                        <span className="text-lg">{statusIcon}</span>
                                        <div>
                                            <div className="font-medium">Jour {dayData.dayNumber}</div>
                                            {dayData.location && (
                                                <div className="text-sm text-gray-600">{dayData.location}</div>
                                            )}
                                        </div>
                                    </div>
                                    
                                    <div className="flex items-center space-x-4 text-sm text-gray-600">
                                        <span>üìù {dayData.posts.length}</span>
                                        <span>üì∏ {dayData.photos.main.length}</span>
                                        <span>üñºÔ∏è {dayData.photos.mastodon.length}</span>
                                    </div>
                                </div>
                            </div>
                        );
                    })}
                </div>
            </div>
            
            {/* Orphelins + Debug */}
            {(stats.orphans.posts.length > 0 || stats.orphans.folders.length > 0 || stats.orphans.photos.mastodon.length > 0) && (
                <div className="bg-purple-50 border border-purple-200 rounded-lg p-4">
                    <h4 className="font-semibold text-purple-800 mb-2">üîç Contenu orphelin & Debug</h4>
                    <div className="text-sm text-purple-700 space-y-2">
                        <div>üìù {stats.orphans.posts.length} posts sans num√©ro de jour</div>
                        <div>üìÅ {stats.orphans.folders.length} dossiers sans jour associ√©</div>
                        <div>üñºÔ∏è {stats.orphans.photos.mastodon.length} photos Mastodon</div>
                        
                        {/* Afficher quelques exemples de dossiers orphelins */}
                        {stats.orphans.folders.length > 0 && (
                            <details className="mt-3">
                                <summary className="cursor-pointer font-medium">üîç Exemples dossiers orphelins</summary>
                                <div className="mt-2 space-y-1 text-xs">
                                    {stats.orphans.folders.slice(0, 10).map((folder, i) => (
                                        <div key={i} className="bg-white p-2 rounded">
                                            üìÅ "{folder.name}" 
                                            {folder.parsed === false && <span className="text-red-600"> (parsing √©chou√©)</span>}
                                        </div>
                                    ))}
                                </div>
                            </details>
                        )}
                    </div>
                </div>
            )}
            
            {/* Debug Mastodon */}
            <div className="bg-gray-50 border border-gray-200 rounded-lg p-4">
                <h4 className="font-semibold text-gray-800 mb-2">Debug Mastodon</h4>
                <div className="text-sm text-gray-700">
                    Posts charg√©s : {MastodonData.posts.length}
                    {MastodonData.posts.length === 0 && (
                        <span className="text-red-600 ml-2">(Aucun post charg√© !)</span>
                    )}
                </div>
                <button 
                    onClick={() => {
                        MastodonData.loadPosts();
                        window.location.reload(); // Force refresh
                    }}
                    className="mt-2 px-3 py-1 bg-gray-500 text-white rounded hover:bg-gray-600 text-sm"
                >
                    Recharger posts Mastodon
                </button>
            </div>
        </div>
    );
};

// ===== COMPOSANT PRINCIPAL (temporaire pour test) =====
const TestApp = () => {
    const [isSignedIn, setIsSignedIn] = React.useState(false);
    const [loading, setLoading] = React.useState(false);
    
    React.useEffect(() => {
        // Initialiser l'API et v√©rifier l'√©tat de connexion
        GoogleDriveAPI.init().then(() => {
            setIsSignedIn(GoogleDriveAPI.isSignedIn);
        });
        
        // Charger les posts Mastodon existants
        MastodonData.loadPosts();
    }, []);
    
    const handleSignIn = async () => {
        setLoading(true);
        try {
            await GoogleDriveAPI.signIn();
            setIsSignedIn(true);
        } catch (error) {
            console.error('Erreur connexion:', error);
        } finally {
            setLoading(false);
        }
    };
    
    const handleSignOut = async () => {
        await GoogleDriveAPI.signOut();
        setIsSignedIn(false);
    };
    
    return (
        <div className="min-h-screen p-4">
            <div className="max-w-4xl mx-auto">
                {/* Header */}
                <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                    <h1 className="text-2xl font-bold text-orange-800">üéØ M√©moire du M√©kong V0.5.6</h1>
                    <p className="text-gray-600 mt-1">FIX MAJEUR : D√©tection .heif/.heic (photos iPhone)</p>
                    
                    <div className="mt-4 flex items-center justify-between">
                        <div className="flex items-center space-x-4">
                            <div className={`w-3 h-3 rounded-full ${isSignedIn ? 'bg-green-500' : 'bg-red-500'}`}></div>
                            <span className={`font-medium ${isSignedIn ? 'text-green-700' : 'text-red-700'}`}>
                                {isSignedIn ? 'Connect√© √† Google Drive' : 'D√©connect√©'}
                            </span>
                        </div>
                        
                        {!isSignedIn ? (
                            <button 
                                onClick={handleSignIn}
                                disabled={loading}
                                className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50 flex items-center space-x-2"
                            >
                                {loading && <LoadingSpinner size="sm" color="blue" />}
                                <span>Se connecter</span>
                            </button>
                        ) : (
                            <button 
                                onClick={handleSignOut}
                                className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
                            >
                                Se d√©connecter
                            </button>
                        )}
                    </div>
                </div>
                
                {/* Test API Photos avec bon scope */}
                <PhotoContentIndex />
            </div>
        </div>
    );
};

// ===== RENDU =====
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<TestApp />);

</script>
</body>
</html>
