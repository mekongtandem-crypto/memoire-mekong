<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üêò M√©moire du M√©kong V0.5.18 nouvelle Home Page </title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://apis.google.com/js/api.js"></script>
	<script src="https://accounts.google.com/gsi/client"></script>
	<script>
	window.onload = () => {
  		google.accounts.id.initialize({
    		client_id: '82966045106-hso0nr386agcuojllnud0dr41vcsh45a.apps.googleusercontent.com'
  		});
		};
	</script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        .lucide { width: 1em; height: 1em; fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; }
        .fade-in { animation: fadeIn 0.3s ease-in; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]:focus { outline: none; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 20px; width: 20px; border-radius: 50%; background: #c2410c; cursor: pointer; margin-top: -8px; }
        input[type=range]::-moz-range-thumb { height: 20px; width: 20px; border-radius: 50%; background: #c2410c; cursor: pointer; }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: #fbbf24; border-radius: 5px; }
        input[type=range]::-moz-range-track { width: 100%; height: 4px; cursor: pointer; background: #fbbf24; border-radius: 5px; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // ===== ICONS LUCIDE =====
        const X = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>;
        const Home = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9,22 9,12 15,12 15,22"/></svg>;
        const Users = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="m22 21-2-2"/></svg>;
        const Camera = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/></svg>;
        const Cloud = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z"/></svg>;
        const Settings = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M12.22 2h-.44a2 2 0 0 0-2 2.18l.2 1.81c-.26.06-.51.14-.76.23l-1.5-1.16a2 2 0 0 0-2.83.32l-.22.38a2 2 0 0 0 .32 2.83l1.16 1.5c-.09.25-.17.5-.23.76l-1.81.2a2 2 0 0 0-2.18 2v.44a2 2 0 0 0 2.18 2l1.81.2c.06.26.14.51.23.76l-1.16 1.5a2 2 0 0 0-.32 2.83l.38.22a2 2 0 0 0 2.83-.32l1.5-1.16c.25.09.5.17.76.23l.2 1.81a2 2 0 0 0 2 2.18h.44a2 2 0 0 0 2-2.18l.2-1.81c.26-.06.51-.14-.76-.23l1.5 1.16a2 2 0 0 0 2.83-.32l.22-.38a2 2 0 0 0-.32-2.83l-1.16-1.5c.09-.25-.17-.5-.23-.76l1.81-.2a2 2 0 0 0 2.18-2v-.44a2 2 0 0 0-2.18-2l-1.81-.2c-.06-.26-.14-.51-.23-.76l1.16-1.5a2 2 0 0 0 .32-2.83l-.38-.22a2 2 0 0 0-2.83.32l-1.5 1.16c-.25-.09-.5-.17-.76-.23l-.2-1.81a2 2 0 0 0-2-2.18Z"/><circle cx="12" cy="12" r="3"/></svg>;
        const BookOpen = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg>;
        const Plus = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M5 12h14"/><path d="M12 5v14"/></svg>;
        const Shuffle = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><polyline points="16,3 21,3 21,8"/><line x1="4" x2="21" y1="20" y2="3"/><polyline points="21,16 21,21 16,21"/><line x1="15" x2="21" y1="15" y2="21"/><line x1="4" x2="9" y1="4" y2="9"/></svg>;
        const Play = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><polygon points="5 3 19 12 5 21 5 3"/></svg>;
        const Pause = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/></svg>;
        const Clock = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></svg>;
        const Mic = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" y1="19" x2="12" y2="22"/></svg>;
        const Zap = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/></svg>;
        const MapPin = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"/><circle cx="12" cy="10" r="3"/></svg>;
        const Trash2 = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><polyline points="3 6 5 6 21 6"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>;
        const Send = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><line x1="22" y1="2" x2="11" y2="13"/><polygon points="22 2 15 22 11 13 2 9 22 2"/></svg>;
        const Edit = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"/></svg>;
        const FileText = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><polyline points="14 2 14 8 20 8"/><line x1="16" y1="13" x2="8" y2="13"/><line x1="16" y1="17" x2="8" y2="17"/><polyline points="10 9 9 9 8 9"/></svg>;

		// ===== COMPOSANT TOAST (Alerte) =====
		const Toast = ({ message, type, onDismiss }) => {
    		if (!message) return null;
    		const styles = { error: { bg: 'bg-red-100', text: 'text-red-800', border: 'border-red-300' }, success: { bg: 'bg-green-100', text: 'text-green-800', border: 'border-green-300' } };
    		const style = styles[type] || styles.error;
    		return ( <div className={`fixed bottom-4 right-4 max-w-sm p-4 border rounded-lg shadow-lg fade-in ${style.bg} ${style.text} ${style.border}`}> <div className="flex justify-between items-center"> <span>{message}</span> <button onClick={onDismiss} className="ml-4 text-xl font-bold">&times;</button> </div> </div> );
		};
		
        // ===== CORE STORAGE =====
        const Storage = {
            get: (key, defaultValue = null) => { try { const item = localStorage.getItem(`mekong_${key}`); return item ? JSON.parse(item) : defaultValue; } catch { return defaultValue; } },
            set: (key, value) => { try { localStorage.setItem(`mekong_${key}`, JSON.stringify(value)); return true; } catch { return false; } },
            remove: (key) => localStorage.removeItem(`mekong_${key}`),
            clear: () => { Object.keys(localStorage).forEach(key => { if (key.startsWith('mekong_')) localStorage.removeItem(key); }); }
        };

        // ===== CORE STATES =====
        const useAppState = () => {
            const [currentPage, setCurrentPage] = React.useState('home');
            const [currentUser, setCurrentUser] = React.useState(Storage.get('currentUser', ''));
            React.useEffect(() => { Storage.set('currentUser', currentUser); }, [currentUser]);
            const resetApp = () => { setCurrentPage('home'); setCurrentUser(''); Storage.clear(); };
            return { currentPage, setCurrentPage, currentUser, setCurrentUser, resetApp };
        };
		
        // ===== MASTODON DATA MANAGEMENT =====
        const MastodonData = {
    decodeHtmlEntities: (text) => {
        if (typeof text !== 'string') return '';
        const textArea = document.createElement('textarea');
        textArea.innerHTML = text;
        return textArea.value;
    },
    savePosts: (posts) => {
        Storage.set('mastodon_posts', posts);
        Storage.set('mastodon_imported_at', new Date().toISOString());
    },
    parseOutbox: (jsonData) => {
        try {
            const data = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;
            const orderedItems = data.orderedItems || data.data?.orderedItems;
            if (!Array.isArray(orderedItems)) throw new Error('orderedItems non trouv√© ou invalide');
            const allPosts = orderedItems.filter(item => item.type === 'Create' && item.object?.type === 'Note').map((item, index) => {
                const note = item.object;
                const content = note.content || '';
                const cleanContent = content.replace(/<p>|<\/p>/g, '\n').replace(/<br\s*\/?>/g, '\n').replace(/<[^>]*>/g, '').trim();
                const decodedContent = MastodonData.decodeHtmlEntities(cleanContent);
                const dayMatch = decodedContent.match(/^J(\d{1,3})[\s:]/);
                const dayNumber = dayMatch ? parseInt(dayMatch[1]) : null;
                let title = '';
                let contentOnly = decodedContent;

                if (dayNumber !== null) {
                    const titleAndContent = decodedContent.replace(/^J\d{1,3}[\s:]+/, '');
                    const lines = titleAndContent.split('\n');
                    title = MastodonData.decodeHtmlEntities(lines[0].trim());
                    contentOnly = lines.slice(1).join('\n').trim(); // On ne garde que le reste du contenu
                } else {
                    const lines = decodedContent.split('\n');
                    title = MastodonData.decodeHtmlEntities(lines[0].trim());
                    contentOnly = lines.slice(1).join('\n').trim();
                }

                return { id: note.id || `post-${index}`, dayNumber, hasJourNumber: dayNumber !== null, title: title.slice(0, 80) || 'Post sans titre', content: contentOnly, published: note.published || item.published, attachments: note.attachment || [], url: note.url };
            });
            // ... Le reste de la logique de tri reste inchang√©
            const postsWithDay = allPosts.filter(post => post.hasJourNumber);
            const postsWithoutDay = allPosts.filter(post => !post.hasJourNumber);
            postsWithDay.sort((a, b) => a.dayNumber - b.dayNumber);
            const maxDayNumber = postsWithDay.length > 0 ? Math.max(...postsWithDay.map(p => p.dayNumber)) : 0;
            postsWithoutDay.forEach((post, index) => { post.dayNumber = maxDayNumber + index + 1; post.isExtraPost = true; });
            const finalPosts = [...postsWithDay, ...postsWithoutDay];
            finalPosts.forEach(post => { delete post.hasJourNumber; });
            return finalPosts;
        } catch (error) { console.error('‚ùå Erreur parsing outbox:', error); throw error; }
    },
    getPosts: () => Storage.get('mastodon_posts', []),
    getPostByDay: (dayNumber) => MastodonData.getPosts().find(p => p.dayNumber === dayNumber),
    isImported: () => MastodonData.getPosts().length > 0,
    getStats: () => {
        const posts = MastodonData.getPosts();
        if (posts.length === 0) return { totalPosts: 0, dayRange: null, importedAt: null };
        const dayNumbers = posts.map(p => p.dayNumber).filter(n => n !== null);
        return { totalPosts: posts.length, dayRange: dayNumbers.length > 0 ? { min: Math.min(...dayNumbers), max: Math.max(...dayNumbers) } : null, importedAt: Storage.get('mastodon_imported_at') };
    },
};

// ===== GOOGLE DRIVE API =====
const GoogleDriveAPI = {
    isSignedIn: false, 
    isInitialized: false, 
    tokenClient: null, 
    _folderIdCache: new Map(), 
    _fileIdCache: new Map(),
    _photosByDayCache: new Map(),
    _cacheTimeout: 5 * 60 * 1000, // 5 minutes
    _maxCacheSize: 50, // Maximum 50 jours en cache

    async init() {
                if (this.isInitialized) return;
                try {
                    await new Promise((resolve) => gapi.load('client', resolve));
                    await gapi.client.init({ 
                        apiKey: 'AIzaSyDiyLLN4EsyVREGxF4TzqbuKyugaq4TUXw', 
                        discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'] 
                    });
                    this.tokenClient = google.accounts.oauth2.initTokenClient({ 
                        client_id: '82966045106-hso0nr386agcuojllnud0dr41vcsh45a.apps.googleusercontent.com', 
                        // SCOPE R√âDUIT : moins sensible pour Google
                        scope: 'https://www.googleapis.com/auth/drive.file', 
                        callback: '' 
                    });
                    this.isInitialized = true;
                    console.log('‚úÖ Google Drive API initialis√© avec scopes r√©duits');
                } catch (error) { 
                    console.error('‚ùå Erreur init Google Drive API:', error); 
                    throw error; 
                }
            },

    async signIn() {
        if (!this.isInitialized) await this.init();
        return new Promise((resolve, reject) => {
            if (!this.tokenClient) return reject(new Error('Token client non initialis√©'));
            this.tokenClient.callback = async (response) => {
                if (response.error) { 
                    this.isSignedIn = false; 
                    return reject(new Error(`Erreur OAuth: ${response.error}`)); 
                }
                try { 
                    await Promise.race([
                        gapi.client.drive.files.list({ pageSize: 1 }),
                        new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 10000))
                    ]);
                    this.isSignedIn = true; 
                    resolve(true); 
                } catch (error) { 
                    this.isSignedIn = false; 
                    reject(new Error('Acc√®s API Drive impossible')); 
                }
            };
            const token = gapi.client.getToken();
            if (token) { 
                Promise.race([
                    gapi.client.drive.files.list({ pageSize: 1 }),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 10000))
                ]).then(() => { 
                    this.isSignedIn = true; 
                    resolve(true); 
                }).catch(() => { 
                    gapi.client.setToken(''); 
                    this.tokenClient.requestAccessToken({ prompt: 'consent' }); 
                }); 
            } else { 
                this.tokenClient.requestAccessToken({ prompt: 'consent' }); 
            }
        });
    },

    async signOut() {
        // Vider tous les caches √† la d√©connexion
        this._photosByDayCache.clear();
        this._folderIdCache.clear();
        this._fileIdCache.clear();
        const token = gapi.client.getToken();
        if (token) { 
            google.accounts.oauth2.revoke(token.access_token); 
            gapi.client.setToken(''); 
        }
        this.isSignedIn = false;
    },

    async findMekongFile() {
        if (!this.isSignedIn) return null;
        try {
            const response = await Promise.race([
                gapi.client.drive.files.list({
                    q: "name='mekong_sessions.json' and trashed=false",
                    fields: 'files(id, name)'
                }),
                new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 15000))
            ]);
            return response.result.files[0] || null;
        } catch (error) {
            console.error('‚ùå Erreur recherche fichier:', error);
            return null;
        }
    },

    async saveSessions(sessions) {
        console.log('üìÑ D√©but saveSessions, isSignedIn:', this.isSignedIn);
        
        if (!this.isSignedIn) {
            console.warn('‚ö†Ô∏è Pas connect√© - sauvegarde locale uniquement');
            return false;
        }
        
        try {
            const data = JSON.stringify({ 
                sessions, 
                lastUpdated: new Date().toISOString(),
                version: '0.5.11'
            }, null, 2);
            
            const existingFile = await this.findMekongFile();
            
            if (existingFile) {
                const response = await Promise.race([
                    gapi.client.request({
                        path: `https://www.googleapis.com/upload/drive/v3/files/${existingFile.id}`,
                        method: 'PATCH',
                        params: { uploadType: 'media' },
                        headers: { 'Content-Type': 'application/json' },
                        body: data
                    }),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout sauvegarde')), 30000))
                ]);
                console.log('‚úÖ Sessions sauvegard√©es (MAJ)', response);
                return true;
            } else {
                const boundary = '-------314159265358979323846';
                const delimiter = "\r\n--" + boundary + "\r\n";
                const close_delim = "\r\n--" + boundary + "--";

                const metadata = {
                    'name': 'mekong_sessions.json',
                    'mimeType': 'application/json'
                };

                const multipartRequestBody =
                    delimiter +
                    'Content-Type: application/json\r\n\r\n' +
                    JSON.stringify(metadata) +
                    delimiter +
                    'Content-Type: application/json\r\n\r\n' +
                    data +
                    close_delim;

                const response = await Promise.race([
                    gapi.client.request({
                        'path': 'https://www.googleapis.com/upload/drive/v3/files',
                        'method': 'POST',
                        'params': {'uploadType': 'multipart'},
                        'headers': {
                            'Content-Type': 'multipart/related; boundary="' + boundary + '"'
                        },
                        'body': multipartRequestBody
                    }),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout cr√©ation')), 30000))
                ]);
                console.log('‚úÖ Sessions sauvegard√©es (NOUVEAU)', response);
                return true;
            }
        } catch (error) {
            console.error('‚ùå Erreur sauvegarde d√©taill√©e:', error);
            return false;
        }
    },

    async loadSessions() {
        if (!this.isSignedIn) return null;
        
        try {
            const file = await this.findMekongFile();
            if (!file) return null;
            
            const response = await Promise.race([
                gapi.client.drive.files.get({
                    fileId: file.id,
                    alt: 'media'
                }),
                new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout chargement')), 20000))
            ]);
            
            const data = JSON.parse(response.body);
            console.log('‚úÖ Sessions charg√©es depuis Google Drive');
            return data.sessions || [];
        } catch (error) {
            console.error('‚ùå Erreur chargement:', error);
            return null;
        }
    },

    _cleanCache() {
        // Nettoyer le cache si trop volumineux
        if (this._photosByDayCache.size > this._maxCacheSize) {
            const entries = Array.from(this._photosByDayCache.entries());
            // Garder les 30 plus r√©cents
            const toKeep = entries.slice(-30);
            this._photosByDayCache.clear();
            toKeep.forEach(([key, value]) => this._photosByDayCache.set(key, value));
            console.log('üßπ Cache photos nettoy√©');
        }
    },

    async findFolderByPath(path) {
        if (this._folderIdCache.has(path)) return this._folderIdCache.get(path);
        const parts = path.split('/').filter(p => p);
        let parentId = 'root';
        
        try {
            for (const part of parts) {
                const response = await Promise.race([
                    gapi.client.drive.files.list({ 
                        q: `'${parentId}' in parents and mimeType='application/vnd.google-apps.folder' and name='${part}' and trashed=false`, 
                        fields: 'files(id, name)' 
                    }),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 15000))
                ]);
                const folder = response.result.files[0];
                if (!folder) throw new Error(`Dossier non trouv√©: ${part}`);
                parentId = folder.id;
            }
            this._folderIdCache.set(path, parentId);
            return parentId;
        } catch (error) { 
            console.error(`Erreur recherche dossier ${path}:`, error); 
            return null; 
        }
    },

    async getPhotosByDay(dayNumber) {
        // V√©rifier le cache avec timestamp
        const cacheKey = dayNumber;
        const cached = this._photosByDayCache.get(cacheKey);
        if (cached && cached.timestamp && (Date.now() - cached.timestamp < this._cacheTimeout)) {
            console.log(`üì∏ Cache hit pour jour ${dayNumber}`);
            return { photos: cached.photos, folderName: cached.folderName };
        }

        const photoFolderPath = Storage.get('photoFolderPath', '/Medias/Photos/');
        const parentFolderId = await this.findFolderByPath(photoFolderPath);
        if (!parentFolderId) {
            console.warn('‚ùå Dossier photos parent non trouv√©');
            return { photos: [], folderName: null };
        }
        
        const dayString = String(dayNumber).padStart(3, '0');
        try {
            const folderResponse = await Promise.race([
                gapi.client.drive.files.list({ 
                    q: `'${parentFolderId}' in parents and mimeType='application/vnd.google-apps.folder' and name starts with '${dayString}' and trashed=false`, 
                    fields: 'files(id, name)' 
                }),
                new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout recherche dossier')), 15000))
            ]);

            const dayFolder = folderResponse.result.files[0];
            if (!dayFolder) {
                const emptyResult = { photos: [], folderName: null, timestamp: Date.now() };
                this._photosByDayCache.set(cacheKey, emptyResult);
                this._cleanCache();
                return { photos: [], folderName: null };
            }

            let allPhotos = [];
            let pageToken = null;
            let requestCount = 0;
            const maxRequests = 10; // Limite de s√©curit√©

            do {
                if (requestCount >= maxRequests) {
                    console.warn(`‚ö†Ô∏è Limite de requ√™tes atteinte pour jour ${dayNumber}`);
                    break;
                }

                const photosResponse = await Promise.race([
                    gapi.client.drive.files.list({
                        q: `'${dayFolder.id}' in parents and mimeType contains 'image/' and trashed=false`,
                        fields: 'files(id, name, thumbnailLink, mimeType), nextPageToken',
                        pageSize: 100,
                        pageToken: pageToken
                    }),
                    new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout photos')), 20000))
                ]);
                
                if (photosResponse.result.files) {
                    allPhotos = allPhotos.concat(photosResponse.result.files);
                }
                pageToken = photosResponse.result.nextPageToken;
                requestCount++;
            } while (pageToken);

            const result = {
                photos: allPhotos.map(file => ({ 
                    id: file.id, 
                    title: file.name, 
                    thumbnailUrl: file.thumbnailLink, 
                    mimeType: file.mimeType 
                })),
                folderName: dayFolder.name,
                timestamp: Date.now()
            };

            this._photosByDayCache.set(cacheKey, result);
            this._cleanCache();
            console.log(`üì∏ ${result.photos.length} photos charg√©es pour jour ${dayNumber}`);
            return { photos: result.photos, folderName: result.folderName };

        } catch (error) { 
            console.error(`‚ùå Erreur chargement photos jour ${dayNumber}:`, error);
            // Cache l'erreur pour √©viter les re-tentatives imm√©diates
            const errorResult = { photos: [], folderName: null, timestamp: Date.now(), error: true };
            this._photosByDayCache.set(cacheKey, errorResult);
            return { photos: [], folderName: null, error: error.message }; 
        }
    },

    async getPhotoAsBase64(fileId, mimeType) {
        try {
            const response = await Promise.race([
                gapi.client.drive.files.get({ fileId: fileId, alt: 'media' }),
                new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout image')), 30000))
            ]);
            
            const raw = response.body;
            const rawLength = raw.length;
            const array = new Uint8Array(new ArrayBuffer(rawLength));
            for (let i = 0; i < rawLength; i++) {
                array[i] = raw.charCodeAt(i);
            }
            const blob = new Blob([array], { type: mimeType });
            return new Promise((resolve, reject) => { 
                const reader = new FileReader(); 
                reader.onloadend = () => resolve(reader.result); 
                reader.onerror = reject; 
                reader.readAsDataURL(blob); 
            });
        } catch (error) { 
            console.error(`‚ùå Erreur chargement image ${fileId}:`, error); 
            return null; 
        }
    },

    async findFileByPartialPath(filename, rootPath) {
        const cacheKey = `${rootPath}:${filename}`;
        if (this._fileIdCache.has(cacheKey)) return this._fileIdCache.get(cacheKey);
        
        const rootFolderId = await this.findFolderByPath(rootPath);
        if (!rootFolderId) { 
            console.warn(`Dossier racine non trouv√©: ${rootPath}`); 
            return null; 
        }
        
        try {
            const response = await Promise.race([
                gapi.client.drive.files.list({ 
                    q: `'${rootFolderId}' in parents and name='${filename}' and trashed=false`, 
                    fields: 'files(id, webContentLink)', 
                    pageSize: 1 
                }),
                new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 15000))
            ]);
            
            const file = response.result.files[0];
            if (file) { 
                this._fileIdCache.set(cacheKey, file); 
                return file; 
            }
            return null;
        } catch (error) { 
            console.error(`Erreur recherche fichier ${filename}:`, error); 
            return null; 
        }
    },

    // M√©thode pour vider le cache manuellement
    clearPhotoCache() {
        this._photosByDayCache.clear();
        console.log('üßπ Cache photos vid√© manuellement');
    }
};
// ===== USER CONFIG =====
        const USERS = { 
            tom: { name: 'Tom le jeune √©l√©phantau', color: 'blue', emoji: 'üêò' }, 
            lambert: { name: 'Lambert, le Vieux Pachiderme', color: 'green', emoji: 'üêò' }, 
            duo: { name: 'Duo Mekong Tandem', color: 'amber', emoji: 'üêòüêò' } 
        };
        
        const getUserStyle = (userKey) => { 
            const user = USERS[userKey]; 
            if (!user) return { bg: 'bg-gray-100', border: 'border-gray-300', text: 'text-gray-800' }; 
            const styles = { 
                blue: { bg: 'bg-blue-100 hover:bg-blue-200', border: 'border-blue-300', text: 'text-blue-800' }, 
                green: { bg: 'bg-green-100 hover:bg-green-200', border: 'border-green-300', text: 'text-green-800' }, 
                amber: { bg: 'bg-amber-100 hover:bg-amber-200', border: 'border-amber-300', text: 'text-amber-800' } 
            }; 
            return styles[user.color] || styles.blue; 
        };

        const CloudSessionStorage = {
            async getSessions() {
                try {
                    if (!GoogleDriveAPI.isSignedIn) {
                        console.log('üì± Pas connect√© au cloud, utilisation cache local');
                        return Storage.get('sessions', []);
                    }
                    
                    const cloudSessions = await GoogleDriveAPI.loadSessions();
                    if (cloudSessions) {
                        Storage.set('sessions', cloudSessions);
                        console.log(`‚úÖ ${cloudSessions.length} sessions charg√©es depuis Google Drive`);
                        return cloudSessions;
                    }
                } catch (error) {
                    console.warn('‚ö†Ô∏è Erreur chargement cloud:', error.message);
                }
                return Storage.get('sessions', []);
            },
            
            async saveSession(session) {
                const sessions = Storage.get('sessions', []);
                const existingIndex = sessions.findIndex(s => s.id === session.id);
                if (existingIndex >= 0) {
                    sessions[existingIndex] = session;
                } else {
                    sessions.unshift(session);
                }
                Storage.set('sessions', sessions);
                
                if (!GoogleDriveAPI.isSignedIn) {
                    console.log('üì± Session sauvegard√©e localement (cloud d√©connect√©)');
                    return;
                }
                
                try {
                    await GoogleDriveAPI.saveSessions(sessions);
                    console.log('‚úÖ Session sauvegard√©e localement + cloud');
                } catch (error) {
                    console.warn('‚ö†Ô∏è Erreur sauvegarde cloud:', error.message);
                    throw new Error(`Sauvegarde cloud √©chou√©e: ${error.message}. Session sauvegard√©e localement.`);
                }
            },
            
            async deleteSession(sessionId) {
                const sessions = Storage.get('sessions', []).filter(s => s.id !== sessionId);
                Storage.set('sessions', sessions);
                
                if (!GoogleDriveAPI.isSignedIn) {
                    console.log('üóëÔ∏è Session supprim√©e localement (cloud d√©connect√©)');
                    return;
                }
                
                try {
                    await GoogleDriveAPI.saveSessions(sessions);
                    console.log('‚úÖ Session supprim√©e localement + cloud');
                } catch (error) {
                    console.warn('‚ö†Ô∏è Erreur suppression cloud:', error.message);
                    throw new Error(`Suppression cloud √©chou√©e: ${error.message}. Session supprim√©e localement.`);
                }
            }
        };
// ===== SESSION MANAGEMENT & HOOKS =====
const useSessionState = () => {
    const [currentSession, setCurrentSession] = React.useState(null);
    const [sessions, setSessions] = React.useState([]);

    React.useEffect(() => {
        const loadSessions = async () => {
            const loadedSessions = await CloudSessionStorage.getSessions();
            setSessions(loadedSessions);
        };
        loadSessions();
    }, []);

    const createSession = async (game, user) => {
        console.log('createSession appel√©e avec:', { game, user });

        if (!game || !game.id) {
            console.error('createSession: jeu invalide', game);
            return;
        }

        const newSession = {
            id: Date.now(),
            gameId: Number(game.id),
            gameTitle: game.title || 'Titre inconnu',
            gameDescription: game.description || 'Description inconnue',
            gameDuration: game.duration || 'Dur√©e inconnue',
            postChapo: window.pendingGameSession?.postChapo || null,
            user: user,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            status: 'active',
            notes: [],
            participants: [user],
            photoUrl: window.pendingGameSession?.photoUrl || null
        };

        console.log('Nouvelle session cr√©√©e:', newSession);

        try {
            await CloudSessionStorage.saveSession(newSession);
            const updatedSessions = await CloudSessionStorage.getSessions();
            setSessions(updatedSessions);
            setCurrentSession(newSession);
            
            if (window.pendingGameSession) {
                delete window.pendingGameSession;
            }
            return newSession;
        } catch (error) {
            console.error('Erreur cr√©ation session:', error);
            // Fallback : sauvegarder localement
            const localSessions = [newSession, ...sessions];
            setSessions(localSessions);
            setCurrentSession(newSession);
            if (window.pendingGameSession) {
                delete window.pendingGameSession;
            }
            return newSession;
        }
    };

    const updateSession = async (updatedSession) => {
        const sessionToSave = {
            ...updatedSession, 
            notes: updatedSession.notes || [],
            updatedAt: new Date().toISOString()
        };
        
        try {
            await CloudSessionStorage.saveSession(sessionToSave);
            const updatedSessions = await CloudSessionStorage.getSessions();
            setSessions(updatedSessions);
            setCurrentSession(sessionToSave);
        } catch (error) {
            console.error('Erreur mise √† jour session:', error);
            // Fallback local
            const updatedSessions = sessions.map(s => 
                s.id === sessionToSave.id ? sessionToSave : s
            );
            setSessions(updatedSessions);
            setCurrentSession(sessionToSave);
            throw error; // Re-lancer pour l'UI
        }
    };

    const deleteSession = async (sessionId) => {
        try {
            await CloudSessionStorage.deleteSession(sessionId);
            const updatedSessions = await CloudSessionStorage.getSessions();
            setSessions(updatedSessions);
            if (currentSession?.id === sessionId) {
                setCurrentSession(null);
            }
        } catch (error) {
            console.error('Erreur suppression session:', error);
            // Fallback local
            const updatedSessions = sessions.filter(s => s.id !== sessionId);
            setSessions(updatedSessions);
            if (currentSession?.id === sessionId) {
                setCurrentSession(null);
            }
            throw error;
        }
    };

    const getGameIcon = (gameId) => {
        const game = GAMES.find(g => g.id === gameId);
        return game?.icon || BookOpen;
    };

    const renderGameIcon = (gameId, className = "w-6 h-6") => {
        const IconComponent = getGameIcon(gameId);
        return React.createElement(IconComponent, { className });
    };

    return {
        currentSession, 
        setCurrentSession,
        sessions, 
        setSessions,
        createSession,
        updateSession,
        deleteSession,
        getGameIcon,
        renderGameIcon
    };
};

		// ===== GOOGLE AUTH HOOK (CORRIG√â) =====
        // ===== GOOGLE AUTH HOOK (AVEC AUTO-CONNEXION) =====
        const useGoogleAuth = () => {
            const [isConnected, setIsConnected] = React.useState(false);
            const [isLoading, setIsLoading] = React.useState(true);
            const [userInfo, setUserInfo] = React.useState(null);
            const [hasTriedAutoConnect, setHasTriedAutoConnect] = React.useState(false);
            
            React.useEffect(() => {
                const initAndAutoConnect = async () => {
                    setIsLoading(true);
                    
                    try {
                        console.log('üîÑ Initialisation Google Drive...');
                        await GoogleDriveAPI.init();
                        
                        // TENTATIVE D'AUTO-CONNEXION
                        const token = gapi.client.getToken();
                        if (token && !hasTriedAutoConnect) {
                            console.log('üîÑ Tentative d\'auto-connexion...');
                            setHasTriedAutoConnect(true);
                            
                            try {
                                // Test simple d'acc√®s
                                await Promise.race([
                                    gapi.client.drive.files.list({ pageSize: 1 }),
                                    new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout')), 10000))
                                ]);
                                
                                setIsConnected(true);
                                GoogleDriveAPI.isSignedIn = true;
                                console.log('‚úÖ Auto-connexion r√©ussie !');
                                
                                // R√©cup√©rer infos utilisateur en arri√®re-plan (pas critique)
                                try {
                                    const response = await fetch('https://www.googleapis.com/oauth2/v1/userinfo', { 
                                        headers: { 'Authorization': `Bearer ${token.access_token}` } 
                                    });
                                    if (response.ok) {
                                        const profile = await response.json();
                                        setUserInfo({ name: profile.name, email: profile.email });
                                    }
                                } catch (e) {
                                    console.log('‚ÑπÔ∏è Infos utilisateur non disponibles (pas critique)');
                                }
                                
                            } catch (error) { 
                                console.log('‚ö†Ô∏è Auto-connexion √©chou√©e, connexion manuelle requise');
                                gapi.client.setToken(''); 
                                setIsConnected(false);
                            }
                        } else if (!token) {
                            console.log('üì± Aucun token sauv√©, connexion manuelle requise');
                            setHasTriedAutoConnect(true);
                        }
                        
                    } catch (error) { 
                        console.error('‚ùå Erreur initialisation Google:', error); 
                        setHasTriedAutoConnect(true);
                    } finally { 
                        setIsLoading(false); 
                    }
                };
                
                if (!hasTriedAutoConnect) {
                    initAndAutoConnect();
                }
            }, [hasTriedAutoConnect]);
            
            const signIn = async () => {
                setIsLoading(true);
                
                try {
                    const success = await GoogleDriveAPI.signIn();
                    if (success) {
                        setIsConnected(true);
                        console.log('‚úÖ Connexion manuelle Google Drive r√©ussie');
                        
                        // R√©cup√©rer infos utilisateur
                        try {
                            const token = gapi.client.getToken();
                            const response = await fetch('https://www.googleapis.com/oauth2/v1/userinfo', { 
                                headers: { 'Authorization': `Bearer ${token.access_token}` } 
                            });
                            if (response.ok) {
                                const profile = await response.json();
                                setUserInfo({ name: profile.name, email: profile.email });
                            }
                        } catch (e) {
                            console.log('‚ÑπÔ∏è Infos utilisateur non r√©cup√©r√©es');
                        }
                        
                        return true;
                    }
                    return false;
                } catch (error) { 
                    setIsConnected(false); 
                    setUserInfo(null); 
                    console.error('‚ùå Erreur connexion:', error); 
                    return false; 
                } finally { 
                    setIsLoading(false); 
                }
            };
            
            const signOut = async () => {
                setIsLoading(true);
                try { 
                    await GoogleDriveAPI.signOut(); 
                    setIsConnected(false); 
                    setUserInfo(null); 
                    console.log('‚úÖ D√©connexion r√©ussie');
                } catch (error) { 
                    console.error('Erreur d√©connexion:', error); 
                } finally { 
                    setIsLoading(false); 
                }
            };
            
            return { isConnected, isLoading, userInfo, signIn, signOut };
        };

        // ===== UI COMPONENTS =====
        const TopBar = ({ currentPage, currentUser, onUserChange, onPageChange, googleStatus, onGoogleAction }) => {
            const PAGE_TITLES = { home: "M√©moire du M√©kong", sessions: "Vos Sessions", games: "Choisir un jeu", chat: "Conversation", memories: "M√©moires du Voyage", settings: "R√©glages", users: "Gestion des Utilisateurs" };
            
            const getConnectionButton = () => {
                const { isLoading, isConnected, userInfo } = googleStatus;
                
                if (isLoading) {
                    return {
                        className: 'bg-blue-100 text-blue-700 cursor-wait',
                        content: <div className="animate-spin w-4 h-4 border-2 border-blue-600 border-t-transparent rounded-full"></div>,
                        title: 'Connexion Google Drive...'
                    };
                }
                
                if (isConnected) {
                    return {
                        className: 'bg-green-100 text-green-700 hover:bg-green-200',
                        content: (
                            <>
                                <Cloud className="w-4 h-4" />
                                <span className="ml-1 hidden sm:inline">‚úì Drive</span>
                            </>
                        ),
                        title: `Connect√©: ${userInfo?.email}`
                    };
                }
                
                // PAS CONNECT√â = ALERTE ROUGE
                return {
                    className: 'bg-red-100 text-red-700 hover:bg-red-200 animate-pulse border-2 border-red-300',
                    content: (
                        <>
                            <Cloud className="w-4 h-4" />
                            <span className="ml-1 font-bold">Se connecter !</span>
                        </>
                    ),
                    title: 'CONNEXION GOOGLE DRIVE REQUISE - Cliquer pour se connecter'
                };
            };
            
            const connectionBtn = getConnectionButton();
            
            return ( 
                <header className="sticky top-0 z-10 p-3 bg-white/90 backdrop-blur-md border-b border-gray-200"> 
                    <div className="flex justify-between items-center h-10"> 
                        <h1 className="text-xl font-bold text-amber-900 truncate">
                            {PAGE_TITLES[currentPage] || "M√©moire du M√©kong"}
                        </h1> 
                        <div className="flex items-center space-x-2"> 
                            <button 
                                onClick={onGoogleAction} 
                                className={`flex items-center justify-center h-10 px-3 rounded-lg text-xs font-medium transition-colors ${connectionBtn.className}`}
                                title={connectionBtn.title}
                            > 
                                {connectionBtn.content}
                            </button> 
                            {currentUser && ( 
                                <button 
                                    onClick={() => onPageChange('users')} 
                                    className={`flex items-center justify-center w-10 h-10 rounded-full border ${getUserStyle(currentUser).bg} ${getUserStyle(currentUser).border}`} 
                                    title={`Connect√© en tant que ${USERS[currentUser]?.name}.`}
                                > 
                                    <span className="text-xl">{USERS[currentUser]?.emoji}</span> 
                                </button> 
                            )} 
                        </div> 
                    </div> 
                </header> 
            );
        };
        const BottomNavBar = ({ currentPage, onPageChange, currentUser }) => {
            const navItems = [ { id: 'home', icon: Home, label: 'Accueil' }, { id: 'sessions', icon: BookOpen, label: 'Sessions' }, { id: 'memories', icon: Camera, label: 'M√©moires' }, { id: 'settings', icon: Settings, label: 'R√©glages' }, ];
            return ( <div className="fixed bottom-0 left-0 right-0 h-16 bg-white/90 backdrop-blur-md border-t border-gray-200 shadow-t-lg z-10"> <div className="flex justify-around items-center h-full"> {navItems.map((item) => { const Icon = item.icon; const isActive = currentPage === item.id; const isDisabled = !currentUser && item.id !== 'home'; return ( <button key={item.id} onClick={() => onPageChange(item.id)} disabled={isDisabled} className={`flex flex-col items-center justify-center w-full h-full transition-colors duration-200 ${ isActive ? 'text-amber-600' : 'text-gray-500 hover:text-amber-500' } ${isDisabled ? 'opacity-40 cursor-not-allowed' : ''}`}> <Icon className="w-6 h-6 mb-1" /> <span className={`text-xs font-medium ${isActive ? 'font-bold' : ''}`}>{item.label}</span> </button> ); })} </div> </div> );
        };
        const GoogleConnection = ({ isConnected, isLoading, userInfo, onSignIn, onSignOut }) => {
            if (isLoading) { return ( <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4"> <div className="flex items-center space-x-3"> <div className="animate-spin w-5 h-5 border-2 border-blue-600 border-t-transparent rounded-full"></div> <span className="text-blue-700">Connexion Google Drive...</span> </div> </div> ); }
            if (!isConnected) { return ( <div className="bg-red-50 border border-red-200 rounded-lg p-4 mb-4"> <div className="flex items-center justify-between"> <div className="flex items-center space-x-3"> <div className="w-8 h-8 bg-red-100 rounded-full flex items-center justify-center"><Cloud className="w-4 h-4 text-red-600" /></div> <div> <div className="font-medium text-red-900">Connexion Google Drive requise</div> <div className="text-sm text-red-700">Vos sessions seront partag√©es</div> </div> </div> <button onClick={onSignIn} className="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-lg text-sm font-medium">Se connecter</button> </div> </div> ); }
            return ( <div className="bg-green-50 border border-green-200 rounded-lg p-3 mb-4"> <div className="flex items-center justify-between"> <div className="flex items-center space-x-3"> <div className="w-8 h-8 bg-green-100 rounded-full flex items-center justify-center"><Cloud className="w-4 h-4 text-green-600" /></div> <div> <div className="font-medium text-green-900">Connect√© √† Google Drive</div> <div className="text-xs text-green-700">{userInfo?.email}</div> </div> </div> <button onClick={onSignOut} className="px-3 py-1 bg-green-600 hover:bg-green-700 text-white rounded text-xs">D√©connecter</button> </div> </div> );
        };
        
        // ===== GAME DATA =====
        const GAMES = [ { id: 1, title: "Photo roulette", icon: Camera }, { id: 7, title: "Souvenir du jour", icon: BookOpen } /* ... autres jeux ... */ ];
        const getGameById = (gameId) => GAMES.find(g => g.id === gameId);

        // ===== PAGES =====
		// Home Page
        const HomePage = ({ currentUser, onUserChange, onPageChange, googleStatus }) => {
            const { isConnected, isLoading, userInfo } = googleStatus;
            const [localSessions, setLocalSessions] = React.useState([]);
            const [mastodonImported, setMastodonImported] = React.useState(false);

            React.useEffect(() => {
                // V√©rifier les donn√©es disponibles localement
                const sessions = Storage.get('sessions', []);
                setLocalSessions(sessions);
                setMastodonImported(MastodonData.isImported());
            }, []);

            const getConnectionStatusCard = () => {
                if (isLoading) {
                    return (
                        <div className="bg-blue-50 border-2 border-blue-200 rounded-xl p-6 text-center">
                            <div className="animate-spin w-8 h-8 border-2 border-blue-600 border-t-transparent rounded-full mx-auto mb-4"></div>
                            <h3 className="text-lg font-semibold text-blue-900 mb-2">Connexion √† Google Drive...</h3>
                            <p className="text-blue-700 text-sm">V√©rification de votre connexion</p>
                        </div>
                    );
                }

                if (isConnected) {
                    return (
                        <div className="bg-green-50 border-2 border-green-200 rounded-xl p-6 text-center">
                            <div className="w-12 h-12 bg-green-100 rounded-full flex items-center justify-center mx-auto mb-4">
                                <Cloud className="w-6 h-6 text-green-600" />
                            </div>
                            <h3 className="text-lg font-semibold text-green-900 mb-2">‚úÖ Connect√© √† Google Drive</h3>
                            <p className="text-green-700 text-sm mb-2">Synchronisation active ‚Ä¢ {userInfo?.email}</p>
                            <div className="bg-green-100 rounded-lg p-3 text-xs text-green-800">
                                <strong>Avantages :</strong> Partage Tom/Lambert ‚Ä¢ Photos du voyage ‚Ä¢ Sauvegarde automatique
                            </div>
                        </div>
                    );
                }

                return (
                    <div className="bg-orange-50 border-2 border-orange-300 rounded-xl p-6 text-center">
                        <div className="w-12 h-12 bg-orange-100 rounded-full flex items-center justify-center mx-auto mb-4">
                            <Cloud className="w-6 h-6 text-orange-600" />
                        </div>
                        <h3 className="text-lg font-semibold text-orange-900 mb-2">‚ö†Ô∏è Mode Hors Ligne</h3>
                        <p className="text-orange-700 text-sm mb-4">Fonctionnalit√©s limit√©es ‚Ä¢ Pas de synchronisation</p>
                        <button
                            onClick={() => onPageChange('settings')}
                            className="w-full px-4 py-3 bg-orange-600 hover:bg-orange-700 text-white rounded-lg font-semibold mb-3"
                        >
                            Se connecter maintenant
                        </button>
                        <div className="bg-orange-100 rounded-lg p-3 text-xs text-orange-800">
                            <strong>Connexion recommand√©e pour :</strong><br/>
                            ‚Ä¢ Partager avec Tom/Lambert ‚Ä¢ Acc√©der aux photos ‚Ä¢ Synchroniser vos sessions
                        </div>
                    </div>
                );
            };

            const getAvailableActions = () => {
                const actions = [];

                // Sessions - toujours disponibles mais avec diff√©rences
                actions.push({
                    id: 'sessions',
                    icon: BookOpen,
                    title: 'Sessions',
                    description: isConnected 
                        ? `${localSessions.length} session(s) ‚Ä¢ Partage & synchronisation`
                        : `${localSessions.length} session(s) locales ‚Ä¢ Pas de partage`,
                    bgColor: isConnected ? 'bg-blue-50 hover:bg-blue-100 border-blue-200' : 'bg-gray-50 hover:bg-gray-100 border-gray-200',
                    textColor: isConnected ? 'text-blue-900' : 'text-gray-700',
                    iconColor: isConnected ? 'text-blue-600' : 'text-gray-500',
                    available: true,
                    badge: localSessions.length > 0 ? `${localSessions.length}` : null
                });

                // M√©moires - d√©pend de l'√©tat
                actions.push({
                    id: 'memories',
                    icon: Camera,
                    title: 'M√©moires',
                    description: isConnected 
                        ? 'Blog + Photos du voyage ‚Ä¢ Acc√®s complet'
                        : mastodonImported 
                            ? 'Blog uniquement ‚Ä¢ Photos non disponibles'
                            : 'Import du blog requis',
                    bgColor: (isConnected || mastodonImported) ? 'bg-green-50 hover:bg-green-100 border-green-200' : 'bg-gray-50 hover:bg-gray-100 border-gray-200',
                    textColor: (isConnected || mastodonImported) ? 'text-green-900' : 'text-gray-700',
                    iconColor: (isConnected || mastodonImported) ? 'text-green-600' : 'text-gray-500',
                    available: isConnected || mastodonImported,
                    badge: !isConnected && mastodonImported ? '‚ö†Ô∏è' : null
                });

                return actions;
            };

            return (
                <div className="space-y-6 fade-in">
                    {/* Titre et utilisateur */}
                    <div className="text-center">
                        <h2 className="text-2xl font-bold text-amber-900 mb-4">
                            M√©moire du M√©kong
                        </h2>
                        {currentUser ? (
                            <p className="text-amber-700 mb-6">
                                Bonjour <strong>{USERS[currentUser]?.name}</strong> ! 
                            </p>
                        ) : (
                            <p className="text-amber-700 mb-6">
                                Bienvenue dans vos m√©moires du voyage !
                            </p>
                        )}
                    </div>

                    {/* S√©lection utilisateur si n√©cessaire */}
                    {!currentUser && (
                        <div className="max-w-md mx-auto space-y-4 mb-6">
                            <h3 className="text-lg font-semibold text-amber-900 text-center">Qui √™tes-vous ?</h3>
                            <div className="space-y-3">
                                {Object.entries(USERS).map(([key, user]) => (
                                    <button
                                        key={key}
                                        onClick={() => onUserChange(key)}
                                        className={`flex items-center space-x-3 p-4 border-2 rounded-lg w-full text-left transition-all ${getUserStyle(key).bg} hover:${getUserStyle(key).border}`}
                                    >
                                        <span className="text-3xl">{user.emoji}</span>
                                        <div>
                                            <div className={`font-medium text-lg ${getUserStyle(key).text}`}>{user.name}</div>
                                        </div>
                                    </button>
                                ))}
                            </div>
                        </div>
                    )}

                    {/* √âtat de connexion - toujours visible */}
                    {getConnectionStatusCard()}

                    {/* Actions disponibles */}
                    {currentUser && (
                        <div className="space-y-4">
                            <h3 className="text-lg font-semibold text-amber-900 text-center">Que voulez-vous faire ?</h3>
                            <div className="grid grid-cols-1 md:grid-cols-2 gap-4 max-w-2xl mx-auto">
                                {getAvailableActions().map(action => {
                                    const IconComponent = action.icon;
                                    return (
                                        <button
                                            key={action.id}
                                            onClick={() => action.available && onPageChange(action.id)}
                                            disabled={!action.available}
                                            className={`p-6 border-2 rounded-xl text-left transition-all relative ${action.bgColor} ${action.available ? 'cursor-pointer' : 'cursor-not-allowed opacity-60'}`}
                                        >
                                            <div className="flex items-start space-x-4">
                                                <div className={`p-2 rounded-lg bg-white/50`}>
                                                    <IconComponent className={`w-8 h-8 ${action.iconColor}`} />
                                                </div>
                                                <div className="flex-1">
                                                    <h4 className={`font-semibold text-lg mb-2 ${action.textColor}`}>
                                                        {action.title}
                                                        {action.badge && (
                                                            <span className="ml-2 px-2 py-1 text-xs bg-amber-200 text-amber-800 rounded-full">
                                                                {action.badge}
                                                            </span>
                                                        )}
                                                    </h4>
                                                    <p className={`text-sm ${action.textColor} opacity-80`}>
                                                        {action.description}
                                                    </p>
                                                </div>
                                            </div>
                                        </button>
                                    );
                                })}
                            </div>
                        </div>
                    )}

                    {/* Message √©ducatif selon l'√©tat */}
                    <div className="max-w-2xl mx-auto">
                        {isConnected ? (
                            <div className="bg-amber-50 border border-amber-200 rounded-lg p-4 text-center">
                                <p className="text-amber-800 text-sm">
                                    <strong>üí° Parfait !</strong> Vous pouvez maintenant partager vos m√©moires avec Tom/Lambert 
                                    et acc√©der √† toutes vos photos du voyage.
                                </p>
                            </div>
                        ) : (
                            <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 text-center">
                                <p className="text-blue-800 text-sm">
                                    <strong>‚ÑπÔ∏è Mode limit√© :</strong> Connectez-vous √† Google Drive pour synchroniser 
                                    vos sessions avec Tom/Lambert et acc√©der aux 2000+ photos du voyage !
                                </p>
                            </div>
                        )}
                    </div>
                </div>
            );
        };
		//User Page
        const UsersPage = ({ currentUser, onUserChange, onPageChange }) => {
            return ( <div className="space-y-6 fade-in"> <div className="text-center mb-6"> <h2 className="text-2xl font-bold text-amber-900 mb-2">Gestion des Utilisateurs</h2> <p className="text-amber-700">Actuellement connect√© en tant que <strong>{USERS[currentUser]?.name}</strong></p> </div> <div className="space-y-4"> <h3 className="text-lg font-semibold text-amber-900">Changer d'utilisateur :</h3> <div className="grid grid-cols-1 gap-4"> {Object.entries(USERS).map(([key, user]) => ( <button key={key} onClick={() => { onUserChange(key); onPageChange('home'); }} className={`flex items-center space-x-4 p-4 border-2 rounded-lg transition-all ${ key === currentUser ? `${getUserStyle(key).bg} ${getUserStyle(key).border} ring-2 ring-amber-300` : `${getUserStyle(key).bg} hover:${getUserStyle(key).border} border-gray-200 hover:border-amber-300`}`}> <span className="text-3xl">{user.emoji}</span> <div className="flex-1 text-left"> <div className={`font-semibold text-lg ${getUserStyle(key).text}`}>{user.name}{key === currentUser && (<span className="ml-2 text-sm bg-amber-200 text-amber-800 px-2 py-1 rounded-full">Actuel</span>)}</div> <div className="text-sm text-gray-600">{key === 'tom' && "Le jeune aventurier"}{key === 'lambert' && "Le sage guide"}{key === 'duo' && "Session p√®re-fils"}</div> </div> {key !== currentUser && (<div className="text-amber-600 font-medium">‚Üí Changer</div>)} </button> ))} </div> </div> <div className="bg-amber-50 border border-amber-200 rounded-lg p-4 mt-6"> <h4 className="font-semibold text-amber-900 mb-2">üí° √Ä propos des utilisateurs</h4> <div className="text-amber-700 text-sm space-y-1"> <div><strong>Tom :</strong> Voit ses propres messages √† droite, ceux de Lambert √† gauche</div> <div><strong>Lambert :</strong> Voit ses propres messages √† droite, ceux de Tom √† gauche</div> <div><strong>Duo :</strong> Mode session partag√©e, messages centr√©s</div> </div> </div> <div className="flex justify-center pt-4"> <button onClick={() => onPageChange('home')} className="px-6 py-3 bg-amber-500 hover:bg-amber-600 text-white rounded-lg font-medium">Retour √† l'accueil</button> </div> </div> );
        };
        const GamesPage = ({ currentUser, onPageChange, onGameSelect }) => {
            const fullGamesList = [ { id: 1, title: "Photo roulette", duration: "15 min", type: "pr√©sentiel", icon: Camera, description: "S√©lectionnez une photo au hasard et racontez tout ce qui vous revient en m√©moire" }, { id: 7, title: "Souvenir du jour", duration: "libre", type: "m√©moire", icon: BookOpen, description: "Discussion autour d'un post sp√©cifique du blog Mastodon" } ];
            return ( <div className="space-y-6 fade-in"> <div className="flex justify-between items-center"> <h2 className="text-2xl font-bold text-amber-900">Catalogue de jeux</h2> <button onClick={() => { const randomGame = fullGamesList[Math.floor(Math.random() * fullGamesList.length)]; onGameSelect(randomGame); }} className="flex items-center space-x-2 px-4 py-2 bg-purple-500 hover:bg-purple-600 text-white rounded-lg"><Shuffle className="w-4 h-4" /><span>Jeu au hasard</span></button> </div> <div className="grid grid-cols-1 md:grid-cols-2 gap-6"> {fullGamesList.map(game => { const IconComponent = game.icon; return ( <button key={game.id} onClick={() => onGameSelect(game)} className="p-6 border-2 border-gray-200 rounded-lg hover:border-amber-300 hover:bg-amber-50 transition-all text-left group"> <div className="flex items-start space-x-4"> <IconComponent className="w-8 h-8 text-amber-600 mt-1 flex-shrink-0" /> <div className="flex-1"> <div className="flex justify-between items-start mb-2"> <h3 className="font-semibold text-lg text-amber-900 group-hover:text-amber-800">{game.title}</h3> {game.duration && <span className="text-xs bg-gray-100 px-2 py-1 rounded text-gray-600">{game.duration}</span>} </div> <p className="text-gray-600 text-sm leading-relaxed mb-2">{game.description}</p> </div> </div> </button> ); })} </div> </div> );
        };
//Page SESSIONS
        const SessionsPage = ({ currentUser, onPageChange, onSessionSelect, sessions, deleteSession }) => {
    const formatDate = (dateString) => new Date(dateString).toLocaleDateString('fr-FR', { day: 'numeric', month: 'short', hour: '2-digit', minute: '2-digit' });
    const statusIcons = { active: { icon: Play, color: 'text-green-500', title: 'Active' }, paused: { icon: Pause, color: 'text-orange-500', title: 'En pause' }, completed: { icon: FileText, color: 'text-gray-500', title: 'Termin√©e' } };

    return (
        <div className="space-y-4 fade-in">
            <button onClick={() => onPageChange('games')} className="w-full flex items-center justify-center space-x-2 px-4 py-3 bg-amber-500 hover:bg-amber-600 text-white rounded-lg font-semibold shadow">
                <Plus className="w-5 h-5" />
                <span>Nouveau Jeu de M√©moire</span>
            </button>

            {!sessions || sessions.length === 0 ? (
                <div className="text-center py-12 bg-gray-50 rounded-lg">
                    <FileText className="w-16 h-16 text-gray-300 mx-auto mb-4" />
                    <h3 className="text-lg font-medium text-gray-600 mb-2">Aucune session</h3>
                    <p className="text-gray-500 mb-6">Cr√©ez votre premi√®re session de m√©moire</p>
                    <button onClick={() => onPageChange('games')} className="px-6 py-3 bg-amber-500 hover:bg-amber-600 text-white rounded-lg font-medium">Commencer un jeu</button>
                </div>
            ) : (
                <div className="space-y-3">
                    {sessions.map((session) => {
                        const StatusIcon = statusIcons[session.status]?.icon || FileText;
                        const lastUser = session.lastModifiedBy || session.user; // On utilise le dernier modificateur, ou le cr√©ateur par d√©faut
                        const userStyle = getUserStyle(lastUser);

                        return (
                            <div key={session.id} onClick={() => onSessionSelect(session)} className="bg-white p-3 rounded-lg border border-gray-200 hover:border-amber-400 transition-colors cursor-pointer flex items-center space-x-3">
                                <div className={`w-12 h-12 rounded-full border-2 ${userStyle.bg} ${userStyle.border} flex items-center justify-center flex-shrink-0 shadow-sm`} title={`Derni√®re modification par ${USERS[lastUser]?.name}`}>
                                    <span className="text-xl">{USERS[lastUser]?.emoji || 'üêò'}</span>
                                </div>
                                <div className="flex-1 min-w-0">
                                    <div className="flex justify-between items-start">
                                        <h3 className="font-bold text-gray-800 pr-2 truncate">{session.gameTitle}</h3>
                                        <span className="text-xs text-gray-400 whitespace-nowrap">{(session.notes || []).length} notes</span>
                                    </div>
                                    <div className="flex items-center justify-between mt-1">
                                        <span className="text-xs text-gray-500">{formatDate(session.updatedAt)}</span>
                                        <div className="flex items-center space-x-2">
                                            <StatusIcon className={`w-5 h-5 ${statusIcons[session.status]?.color || 'text-gray-500'}`} title={statusIcons[session.status]?.title || 'Archiv√©e'} />
                                            <button onClick={(e) => { e.stopPropagation(); if (confirm(`Supprimer la session "${session.gameTitle}" ?`)) { deleteSession(session.id); } }} className="p-1 text-gray-400 hover:text-red-600 hover:bg-red-50 rounded-full">
                                                <Trash2 className="w-4 h-4" />
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        );
                    })}
                </div>
            )}
        </div>
    );
};
//Page CHAT
        const ChatPage = ({ currentUser, currentSession, onUpdateSession, onBackToSessions }) => {
    const [newMessageContent, setNewMessageContent] = React.useState('');
    const [editingMessage, setEditingMessage] = React.useState(null); // { id, content }
    const [editingTitle, setEditingTitle] = React.useState(false);
    const [titleContent, setTitleContent] = React.useState('');
    const messagesEndRef = React.useRef(null);

    React.useEffect(() => { if (messagesEndRef.current) { messagesEndRef.current.scrollIntoView({ behavior: "smooth" }); } }, [currentSession?.notes]);

    if (!currentSession) { return <div className="text-center py-12">S√©lectionnez une session pour commencer.</div>; }

    const handleUpdate = (updatedSession) => { onUpdateSession(updatedSession); };

    const sendMessage = () => {
        if (!newMessageContent.trim()) return;
        const updatedSession = { ...currentSession, notes: [...(currentSession.notes || []), { id: Date.now(), content: newMessageContent.trim(), author: currentUser, timestamp: new Date().toISOString() }], lastModifiedBy: currentUser };
        handleUpdate(updatedSession);
        setNewMessageContent('');
    };

    const startEditMessage = (message) => setEditingMessage({ id: message.id, content: message.content });
    const cancelEditMessage = () => setEditingMessage(null);
    const saveEditMessage = () => {
        if (!editingMessage || !editingMessage.content.trim()) return;
        const updatedNotes = (currentSession.notes || []).map(note => note.id === editingMessage.id ? { ...note, content: editingMessage.content.trim(), edited: true } : note);
        handleUpdate({ ...currentSession, notes: updatedNotes, lastModifiedBy: currentUser });
        setEditingMessage(null);
    };
    const deleteMessage = (messageId) => {
        if (confirm('Supprimer ce message ?')) {
            const updatedNotes = (currentSession.notes || []).filter(note => note.id !== messageId);
            handleUpdate({ ...currentSession, notes: updatedNotes, lastModifiedBy: currentUser });
        }
    };

    const startEditTitle = () => { setTitleContent(currentSession.gameTitle); setEditingTitle(true); };
    const saveTitle = () => {
        if (!titleContent.trim()) { setEditingTitle(false); return; }
        const updatedSession = { ...currentSession, gameTitle: titleContent.trim() };
        handleUpdate(updatedSession);
        setEditingTitle(false);
    };

    const getBubbleStyle = (author) => {
        const user = USERS[author];
        if (!user) return 'bg-gray-200 text-gray-800';
        const colorMap = { blue: 'bg-blue-500 text-white', green: 'bg-green-500 text-white', amber: 'bg-amber-500 text-white' };
        return colorMap[user.color];
    };

    return (
        <div className="flex flex-col h-screen max-h-[85vh] fade-in">
            <div className="bg-amber-50 border-b p-3 flex-shrink-0 flex justify-between items-center">
                {editingTitle ? (
                    <div className="flex-1 flex items-center gap-2">
                        <input type="text" value={titleContent} onChange={e => setTitleContent(e.target.value)} className="font-bold text-amber-900 text-lg bg-white border border-amber-300 rounded px-2 py-1 flex-1" autoFocus onBlur={saveTitle} onKeyDown={e => e.key === 'Enter' && saveTitle()} />
                    </div>
                ) : (
                    <div className="flex items-center gap-2 group cursor-pointer" onClick={startEditTitle}>
                        <h3 className="font-bold text-amber-900 text-lg">{currentSession.gameTitle}</h3>
                        <Edit className="w-4 h-4 text-amber-400 opacity-0 group-hover:opacity-100 transition-opacity" />
                    </div>
                )}
            </div>
            <div className="flex-1 bg-gray-50 overflow-y-auto p-4 space-y-4">
                {currentSession.photoUrl && ( <div className="p-2 border-b border-gray-200 mb-4"><img src={currentSession.photoUrl} alt="Contexte" className="max-w-xs mx-auto rounded-lg shadow-md" /></div> )}
                {(currentSession.notes || []).map(note => {
                    const isOwn = note.author === currentUser;
                    const isDuo = note.author === 'duo';
                    const userStyle = getUserStyle(note.author);
                    const isEditing = editingMessage?.id === note.id;
                    let justifyContent = isDuo ? 'justify-center' : isOwn ? 'justify-end' : 'justify-start';
                    return (
                        <div key={note.id} className={`flex items-end gap-2 ${justifyContent}`}>
                            {!isDuo && !isOwn && (<div className={`w-8 h-8 rounded-full flex items-center justify-center ${userStyle.bg} flex-shrink-0`}><span className="text-lg">{USERS[note.author]?.emoji}</span></div>)}
                            <div className={`max-w-[70%] relative group ${isDuo ? '' : 'p-3 rounded-2xl'} ${isDuo ? 'bg-amber-100 text-amber-800 p-3 rounded-lg' : getBubbleStyle(note.author)}`}>
                                {isEditing ? (
                                    <div className="w-full">
                                        <textarea value={editingMessage.content} onChange={e => setEditingMessage({...editingMessage, content: e.target.value})} className="w-full bg-white text-gray-800 rounded p-2 text-sm resize-none" rows="3" autoFocus></textarea>
                                        <div className="flex justify-end gap-2 mt-1">
                                            <button onClick={cancelEditMessage} className="px-2 py-1 text-xs bg-gray-200 rounded">Annuler</button>
                                            <button onClick={saveEditMessage} className="px-2 py-1 text-xs bg-green-500 text-white rounded">Sauver</button>
                                        </div>
                                    </div>
                                ) : (
                                    <>
                                        <p className="text-sm whitespace-pre-wrap">{note.content}</p>
                                        {note.edited && <span className="text-xs opacity-70 italic pl-2">(modifi√©)</span>}
                                    </>
                                )}
                                {isOwn && !isEditing && !isDuo && (
                                    <div className="absolute top-0 right-0 opacity-0 group-hover:opacity-100 transition-opacity flex bg-black/20 rounded-full p-1 -mt-2 -mr-2">
                                        <button onClick={() => startEditMessage(note)} className="p-1 hover:text-white"><Edit className="w-3 h-3"/></button>
                                        <button onClick={() => deleteMessage(note.id)} className="p-1 hover:text-white"><Trash2 className="w-3 h-3"/></button>
                                    </div>
                                )}
                            </div>
                            {!isDuo && isOwn && (<div className={`w-8 h-8 rounded-full flex items-center justify-center ${userStyle.bg} flex-shrink-0`}><span className="text-lg">{USERS[note.author]?.emoji}</span></div>)}
                        </div>
                    );
                })}
                <div ref={messagesEndRef} />
            </div>
            <div className="mt-auto p-2 border-t bg-white flex items-center">
                <input type="text" value={newMessageContent} onChange={e => setNewMessageContent(e.target.value)} onKeyDown={e => e.key === 'Enter' && sendMessage()} placeholder="Votre souvenir..." className="flex-1 px-4 py-2 border rounded-full focus:outline-none focus:ring-2 focus:ring-amber-400" />
                <button onClick={sendMessage} className="ml-3 p-3 bg-amber-500 text-white rounded-full hover:bg-amber-600 disabled:bg-gray-300" disabled={!newMessageContent.trim()}><Send className="w-5 h-5"/></button>
            </div>
        </div>
    );
};
		//Page CONFIG
        const SettingsPage = ({ onReset, googleAuth, onGoogleDisconnect }) => {
            const { isConnected, isLoading, userInfo, signIn, signOut } = googleAuth;
            const [photoPath, setPhotoPath] = React.useState(Storage.get('photoFolderPath', '/Medias/Photos/'));
            const [mastodonPath, setMastodonPath] = React.useState(Storage.get('mastodonMediaPath', '/Medias/Mastodon/'));
            const [importStatus, setImportStatus] = React.useState('');
            const [isImporting, setIsImporting] = React.useState(false);
            const fileInputRef = React.useRef(null);
            const stats = MastodonData.getStats();
            const isImported = MastodonData.isImported();
            const handleFileImport = async (event) => {
                const file = event.target.files[0]; if (!file) return;
                setIsImporting(true); setImportStatus('Lecture du fichier...');
                try {
                    const text = await file.text(); setImportStatus('Analyse des donn√©es...');
                    const posts = MastodonData.parseOutbox(text); MastodonData.savePosts(posts);
                    setImportStatus(`Succ√®s ! ${posts.length} posts import√©s.`);
                    setTimeout(() => setImportStatus(''), 3000);
                } catch (error) { console.error('Erreur import:', error); setImportStatus(`Erreur: ${error.message}`);
                } finally { setIsImporting(false); if (fileInputRef.current) fileInputRef.current.value = ''; }
            };
            const clearMastodonData = () => { if (confirm('Supprimer toutes les donn√©es du blog Mastodon import√©es ?')) { Storage.remove('mastodon_posts'); Storage.remove('mastodon_imported_at'); window.location.reload(); }};
            const savePaths = () => { Storage.set('photoFolderPath', photoPath); Storage.set('mastodonMediaPath', mastodonPath); GoogleDriveAPI._folderIdCache.clear(); GoogleDriveAPI._fileIdCache.clear(); alert('Chemins de dossiers sauvegard√©s !'); };
            return (
                <div className="space-y-6 fade-in">
                    <GoogleConnection isConnected={isConnected} isLoading={isLoading} userInfo={userInfo} onSignIn={signIn} onSignOut={onGoogleDisconnect || signOut} />
                    <div className="bg-white p-6 rounded-lg shadow-md space-y-4">
                        <h3 className="text-lg font-semibold text-gray-900">Configuration Google Drive</h3>
                        <div>
                            <label htmlFor="photoPath" className="block text-sm font-medium text-gray-700 mb-1">Chemin du dossier Photos de voyage</label>
                            <input type="text" id="photoPath" value={photoPath} onChange={e => setPhotoPath(e.target.value)} className="w-full px-3 py-2 border border-gray-300 rounded-lg" placeholder="/Medias/Photos/"/>
                        </div>
                        <div>
                            <label htmlFor="mastodonPath" className="block text-sm font-medium text-gray-700 mb-1">Chemin du dossier racine des M√©dias Mastodon</label>
                            <input type="text" id="mastodonPath" value={mastodonPath} onChange={e => setMastodonPath(e.target.value)} className="w-full px-3 py-2 border border-gray-300 rounded-lg" placeholder="/Medias/Mastodon/"/>
                             <p className="text-xs text-gray-500 mt-2">Doit pointer vers le dossier qui contient `media_attachments`.</p>
                        </div>
                        <div className="text-right"> <button onClick={savePaths} className="px-4 py-2 bg-amber-500 hover:bg-amber-600 text-white rounded-lg">Sauvegarder les chemins</button> </div>
                    </div>
                    <div className="bg-white p-6 rounded-lg shadow-md space-y-4">
                        <h3 className="text-lg font-semibold text-gray-900">Blog Mastodon</h3>
                        {isImported ? (
                            <div className="bg-green-50 border border-green-200 p-4 rounded-lg">
                                <div className="flex items-center justify-between">
                                    <div>
                                        <div className="font-medium text-green-900">Blog import√©</div>
                                        <div className="text-sm text-green-700">{stats.totalPosts} posts ‚Ä¢ Jours {stats.dayRange?.min}-{stats.dayRange?.max}</div>
                                    </div>
                                    <button onClick={clearMastodonData} className="px-3 py-1 bg-red-100 hover:bg-red-200 text-red-700 rounded text-sm">Supprimer</button>
                                </div>
                            </div>
                        ) : (
                            <div className="space-y-4">
                                <p className="text-gray-600">Importez votre fichier outbox.json.</p>
                                <div className="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center">
                                    <input ref={fileInputRef} type="file" accept=".json" onChange={handleFileImport} className="hidden" id="mastodon-file" disabled={isImporting} />
                                    <label htmlFor="mastodon-file" className={`cursor-pointer flex flex-col items-center ${isImporting ? 'opacity-50 cursor-not-allowed' : ''}`}>
                                        <svg className="w-12 h-12 text-gray-400 mb-3" viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7,10 12,5 17,10"/><line x1="12" x2="12" y1="5" y2="15"/></svg>
                                        <div className="text-lg font-medium text-gray-700">{isImporting ? 'Import en cours...' : 'S√©lectionner outbox.json'}</div>
                                    </label>
                                </div>
                                {importStatus && (<div className={`p-3 rounded-lg text-sm ${importStatus.includes('Erreur') ? 'bg-red-100 text-red-700' : 'bg-green-100 text-green-700'}`}>{importStatus}</div>)}
                            </div>
                        )}
                    </div>
                </div>
            );
        };
//Page Memoires
const MemoriesPage = ({ currentUser, onCreateSession }) => {
    const [activeView, setActiveView] = React.useState('blog');
    const [dayNumber, setDayNumber] = React.useState(1);
    const [currentPost, setCurrentPost] = React.useState(null);
    const [photos, setPhotos] = React.useState([]);
    const [currentDayTitle, setCurrentDayTitle] = React.useState('');
    const [isLoading, setIsLoading] = React.useState(false);
    const [error, setError] = React.useState('');
    const [isModalOpen, setIsModalOpen] = React.useState(false);
    const [selectedPhoto, setSelectedPhoto] = React.useState(null);
    const [modalImageSrc, setModalImageSrc] = React.useState('');
    const [isModalLoading, setIsModalLoading] = React.useState(false);
    const [retryCount, setRetryCount] = React.useState(0);
    
    const { isConnected } = useGoogleAuth();
    const isMastodonImported = MastodonData.isImported();
    const stats = MastodonData.getStats();
    const maxDay = stats?.dayRange?.max || 275;

    React.useEffect(() => {
        const loadDataForDay = async () => {
            setIsLoading(true); 
            setError(''); 
            setCurrentDayTitle('');
            
            try {
                if (activeView === 'blog' && isMastodonImported) {
                    const post = MastodonData.getPostByDay(dayNumber);
                    setCurrentPost(post); 
                    setPhotos([]);
                    if (!post) {
                        setError('Aucun post pour ce jour.');
                    }
                } else if (activeView === 'photos' && isConnected) {
                    const result = await GoogleDriveAPI.getPhotosByDay(dayNumber);
                    setPhotos(result.photos || []); 
                    setCurrentPost(null); 
                    setCurrentDayTitle(result.folderName || '');
                    
                    if (result.error) {
                        setError(`Erreur Google Drive: ${result.error}`);
                    } else if (result.photos.length === 0) {
                        setError('Aucune photo trouv√©e pour ce jour.');
                    }
                } else if (activeView === 'photos' && !isConnected) {
                    setError('Connexion Google Drive requise pour voir les photos.');
                }
            } catch (err) { 
                console.error('Erreur loadDataForDay:', err);
                setError(`Erreur de chargement: ${err.message}`); 
            } finally { 
                setIsLoading(false); 
            }
        };
        loadDataForDay();
    }, [dayNumber, activeView, isConnected, isMastodonImported]);

    const showRandomMemory = async () => {
        const randomDay = Math.floor(Math.random() * maxDay) + 1;
        const availableViews = [];
        if (isMastodonImported) availableViews.push('blog');
        if (isConnected) availableViews.push('photos');
        if (availableViews.length === 0) {
            setError('Aucune source de m√©moires disponible');
            return;
        }
        const randomView = availableViews[Math.floor(Math.random() * availableViews.length)];
        setActiveView(randomView);
        setDayNumber(randomDay);
    };

    const retryLoadPhotos = () => {
        setRetryCount(prev => prev + 1);
        setError('');
        // Le useEffect se red√©clenche automatiquement
    };

    const openPhotoModal = async (photo) => {
        setSelectedPhoto(photo); 
        setIsModalOpen(true); 
        setIsModalLoading(true); 
        setModalImageSrc('');
        
        try {
            const base64Src = await GoogleDriveAPI.getPhotoAsBase64(photo.id, photo.mimeType);
            if (base64Src) { 
                setModalImageSrc(base64Src); 
            } else {
                setError('Impossible de charger l\'image en haute r√©solution');
            }
        } catch (error) {
            console.error('Erreur chargement image modal:', error);
            setError('Erreur de chargement de l\'image');
        } finally {
            setIsModalLoading(false);
        }
    };
    
    const closePhotoModal = () => { 
        setIsModalOpen(false); 
        setSelectedPhoto(null); 
        setModalImageSrc(''); 
    };

    const createSessionFromModal = () => {
        if (!selectedPhoto) return;
        const game = getGameById(1);
        window.pendingGameSession = {
            game: { ...game, title: `Photo du Jour ${dayNumber}` },
            user: currentUser, 
            postChapo: currentDayTitle || `Photo du Jour ${dayNumber}`,
            photoUrl: selectedPhoto.thumbnailUrl
        };
        onCreateSession('chat');
        closePhotoModal();
    };
            
    const createSessionFromPost = (post) => {
        const game = getGameById(7);
        window.pendingGameSession = { 
            game: { ...game, title: `${post.title}` }, 
            user: currentUser, 
            postChapo: `${post.title}\n\n${post.content.slice(0, 200)}...` 
        };
        onCreateSession('chat');
    };

    const MastodonPostImages = ({ attachments }) => {
        const [imageUrls, setImageUrls] = React.useState([]);
        const [imageError, setImageError] = React.useState('');
        const mastodonMediaPath = Storage.get('mastodonMediaPath', '/Medias/Mastodon/');
        
        React.useEffect(() => {
            const fetchImageUrls = async () => {
                if (!attachments || attachments.length === 0 || !isConnected) return;
                
                setImageError('');
                const urls = [];
                
                try {
                    for (const attachment of attachments) {
                        if (attachment.type === 'Image' && attachment.url) {
                            const filename = attachment.url.split('/').pop();
                            const pathOnly = attachment.url.substring(0, attachment.url.lastIndexOf('/'));
                            const fullPath = mastodonMediaPath + 'media_attachments/files/' + pathOnly;
                            
                            try {
                                const file = await GoogleDriveAPI.findFileByPartialPath(filename, fullPath);
                                if (file?.webContentLink) { 
                                    urls.push(file.webContentLink); 
                                }
                            } catch (err) {
                                console.warn(`Image Mastodon non trouv√©e: ${filename}`);
                            }
                        }
                    }
                    setImageUrls(urls);
                } catch (error) {
                    console.error('Erreur chargement images Mastodon:', error);
                    setImageError('Erreur de chargement des images');
                }
            };
            fetchImageUrls();
        }, [attachments, isConnected]);
        
        if (imageError) {
            return <div className="mt-4 p-3 bg-red-50 text-red-700 rounded-lg text-sm">{imageError}</div>;
        }
        
        if (imageUrls.length === 0) return null;
        
        return ( 
            <div className="mt-4 grid grid-cols-2 gap-2"> 
                {imageUrls.map((url, index) => (
                    <a key={index} href={url} target="_blank" rel="noopener noreferrer">
                        <img src={url} alt={`Pi√®ce jointe ${index + 1}`} className="rounded-lg border hover:opacity-80" />
                    </a>
                ))} 
            </div> 
        );
    };

    return (
        <div className="space-y-6 fade-in">
            <div className="flex justify-center bg-gray-100 p-1 rounded-lg">
                <button 
                    onClick={() => setActiveView('blog')} 
                    disabled={!isMastodonImported} 
                    className={`w-full py-2 px-4 rounded-md font-semibold transition-colors ${
                        activeView === 'blog' ? 'bg-white text-amber-600 shadow' : 'text-gray-600'
                    } disabled:opacity-50 disabled:cursor-not-allowed`}
                >
                    Blog
                </button>
                <button 
                    onClick={() => setActiveView('photos')} 
                    disabled={!isConnected} 
                    className={`w-full py-2 px-4 rounded-md font-semibold transition-colors ${
                        activeView === 'photos' ? 'bg-white text-amber-600 shadow' : 'text-gray-600'
                    } disabled:opacity-50 disabled:cursor-not-allowed`}
                >
                    Photos {photos.length > 0 && `(${photos.length})`}
                </button>
            </div>
            
            <div className="bg-white p-4 rounded-lg border border-gray-200 space-y-4">
                <div className="flex items-center space-x-4">
                    <label className="font-medium text-gray-700">Jour</label>
                    <input 
                        type="range" 
                        min="1" 
                        max={maxDay} 
                        value={dayNumber} 
                        onChange={(e) => setDayNumber(parseInt(e.target.value))} 
                        className="flex-1"
                    />
                    <span className="font-bold text-lg text-amber-800 w-12 text-center">{dayNumber}</span>
                </div>
                <div className="text-center">
                    <button 
                        onClick={showRandomMemory} 
                        className="px-6 py-2 bg-orange-500 hover:bg-orange-600 text-white rounded-full font-semibold flex items-center justify-center space-x-2 mx-auto"
                    >
                        <Shuffle className="w-5 h-5"/>
                        <span>Souvenir au hasard</span>
                    </button>
                </div>
            </div>
            
            {isLoading && <div className="text-center py-12">Chargement...</div>}
            
            {error && !isLoading && (
                <div className="text-center py-12 text-gray-500">
                    <p className="mb-4">{error}</p>
                    {error.includes('Google Drive') && (
                        <button 
                            onClick={retryLoadPhotos}
                            className="px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg"
                        >
                            R√©essayer
                        </button>
                    )}
                </div>
            )}
            
            {!isLoading && !error && activeView === 'blog' && currentPost && (
                <div className="bg-white p-6 rounded-lg border border-gray-200">
                    <div className="flex justify-between items-start mb-4">
                        <h3 className="text-2xl font-bold text-amber-900">{currentPost.title}</h3>
                        <button 
                            onClick={() => createSessionFromPost(currentPost)} 
                            className="flex items-center space-x-2 px-3 py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg text-sm font-semibold"
                        >
                            <Plus className="w-4 h-4" /> 
                            <span>Session</span>
                        </button>
                    </div>
                    <p className="text-gray-800 leading-relaxed whitespace-pre-line">{currentPost.content}</p>
                    <MastodonPostImages attachments={currentPost.attachments} />
                </div>
            )}
            
            {!isLoading && !error && activeView === 'photos' && photos.length > 0 && (
                <div>
                    {currentDayTitle && (
                        <div className="bg-amber-50 p-3 rounded-lg mb-4 text-center">
                            <h3 className="font-semibold text-amber-900">{currentDayTitle}</h3>
                            <p className="text-sm text-amber-700">{photos.length} photo(s)</p>
                        </div>
                    )}
                    <div className="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4">
                        {photos.map(photo => (
                            <div 
                                key={photo.id} 
                                className="group relative border rounded-lg overflow-hidden cursor-pointer" 
                                onClick={() => openPhotoModal(photo)}
                            >
                                <img 
                                    src={photo.thumbnailUrl} 
                                    alt={photo.title} 
                                    className="w-full h-full object-cover aspect-square"
                                    onError={(e) => {
                                        e.target.style.display = 'none';
                                        e.target.nextSibling.style.display = 'flex';
                                    }}
                                />
                                <div className="hidden w-full aspect-square bg-gray-200 items-center justify-center text-gray-500 text-xs">
                                    Image indisponible
                                </div>
                                <div className="absolute inset-0 bg-black/60 opacity-0 group-hover:opacity-100 transition-opacity flex items-center justify-center p-2">
                                    <p className="text-white text-xs text-center">{photo.title}</p>
                                </div>
                            </div>
                        ))}
                    </div>
                </div>
            )}

            {isModalOpen && selectedPhoto && (
                <div 
                    className="fixed inset-0 bg-black/90 z-50 flex flex-col" 
                    onClick={(e) => {
                        // Fermeture uniquement si on clique sur l'arri√®re-plan noir
                        if (e.target === e.currentTarget) {
                            closePhotoModal();
                        }
                    }}
                >
                    {/* Zone image - occupe tout l'espace */}
                    <div 
                        className="flex-1 flex items-center justify-center p-4" 
                        onClick={e => e.stopPropagation()}
                    >
                        {isModalLoading && (
                            <div className="text-white text-lg">
                                <div className="animate-spin w-8 h-8 border-2 border-white border-t-transparent rounded-full mx-auto mb-2"></div>
                                Chargement...
                            </div>
                        )}
                        {!isModalLoading && !modalImageSrc && (
                            <div className="text-white text-center">
                                <div className="text-6xl mb-4">‚ö†Ô∏è</div>
                                <div>Erreur de chargement</div>
                            </div>
                        )}
                        {!isModalLoading && modalImageSrc && (
                            <img 
                                src={modalImageSrc} 
                                alt={selectedPhoto.title} 
                                className="object-contain max-w-full max-h-full rounded-lg shadow-2xl"
                            />
                        )}
                    </div>
                    
                    {/* Barre d'outils en bas - plus accessible sur mobile */}
                    <div 
                        className="flex-shrink-0 bg-black/60 backdrop-blur-sm p-4"
                        onClick={e => e.stopPropagation()}
                    >
                        <div className="flex justify-between items-center max-w-md mx-auto">
                            {/* Info photo - afficher le nom du jour au lieu du nom de fichier */}
                            <div className="text-white text-sm flex-1 pr-4">
                                <div className="font-medium">Jour {dayNumber}</div>
                                <div className="text-gray-300">{currentDayTitle || `Photos du voyage`}</div>
                            </div>
                            
                            {/* Boutons d'action */}
                            <div className="flex space-x-3">
                                <button 
                                    onClick={createSessionFromModal} 
                                    className="flex items-center space-x-2 px-4 py-2 bg-green-600 hover:bg-green-700 text-white rounded-full font-medium transition-colors"
                                >
                                    <Plus className="w-5 h-5"/>
                                    <span>Session</span>
                                </button>
                                
                                <button 
                                    onClick={closePhotoModal} 
                                    className="flex items-center space-x-2 px-4 py-2 bg-gray-600 hover:bg-gray-700 text-white rounded-full font-medium transition-colors"
                                >
                                    <X className="w-5 h-5"/>
                                    <span>Fermer</span>
                                </button>
                            </div>
                        </div>
                        
                        {/* Astuce pour fermer */}
                        <div className="text-center mt-2">
                            <div className="text-gray-400 text-xs">
                                Ou touchez l'arri√®re-plan pour fermer
                            </div>
                        </div>
                    </div>
                </div>
            )}
        </div>
    );
};
// ===== MAIN APP =====
const MemoireMekong = () => {
    const { currentPage, setCurrentPage, currentUser, setCurrentUser, resetApp } = useAppState();
    const googleAuth = useGoogleAuth();
    const { isConnected, isLoading, userInfo, signIn, signOut } = googleAuth;
    const sessionHook = useSessionState();
    const [currentChatSession, setCurrentChatSession] = React.useState(null);
    const [toast, setToast] = React.useState({ message: '', type: '' });

    // Synchronisation simplifi√©e √† la connexion Google
    React.useEffect(() => {
        if (isConnected && !isLoading) {
            console.log('üîÑ Synchronisation sessions √† la connexion...');
            CloudSessionStorage.getSessions().then(sessions => {
                sessionHook.setSessions(sessions);
                console.log(`‚úÖ ${sessions.length} sessions synchronis√©es`);
            }).catch(error => {
                console.warn('‚ö†Ô∏è Erreur sync sessions:', error.message);
                setToast({ message: "Erreur de synchronisation", type: 'error' });
            });
        }
    }, [isConnected]);

    const handleSessionSelect = (session) => { 
        setCurrentChatSession(session); 
        setCurrentPage('chat'); 
    };
    
    const handleUpdateSession = async (updatedSession) => {
        try {
            await sessionHook.updateSession(updatedSession);
            setCurrentChatSession(updatedSession);
        } catch (error) {
            setToast({ message: error.message, type: 'error' });
            setCurrentChatSession(updatedSession); // Au moins mettre √† jour localement
        }
    };

    const handleCreateSessionAndNavigate = (page, options = {}) => {
        if (options.game) {
            window.pendingGameSession = { ...(window.pendingGameSession || {}), game: options.game, user: currentUser };
        }
        if (window.pendingGameSession) {
            sessionHook.createSession(window.pendingGameSession.game, currentUser).then(newSession => {
                if(newSession) { 
                    setCurrentChatSession(newSession);
                    setCurrentPage(page);
                }
            });
        } else {
            setCurrentPage(page);
        }
    };

    return (
        <div className="min-h-screen bg-gradient-to-br from-amber-50 to-orange-100">
            <TopBar 
                currentPage={currentPage} 
                currentUser={currentUser} 
                onPageChange={setCurrentPage} 
                onUserChange={setCurrentUser}
                googleStatus={{ isConnected, isLoading, userInfo }} 
                onGoogleAction={() => { isConnected ? setCurrentPage('settings') : signIn(); }} 
            />
            <main className="p-4 md:p-6 pb-24">
                {currentPage === 'home' && <HomePage currentUser={currentUser} onUserChange={setCurrentUser} onPageChange={setCurrentPage} googleStatus={{ isConnected, isLoading, userInfo }} />}                {currentPage === 'games' && <GamesPage currentUser={currentUser} onPageChange={setCurrentPage} onGameSelect={(game) => handleCreateSessionAndNavigate('chat', { game })} />}
                {currentPage === 'sessions' && <SessionsPage currentUser={currentUser} onPageChange={setCurrentPage} onSessionSelect={handleSessionSelect} sessions={sessionHook.sessions} deleteSession={sessionHook.deleteSession} />}
                {currentPage === 'chat' && <ChatPage currentUser={currentUser} currentSession={currentChatSession} onUpdateSession={handleUpdateSession} onBackToSessions={() => setCurrentPage('sessions')} />}
                {currentPage === 'memories' && <MemoriesPage currentUser={currentUser} onCreateSession={(page, options) => handleCreateSessionAndNavigate(page, options)} />}
                {currentPage === 'settings' && <SettingsPage onReset={resetApp} googleAuth={googleAuth} onGoogleDisconnect={signOut} />}
                {currentPage === 'users' && <UsersPage currentUser={currentUser} onUserChange={setCurrentUser} onPageChange={setCurrentPage} />}
            </main>
            <BottomNavBar 
                currentPage={currentPage} 
                onPageChange={setCurrentPage} 
                currentUser={currentUser} 
            />
            <Toast 
                message={toast.message} 
                type={toast.type} 
                onDismiss={() => setToast({ message: '', type: '' })} 
            />
        </div>
    );
};

        // ===== RENDER =====
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(MemoireMekong));
    </script>
</body>
</html>
