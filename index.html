<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üêò M√©moire du M√©kong V0.6.0.1 : Debug Import photo index</title>
    
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <script src="https://apis.google.com/js/api.js"></script>
	<script src="https://accounts.google.com/gsi/client"></script>
	<script>
	window.onload = () => {
  		google.accounts.id.initialize({
    		client_id: '82966045106-hso0nr386agcuojllnud0dr41vcsh45a.apps.googleusercontent.com'
  		});
	};
	</script>

    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        .lucide { width: 1em; height: 1em; fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; }
        .fade-in { animation: fadeIn 0.3s ease-in; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
		.pulse-warning { animation: pulseWarning 2s infinite; }
		@keyframes pulseWarning { 
    		0%, 100% { background-color: rgb(254 242 242); border-color: rgb(252 165 165); }
    		50% { background-color: rgb(239 68 68); border-color: rgb(185 28 28); color: white; }
		}
        .scrollbar-thin { scrollbar-width: thin; scrollbar-color: rgb(251 146 60) rgb(229 231 235); }
        .scrollbar-thin::-webkit-scrollbar { height: 8px; }
        .scrollbar-thin::-webkit-scrollbar-track { background: rgb(229 231 235); border-radius: 4px; }
        .scrollbar-thin::-webkit-scrollbar-thumb { background-color: rgb(251 146 60); border-radius: 4px; }
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // ===== ICONS LUCIDE =====
        const Home = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9,22 9,12 15,12 15,22"/></svg>;
        const Users = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="m22 21-2-2"/></svg>;
        const User = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>;
        const Play = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><polygon points="5,3 19,12 5,21"/></svg>;
        const Camera = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/></svg>;
        const Cloud = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z"/></svg>;
        const Settings = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M12.22 2h-.44a2 2 0 0 0-2 2.18l.2 1.81c-.26.06-.51.14-.76.23l-1.5-1.16a2 2 0 0 0-2.83.32l-.22.38a2 2 0 0 0 .32 2.83l1.16 1.5c-.09.25-.17.5-.23.76l-1.81.2a2 2 0 0 0-2.18 2v.44a2 2 0 0 0 2.18 2l1.81.2c.06.26.14.51.23.76l-1.16 1.5a2 2 0 0 0-.32 2.83l.38.22a2 2 0 0 0 2.83-.32l1.5-1.16c.25.09.5.17.76.23l.2 1.81a2 2 0 0 0 2 2.18h.44a2 2 0 0 0 2-2.18l.2-1.81c.26-.06.51-.14.76-.23l1.5 1.16a2 2 0 0 0 2.83-.32l.22-.38a2 2 0 0 0-.32-2.83l-1.16-1.5c.09-.25.17-.5.23-.76l1.81-.2a2 2 0 0 0 2.18-2v-.44a2 2 0 0 0-2.18-2l-1.81-.2c-.06-.26-.14-.51-.23-.76l1.16-1.5a2 2 0 0 0 .32-2.83l-.38-.22a2 2 0 0 0-2.83.32l-1.5 1.16c-.25-.09-.5-.17-.76-.23l-.2-1.81a2 2 0 0 0-2-2.18Z"/><circle cx="12" cy="12" r="3"/></svg>;
        const ChevronLeft = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="m15 18-6-6 6-6"/></svg>;
        const ChevronRight = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="m9 18 6-6-6-6"/></svg>;
        const BookOpen = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg>;
        const Edit = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="m18.5 2.5 3 3L12 15l-4 1 1-4 9.5-9.5Z"/></svg>;
        const Plus = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M5 12h14"/><path d="M12 5v14"/></svg>;
        const Send = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="m22 2-7 20-4-9-9-4Z"/><path d="M22 2 11 13"/></svg>;
        const Trash2 = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="m8 6V4c0-1 1-2 2-2h4c0-1-1-2-2-2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>;
        const Upload = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7,10 12,5 17,10"/><line x1="12" x2="12" y1="5" y2="15"/></svg>;
        const FileText = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14,2 14,8 20,8"/><line x1="16" x2="8" y1="13" y2="13"/><line x1="16" x2="8" y1="17" y2="17"/><line x1="10" x2="8" y1="9" y2="9"/></svg>;
		const CloudOff = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="m2 2 20 20"/><path d="M5.782 5.782A7 7 0 0 0 9 19h8.5a4.5 4.5 0 0 0 1.307-.193"/><path d="M21.532 16.5A4.5 4.5 0 0 0 17.5 10h-1.79A7.008 7.008 0 0 0 10 5.07"/></svg>;

		// ===== COMPOSANT TOAST =====
		const Toast = ({ message, type, onDismiss }) => {
			if (!message) return null;
			const styles = { error: { bg: 'bg-red-100', text: 'text-red-800', border: 'border-red-300' }, success: { bg: 'bg-green-100', text: 'text-green-800', border: 'border-green-300' } };
			const style = styles[type] || styles.error;
			React.useEffect(() => { const timer = setTimeout(() => onDismiss(), 5000); return () => clearTimeout(timer); }, [message, onDismiss]);
			return ( <div className={`fixed bottom-20 right-4 left-4 sm:left-auto sm:max-w-sm p-4 border-2 rounded-lg shadow-lg fade-in z-50 ${style.bg} ${style.text} ${style.border}`}> <div className="flex justify-between items-start"> <span className="flex-1 pr-2 text-sm">{message}</span> <button onClick={onDismiss} className="ml-2 text-xl font-bold hover:opacity-70">&times;</button> </div> </div> );
		};

		// ===== COMPOSANT LOADING SPINNER =====
		const LoadingSpinner = ({ message = "Chargement...", size = "normal" }) => {
			const sizeClasses = { small: "w-4 h-4 border-2", normal: "w-8 h-8 border-2", large: "w-12 h-12 border-4" };
			return ( <div className="flex flex-col items-center justify-center py-12 fade-in"> <div className={`animate-spin border-amber-600 border-t-transparent rounded-full mb-4 ${sizeClasses[size]}`}></div> <p className="text-amber-700 text-center">{message}</p> </div> );
		};
        
        // ===== COMPOSANT TIMELINE (FRISE CHRONOLOGIQUE) =====
        const Timeline = ({ currentDay, maxDay, onDaySelect }) => {
            const timelineRef = React.useRef(null);
            const dayRef = React.useRef(null);

            React.useEffect(() => {
                if (dayRef.current) {
                    dayRef.current.scrollIntoView({ behavior: 'smooth', inline: 'center', block: 'nearest' });
                }
            }, [currentDay]);

            const days = Array.from({ length: maxDay }, (_, i) => i + 1);

            return (
                <div className="bg-gray-100 p-2 rounded-lg border border-gray-200">
                    <div ref={timelineRef} className="flex overflow-x-auto space-x-1 py-2 scrollbar-thin">
                        {days.map(day => {
                            const isCurrent = day === currentDay;
                            const isDecade = day % 10 === 0;
                            return (
                                <button key={day} ref={isCurrent ? dayRef : null} onClick={() => onDaySelect(day)} className={`flex-shrink-0 flex flex-col items-center justify-end h-16 w-8 rounded transition-colors duration-200 ${isCurrent ? 'bg-amber-500 text-white' : 'hover:bg-amber-100'}`}>
                                    <span className={`text-xs font-semibold ${isCurrent ? 'font-bold' : 'text-gray-600'}`}>
                                        {isDecade || day === 1 || day === maxDay ? day : ''}
                                    </span>
                                    <div className={`w-px h-full ${isDecade ? 'bg-amber-400 h-8' : 'bg-gray-300 h-4'}`}></div>
                                </button>
                            );
                        })}
                    </div>
                </div>
            );
        };

        // ===== COMPOSANT PHOTOGRID (GRILLE PHOTOS) =====
        const PhotoGrid = ({ photos, onPhotoSelect }) => {
            if (!photos || photos.length === 0) {
                return ( <div className="text-center py-12 bg-gray-50 rounded-lg"> <Camera className="w-16 h-16 text-gray-300 mx-auto mb-4" /> <h3 className="text-lg font-medium text-gray-600">Aucune photo pour ce jour</h3> <p className="text-gray-500">S√©lectionnez un autre jour sur la frise.</p> </div> );
            }
            return ( <div className="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-8 gap-2"> {photos.map((photo, index) => ( <button key={photo.filename + index} onClick={() => onPhotoSelect(index)} className="aspect-square bg-gray-200 rounded-md overflow-hidden hover:opacity-80 transition-opacity focus:outline-none focus:ring-2 focus:ring-amber-500"> <img src={photo.thumbnailLink} alt={photo.filename} loading="lazy" className="w-full h-full object-cover" /> </button> ))} </div> );
        };

        // ===== COMPOSANT PHOTOVIEWER (LIGHTBOX) =====
        const PhotoViewer = ({ photos, selectedIndex, onClose, onNavigate, onCreateSession }) => {
            if (selectedIndex === null) return null;
            React.useEffect(() => { const handleKeyDown = (e) => { if (e.key === 'Escape') onClose(); if (e.key === 'ArrowLeft') onNavigate('prev'); if (e.key === 'ArrowRight') onNavigate('next'); }; window.addEventListener('keydown', handleKeyDown); return () => window.removeEventListener('keydown', handleKeyDown); }, [onClose, onNavigate]);
            const cleanDriveImageLink = (url) => { if (!url) return null; return url.split('=')[0]; };
            const currentPhoto = photos[selectedIndex];
            const canGoPrev = selectedIndex > 0;
            const canGoNext = selectedIndex < photos.length - 1;
            const largeImageUrl = cleanDriveImageLink(currentPhoto.webContentLink);
            return ( <div className="fixed inset-0 bg-black/90 flex flex-col items-center justify-center z-50 fade-in p-4"> <button onClick={onClose} className="absolute top-4 right-4 text-white text-3xl hover:opacity-75 z-50">&times;</button> <div className="relative w-full h-full flex items-center justify-center"> <div className="relative flex items-center justify-center max-w-full max-h-full"> <img src={largeImageUrl} alt={currentPhoto.filename} className="max-h-[85vh] max-w-[90vw] object-contain"/> </div> <button onClick={() => onNavigate('prev')} disabled={!canGoPrev} className="absolute left-4 text-white text-4xl hover:opacity-75 disabled:opacity-30"><ChevronLeft className="w-10 h-10" /></button> <button onClick={() => onNavigate('next')} disabled={!canGoNext} className="absolute right-4 text-white text-4xl hover:opacity-75 disabled:opacity-30"><ChevronRight className="w-10 h-10" /></button> </div> <div className="absolute bottom-4 left-4 right-4 flex justify-between items-center text-white bg-black/30 p-3 rounded-lg"> <p className="text-sm truncate pr-4">{currentPhoto.filename}</p> <button onClick={() => onCreateSession(currentPhoto)} className="flex-shrink-0 flex items-center space-x-2 px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg text-sm font-semibold"><Plus className="w-4 h-4"/><span>Session</span></button> </div> </div> );
        };

		// ===== CORE STORAGE =====
		const Storage = {
			get: (key, defaultValue = null) => { try { const item = localStorage.getItem(`mekong_${key}`); return item ? JSON.parse(item) : defaultValue; } catch { return defaultValue; } },
			set: (key, value) => { try { localStorage.setItem(`mekong_${key}`, JSON.stringify(value)); return true; } catch { return false; } },
			remove: (key) => localStorage.removeItem(`mekong_${key}`),
			clear: () => { Object.keys(localStorage).forEach(key => { if (key.startsWith('mekong_')) localStorage.removeItem(key); }); }
		};
		
        // ===== MASTODON DATA MANAGEMENT =====
        const MastodonData = {
            decodeHtmlEntities: (text) => { const ta = document.createElement('textarea'); ta.innerHTML = text; return ta.value; },
            parseOutbox: (jsonData) => {
                try {
                    const data = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;
                    let orderedItems = data.orderedItems || (data.data && data.data.orderedItems) || [];
                    if (!Array.isArray(orderedItems)) throw new Error('orderedItems is not an array');
                    
                    const allPosts = orderedItems.filter(item => item.type === 'Create' && item.object?.type === 'Note').map((item, index) => {
                        const note = item.object;
                        const content = note.content || '';
                        const cleanContent = content.replace(/<[^>]*>/g, '');
                        const decodedContent = MastodonData.decodeHtmlEntities(cleanContent);
                        const dayMatch = decodedContent.match(/^J(\d{1,3})[\s:]/);
                        const dayNumber = dayMatch ? parseInt(dayMatch[1]) : null;
                        let title = (dayNumber !== null ? decodedContent.replace(/^J\d{1,3}[\s:]+/, '') : decodedContent).split('\n')[0].slice(0, 60).trim();
                        if (title.length === 60) title += '...';
                        title = title.replace(/[‚õ©Ô∏èü¶©‚úàÔ∏èüá®üáµüî•‚ö°üåüüéØüí™üöÄ‚ú®üéâüéäüéàüéÅüéÄüéáüéÜ]/g, '').replace(/\s+/g, ' ').trim();
                        return { id: note.id || `post-${index}`, dayNumber, hasJourNumber: dayNumber !== null, title: title || 'Post sans titre', content: decodedContent, published: note.published || item.published, attachments: note.attachment || [], url: note.url };
                    });

                    const postsWithDay = allPosts.filter(p => p.hasJourNumber);
                    const postsWithoutDay = allPosts.filter(p => !p.hasJourNumber);
                    postsWithDay.sort((a, b) => a.dayNumber - b.dayNumber);
                    const maxDayNumber = postsWithDay.length > 0 ? Math.max(...postsWithDay.map(p => p.dayNumber)) : 0;
                    postsWithoutDay.forEach((post, index) => { post.dayNumber = maxDayNumber + index + 1; post.isExtraPost = true; });
                    const finalPosts = [...postsWithDay, ...postsWithoutDay];
                    finalPosts.forEach(p => { delete p.hasJourNumber; });
                    return finalPosts;
                } catch (error) { console.error('Erreur parsing outbox:', error); throw error; }
            },
            savePosts: (posts) => { Storage.set('mastodon_posts', posts); Storage.set('mastodon_imported_at', new Date().toISOString()); },
            getPosts: () => Storage.get('mastodon_posts', []),
            searchPosts: (query) => { const posts = MastodonData.getPosts(); if (!query.trim()) return posts; const terms = query.toLowerCase().trim().split(/\s+/); return posts.filter(p => terms.every(t => p.content.toLowerCase().includes(t))); },
            getPostByDay: (day) => MastodonData.getPosts().find(p => p.dayNumber === day),
            getRandomPost: () => { const p = MastodonData.getPosts(); return p.length ? p[Math.floor(Math.random() * p.length)] : null; },
            isImported: () => MastodonData.getPosts().length > 0,
            getStats: () => {
                const posts = MastodonData.getPosts(); const extra = posts.filter(p => p.isExtraPost).length;
                return { totalPosts: posts.length, regularPosts: posts.length - extra, extraPosts: extra, dayRange: posts.length > 0 ? { min: Math.min(...posts.map(p => p.dayNumber)), max: Math.max(...posts.map(p => p.dayNumber)) } : null, importedAt: Storage.get('mastodon_imported_at') };
            }
        };

        // ===== PHOTO DATA MANAGEMENT =====
        const PhotoData = {
            parsePhotoIndex: (jsonData) => {
                try {
                    const data = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;
                    let allPhotos = []; const photosByDay = {};
                    for (const key in data) {
                        if (data.hasOwnProperty(key)) {
                            const entry = data[key];
                            const day = entry.day;
                            if (day && entry.photos && entry.photos.length > 0) {
                                if (!photosByDay[day]) photosByDay[day] = [];
                                const photoEntries = entry.photos.map(filename => ({ day, folderName: entry.folderName, filename }));
                                photosByDay[day].push(...photoEntries);
                                allPhotos.push(...photoEntries);
                            }
                        }
                    }
                    allPhotos.sort((a, b) => a.day - b.day);
                    return { allPhotos, photosByDay };
                } catch (e) { console.error("Erreur parsing index photos:", e); throw e; }
            },
            saveIndex: (indexData) => { Storage.set('photo_index', indexData); Storage.set('photo_index_imported_at', new Date().toISOString()); },
            getIndex: () => Storage.get('photo_index', null),
            getPhotosByDay: (day) => PhotoData.getIndex()?.photosByDay?.[day] || [],
            isImported: () => !!PhotoData.getIndex(),
            getStats: () => { const index = PhotoData.getIndex(); if (!index) return { totalPhotos: 0 }; return { totalPhotos: index.allPhotos.length, totalDays: Object.keys(index.photosByDay).length, importedAt: Storage.get('photo_index_imported_at') }; }
        };

        // ===== GOOGLE DRIVE API =====
        const GOOGLE_CONFIG = {
            API_KEY: 'AIzaSyDiyLLN4EsyVREGxF4TzqbuKyugaq4TUXw',
            CLIENT_ID: '82966045106-hso0nr386agcuojllnud0dr41vcsh45a.apps.googleusercontent.com',
            SCOPES: 'https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/userinfo.profile https://www.googleapis.com/auth/userinfo.email'
        };
        const GoogleDriveAPI = {
            isSignedIn: false, isInitialized: false, tokenClient: null, _folderCache: new Map(),
            async init() { if (this.isInitialized) return; try { await new Promise(r => gapi.load('client', r)); await gapi.client.init({ apiKey: GOOGLE_CONFIG.API_KEY, discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'] }); this.tokenClient = google.accounts.oauth2.initTokenClient({ client_id: GOOGLE_CONFIG.CLIENT_ID, scope: GOOGLE_CONFIG.SCOPES, callback: '' }); this.isInitialized = true; } catch (e) { console.error('Erreur init API:', e); throw e; } },
            async signIn() { if (!this.isInitialized) await this.init(); return new Promise((resolve, reject) => { if (!this.tokenClient) return reject(new Error('Token client non initialis√©')); this.tokenClient.callback = async (res) => { if (res.error) { this.isSignedIn = false; return reject(new Error(`Erreur OAuth: ${res.error}`)); } try { await gapi.client.drive.files.list({ pageSize: 1 }); this.isSignedIn = true; resolve(true); } catch (e) { this.isSignedIn = false; reject(new Error('Acc√®s API impossible')); } }; const token = gapi.client.getToken(); if (token) { gapi.client.drive.files.list({ pageSize: 1 }).then(() => { this.isSignedIn = true; resolve(true); }).catch(() => { gapi.client.setToken(''); this.tokenClient.requestAccessToken({ prompt: 'consent' }); }); } else { this.tokenClient.requestAccessToken({ prompt: 'consent' }); } }); },
            async signOut() { const token = gapi.client.getToken(); if (token) { google.accounts.oauth2.revoke(token.access_token); gapi.client.setToken(''); } this.isSignedIn = false; this._folderCache.clear(); },
            async _findFile(name, parentId = 'root', mimeType = null) { const cacheKey = `${parentId}-${name}-${mimeType||'any'}`; if (this._folderCache.has(cacheKey)) return this._folderCache.get(cacheKey); try { let q = `'${parentId}' in parents and name='${name}' and trashed=false`; if (mimeType) q += ` and mimeType='${mimeType}'`; const res = await gapi.client.drive.files.list({ q, fields: 'files(id, name)', pageSize: 1 }); const file = res.result.files[0] || null; if (file) this._folderCache.set(cacheKey, file); return file; } catch (e) { console.error(`Erreur recherche '${name}':`, e); throw e; } },
            async findMekongFile() { return this._findFile("mekong_sessions.json", "root"); },
            async loadSessions() { if (!this.isSignedIn) throw new Error('Pas connect√©'); try { const file = await this.findMekongFile(); if (!file) return null; const res = await gapi.client.drive.files.get({ fileId: file.id, alt: 'media' }); return JSON.parse(res.body).sessions || []; } catch (e) { console.error('Erreur chargement sessions:', e); throw e; } },
            async saveSessions(sessions) { if (!this.isSignedIn) throw new Error('Pas connect√©'); try { const data = JSON.stringify({ sessions, lastUpdated: new Date().toISOString() }, null, 2); const file = await this.findMekongFile(); if (file) { await gapi.client.request({ path: `https://www.googleapis.com/upload/drive/v3/files/${file.id}`, method: 'PATCH', params: { uploadType: 'media' }, headers: { 'Content-Type': 'application/json' }, body: data }); } else { const boundary = '---314159'; const metadata = { name: 'mekong_sessions.json', mimeType: 'application/json' }; const body = `\r\n--${boundary}\r\nContent-Type: application/json\r\n\r\n${JSON.stringify(metadata)}\r\n--${boundary}\r\nContent-Type: application/json\r\n\r\n${data}\r\n--${boundary}--`; await gapi.client.request({ path: '/upload/drive/v3/files', method: 'POST', params: { uploadType: 'multipart' }, headers: { 'Content-Type': `multipart/related; boundary="${boundary}"` }, body }); } return true; } catch (e) { console.error('Erreur sauvegarde sessions:', e); throw e; } },
            async loadJsonFile(fileName) { if (!this.isSignedIn) throw new Error('Pas connect√©'); try { const file = await this._findFile(fileName, "root"); if (!file) return null; const res = await gapi.client.drive.files.get({ fileId: file.id, alt: 'media' }); return JSON.parse(res.body); } catch (e) { console.error(`Erreur chargement JSON '${fileName}':`, e); throw e; } },
            async listPhotoFiles(folderId) { if (!this.isSignedIn) throw new Error('Pas connect√©'); try { const res = await gapi.client.drive.files.list({ q: `'${folderId}' in parents and mimeType contains 'image/' and trashed=false`, fields: 'files(name, webContentLink, thumbnailLink)', pageSize: 500 }); return res.result.files || []; } catch (e) { console.error(`Erreur listing photos du dossier ${folderId}:`, e); return []; } }
        };

        // ===== USER CONFIG & HELPERS =====
        const USERS = { tom: { name: 'Tom', emoji: 'üêò' }, lambert: { name: 'Lambert', emoji: 'üêò' }, duo: { name: 'Duo', emoji: 'üêòüêò' } };
        const getGameById = (id) => GAMES.find(g => g.id === id);

        // ===== APP STATE & SESSION MANAGEMENT =====
        const useAppState = () => { const [page, setPage] = React.useState('home'); const [user, setUser] = React.useState(Storage.get('currentUser', '')); React.useEffect(() => { Storage.set('currentUser', user); }, [user]); const resetApp = () => { setPage('home'); setUser(''); Storage.clear(); }; return { currentPage: page, setCurrentPage: setPage, currentUser: user, setCurrentUser: setUser, resetApp }; };
        const useSessionState = () => { const [sessions, setSessions] = React.useState(Storage.get('sessions', [])); const saveSessionsToStorage = (s) => { Storage.set('sessions', s); setSessions(s); }; const createSession = (game, user, initialContent = null) => { const newSession = { id: Date.now(), gameId: game.id, gameTitle: game.title, user, createdAt: new Date().toISOString(), notes: initialContent ? [{id: Date.now(), content: initialContent, author: 'duo', timestamp: new Date().toISOString()}] : [] }; const newSessions = [newSession, ...sessions]; saveSessionsToStorage(newSessions); return newSession; }; const updateSession = (updated) => { const newSessions = sessions.map(s => s.id === updated.id ? { ...updated, updatedAt: new Date().toISOString() } : s); saveSessionsToStorage(newSessions); }; const deleteSession = (id) => { if (confirm('Supprimer cette session ?')) { const newSessions = sessions.filter(s => s.id !== id); saveSessionsToStorage(newSessions); } }; return { sessions, createSession, updateSession, deleteSession }; };
        
        // ===== GOOGLE AUTH & SYNC =====
        const useGoogleAuthAndSync = (sessions, setSessions) => {
            const [isConnected, setIsConnected] = React.useState(false);
            const [isLoading, setIsLoading] = React.useState(true);
            const [toast, setToast] = React.useState({ msg: '', type: '' });

            const sync = async () => {
                if (!GoogleDriveAPI.isSignedIn) return;
                try {
                    const cloudSessions = await GoogleDriveAPI.loadSessions();
                    if (cloudSessions) {
                        const localSessions = Storage.get('sessions', []);
                        // Simple merge: cloud data is king, but keep local new sessions
                        const cloudIds = new Set(cloudSessions.map(s => s.id));
                        const newLocal = localSessions.filter(s => !cloudIds.has(s.id));
                        const merged = [...cloudSessions, ...newLocal].sort((a,b) => new Date(b.createdAt) - new Date(a.createdAt));
                        Storage.set('sessions', merged);
                        setSessions(merged);
                        setToast({ msg: 'Synchronisation r√©ussie', type: 'success' });
                    }
                } catch (e) { setToast({ msg: `√âchec de la synchronisation: ${e.message}`, type: 'error' }); }
            };

            const signIn = async () => {
                try {
                    await GoogleDriveAPI.signIn();
                    setIsConnected(true);
                    await sync();
                } catch (e) { setToast({ msg: `Erreur de connexion: ${e.message}`, type: 'error' }); }
            };
            
            React.useEffect(() => {
                const init = async () => {
                    setIsLoading(true);
                    await GoogleDriveAPI.init();
                    // Auto-signin attempt
                    if (gapi.client.getToken()) {
                        GoogleDriveAPI.isSignedIn = true;
                        setIsConnected(true);
                        await sync();
                    }
                    setIsLoading(false);
                };
                init();
            }, []);

            return { isConnected, isLoading, signIn, toast, setToast };
        };

        // ===== MAIN PAGES =====

        const HomePage = ({ onPageChange }) => (
            <div className="grid grid-cols-1 md:grid-cols-3 gap-6 text-center">
                <button onClick={() => onPageChange('sessions')} className="p-6 bg-white rounded-lg shadow-md hover:shadow-lg transition-shadow"> <Play className="w-12 h-12 text-blue-600 mx-auto mb-4" /> <h3 className="text-lg font-semibold">Sessions</h3> <p className="text-sm text-gray-600">Cr√©er ou reprendre une session</p> </button>
                <button onClick={() => onPageChange('memories')} className="p-6 bg-white rounded-lg shadow-md hover:shadow-lg transition-shadow"> <Cloud className="w-12 h-12 text-green-600 mx-auto mb-4" /> <h3 className="text-lg font-semibold">M√©moires</h3> <p className="text-sm text-gray-600">Explorer le blog et les photos</p> </button>
                <button onClick={() => onPageChange('settings')} className="p-6 bg-white rounded-lg shadow-md hover:shadow-lg transition-shadow"> <Settings className="w-12 h-12 text-purple-600 mx-auto mb-4" /> <h3 className="text-lg font-semibold">R√©glages</h3> <p className="text-sm text-gray-600">Configuration et import</p> </button>
            </div>
        );

        const SessionsPage = ({ sessions, onSessionSelect, onNewSession }) => (
            <div className="space-y-4">
                <button onClick={onNewSession} className="w-full flex items-center justify-center space-x-2 px-4 py-3 bg-amber-500 hover:bg-amber-600 text-white rounded-lg font-semibold shadow"><Plus/><span>Nouveau Jeu de M√©moire</span></button>
                {sessions.length === 0 ? <p className="text-center text-gray-500 py-8">Aucune session. Cr√©ez-en une !</p> : sessions.map(s => (
                    <div key={s.id} onClick={() => onSessionSelect(s)} className="bg-white p-3 rounded-lg border hover:border-amber-400 cursor-pointer">
                        <h3 className="font-bold">{s.gameTitle}</h3>
                        <p className="text-xs text-gray-500">Cr√©√©e le {new Date(s.createdAt).toLocaleDateString()}</p>
                    </div>
                ))}
            </div>
        );

        const ChatPage = ({ session, onUpdateSession, currentUser }) => {
            const [text, setText] = React.useState('');
            const addNote = () => { if (!text.trim()) return; const newNote = { id: Date.now(), content: text, author: currentUser, timestamp: new Date().toISOString() }; onUpdateSession({ ...session, notes: [...(session.notes || []), newNote] }); setText(''); };
            const renderMessageContent = (content) => {
                const match = content.match(/\[IMAGE\](.*?)\[\/IMAGE\]/);
                if (match && match[1]) {
                    const text = content.replace(match[0], '').trim();
                    return (<> <img src={match[1]} className="rounded-lg max-w-xs my-2" /> {text && <p className="mt-2">{text}</p>} </>);
                }
                return <p>{content}</p>;
            };
            return (
                <div className="flex flex-col h-[70vh]">
                    <h2 className="text-xl font-bold mb-4">{session.gameTitle}</h2>
                    <div className="flex-1 bg-gray-50 rounded-lg border overflow-y-auto p-4 space-y-3">
                        {(session.notes || []).map(note => (
                            <div key={note.id} className={`flex ${note.author === currentUser ? 'justify-end' : 'justify-start'}`}>
                                <div className={`max-w-[75%] rounded-2xl px-4 py-3 ${note.author === currentUser ? 'bg-blue-500 text-white' : 'bg-gray-200'}`}>
                                    {renderMessageContent(note.content)}
                                    <div className="text-xs opacity-70 mt-1">{note.author} - {new Date(note.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</div>
                                </div>
                            </div>
                        ))}
                    </div>
                    <div className="mt-4 flex space-x-2">
                        <textarea value={text} onChange={e => setText(e.target.value)} placeholder="Votre souvenir..." className="flex-1 resize-none border rounded-lg p-2" rows="3"></textarea>
                        <button onClick={addNote} className="w-12 h-12 self-end bg-blue-500 text-white rounded-lg flex items-center justify-center"><Send className="w-6 h-6"/></button>
                    </div>
                </div>
            );
        };

        const MemoriesPage = ({ onCreateSession }) => {
            const [currentDay, setCurrentDay] = React.useState(1);
            const [activeTab, setActiveTab] = React.useState('blog');
            const [currentPost, setCurrentPost] = React.useState(null);
            const [dayPhotos, setDayPhotos] = React.useState([]);
            const [isLoadingPhotos, setIsLoadingPhotos] = React.useState(false);
            const [selectedPhotoIndex, setSelectedPhotoIndex] = React.useState(null);
            const mastodonStats = MastodonData.getStats();
            const isPhotoIndexImported = PhotoData.isImported();
            
            React.useEffect(() => {
                const loadDataForDay = async () => {
                    setCurrentPost(MastodonData.getPostByDay(currentDay));
                    if (isPhotoIndexImported && PhotoData.getPhotosByDay(currentDay).length > 0) {
                        setActiveTab('photos');
                        await loadPhotosForDay(currentDay);
                    } else { setActiveTab('blog'); setDayPhotos([]); }
                };
                loadDataForDay();
            }, [currentDay, isPhotoIndexImported]);

            const cleanDriveImageLink = (url) => url ? url.split('=')[0] : null;
            
            const loadPhotosForDay = async (day) => {
                setIsLoadingPhotos(true); setDayPhotos([]);
                const photoIndexEntries = PhotoData.getPhotosByDay(day);
                if (photoIndexEntries.length === 0) { setIsLoadingPhotos(false); return; }
                const foldersToQuery = photoIndexEntries.reduce((acc, photo) => { acc[photo.folderName] = (acc[photo.folderName] || []).concat(photo.filename); return acc; }, {});
                let allFoundPhotos = [];
                const mediasFolder = await GoogleDriveAPI._findFile('Medias', 'root', 'application/vnd.google-apps.folder');
                const photosRootFolder = await GoogleDriveAPI._findFile('Photos', mediasFolder.id, 'application/vnd.google-apps.folder');
                if (!photosRootFolder) { setIsLoadingPhotos(false); return; }
                for (const folderName in foldersToQuery) {
                    const dayFolder = await GoogleDriveAPI._findFile(folderName, photosRootFolder.id, 'application/vnd.google-apps.folder');
                    if (dayFolder) {
                        const filesInDrive = await GoogleDriveAPI.listPhotoFiles(dayFolder.id);
                        const driveFilesMap = new Map(filesInDrive.map(file => [file.name, file]));
                        for (const filename of foldersToQuery[folderName]) {
                            if (driveFilesMap.has(filename)) {
                                const fileData = driveFilesMap.get(filename);
                                allFoundPhotos.push({ ...fileData, filename, thumbnailLink: cleanDriveImageLink(fileData.thumbnailLink), webContentLink: cleanDriveImageLink(fileData.webContentLink) });
                            }
                        }
                    }
                }
                setDayPhotos(allFoundPhotos); setIsLoadingPhotos(false);
            };

            const createSessionFromPhoto = (photo) => { const game = getGameById(1); const content = `[IMAGE]${photo.webContentLink}[/IMAGE]\n\n√Ä propos de cette photo : ${photo.filename}`; onCreateSession(game, content); };

            return (
                <div className="space-y-6">
                    <Timeline currentDay={currentDay} maxDay={mastodonStats?.dayRange?.max || 275} onDaySelect={setCurrentDay} />
                    <div className="flex justify-center border-b">
                        <button onClick={() => setActiveTab('blog')} className={`px-6 py-3 font-semibold ${activeTab === 'blog' ? 'border-b-2 border-amber-500 text-amber-600' : 'text-gray-500'}`}><BookOpen className="w-5 h-5 inline mr-2"/>Blog</button>
                        <button onClick={() => setActiveTab('photos')} className={`px-6 py-3 font-semibold ${activeTab === 'photos' ? 'border-b-2 border-amber-500 text-amber-600' : 'text-gray-500'}`} disabled={!isPhotoIndexImported}><Camera className="w-5 h-5 inline mr-2"/>Photos</button>
                    </div>
                    <div className="bg-white p-4 rounded-lg border min-h-[300px]">
                        {activeTab === 'photos' ? (isLoadingPhotos ? <LoadingSpinner message="Chargement..." /> : <PhotoGrid photos={dayPhotos} onPhotoSelect={setSelectedPhotoIndex} />)
                        : (currentPost ? <div><h3 className="text-2xl font-bold text-amber-900">Jour {currentPost.dayNumber}</h3><div className="prose max-w-none mt-4"><p>{currentPost.content}</p></div></div> : <p className="text-center py-12">Aucun post.</p>)}
                    </div>
                    {selectedPhotoIndex !== null && <PhotoViewer photos={dayPhotos} selectedIndex={selectedPhotoIndex} onClose={() => setSelectedPhotoIndex(null)} onNavigate={(dir) => setSelectedPhotoIndex(i => dir === 'next' ? i+1 : i-1)} onCreateSession={createSessionFromPhoto} />}
                </div>
            );
        };
        
        const SettingsPage = ({ googleAuth, setSessions }) => {
            const { isConnected, signIn } = googleAuth;
            const [status, setStatus] = React.useState('');
            
            const handleImport = async (importer, parser, saver, fileName, dataType) => {
                setStatus(`Import de ${dataType}...`);
                try {
                    const data = await importer(fileName);
                    if (!data) throw new Error(`Fichier ${fileName} introuvable sur votre Google Drive.`);
                    const parsed = parser(data);
                    saver(parsed);
                    setStatus(`‚úÖ ${dataType} import√©(e)s avec succ√®s !`);
                } catch(e) { setStatus(`‚ùå Erreur: ${e.message}`); }
            };

            const importMastodon = (file) => new Promise((resolve, reject) => {
                if (!file) return reject(new Error("Aucun fichier s√©lectionn√©."));
                const reader = new FileReader();
                reader.onload = (e) => resolve(e.target.result);
                reader.onerror = (e) => reject(new Error("Erreur de lecture du fichier."));
                reader.readAsText(file);
            });

            return (
                <div className="space-y-6">
                    <div className="bg-white p-6 rounded-lg shadow-md">
                        <h3 className="text-lg font-semibold mb-4">Connexion Google Drive</h3>
                        {isConnected ? <p className="text-green-700">‚úÖ Connect√© et synchronis√©.</p> : <button onClick={signIn} className="px-4 py-2 bg-blue-500 text-white rounded">Se Connecter</button>}
                    </div>
                    <div className="bg-white p-6 rounded-lg shadow-md space-y-4">
                        <h3 className="text-lg font-semibold">Imports de Donn√©es</h3>
                        <div className="flex flex-col sm:flex-row gap-4">
                            <label htmlFor="mastodon-file" className="flex-1 w-full text-center px-4 py-2 border rounded hover:bg-gray-50 cursor-pointer">Importer Blog Mastodon</label>
                            <input type="file" id="mastodon-file" className="hidden" onChange={(e) => handleImport(() => importMastodon(e.target.files[0]), MastodonData.parseOutbox, MastodonData.savePosts, null, 'Blog Mastodon')} />
                            
                            {/* LA CORRECTION EST ICI : on utilise .bind(GoogleDriveAPI) */}
                            <button 
                                onClick={() => handleImport(GoogleDriveAPI.loadJsonFile.bind(GoogleDriveAPI), PhotoData.parsePhotoIndex, PhotoData.saveIndex, 'photos_index_clean.json', 'Index Photos')} 
                                className="flex-1 px-4 py-2 border rounded hover:bg-gray-50" 
                                disabled={!isConnected}>
                                Importer Index Photos (Drive)
                            </button>
                        </div>
                        {status && <p className="text-center text-sm mt-4">{status}</p>}
                    </div>
                    <div className="bg-white p-6 rounded-lg shadow-md">
                        <h3 className="text-lg font-semibold mb-4">R√©initialisation</h3>
                        <button onClick={() => {if(confirm('R√©initialiser toute l\'application ?')) { Storage.clear(); window.location.reload(); }}} className="px-4 py-2 bg-red-500 text-white rounded">Reset Complet</button>
                    </div>
                </div>
            );
        };
        
        // ===== APP ROOT =====
        const GAMES = [ { id: 1, title: "Photo roulette" }, { id: 7, title: "Souvenir du jour" } ]; // Simplified
        const MemoireMekong = () => {
            const { currentPage, setCurrentPage, currentUser, setCurrentUser } = useAppState();
            const { sessions, createSession, updateSession, deleteSession } = useSessionState();
            const { isConnected, isLoading, signIn, toast, setToast } = useGoogleAuthAndSync(sessions, (newSessions) => updateSession({ id: -1, notes: [] }, newSessions)); // Workaround to update sessions from sync

            const [currentChatSession, setCurrentChatSession] = React.useState(null);

            const handleSessionSelect = (session) => { setCurrentChatSession(session); setCurrentPage('chat'); };
            const handleCreateSession = (game, content) => { const newSession = createSession(game, currentUser, content); handleSessionSelect(newSession); };

            const PageContent = () => {
                switch(currentPage) {
                    case 'home': return <HomePage onPageChange={setCurrentPage} />;
                    case 'sessions': return <SessionsPage sessions={sessions} onSessionSelect={handleSessionSelect} onNewSession={() => alert("Choisissez un jeu depuis la page M√©moires.")} />;
                    case 'chat': return currentChatSession ? <ChatPage session={currentChatSession} onUpdateSession={updateSession} currentUser={currentUser} /> : <p>Session non trouv√©e.</p>;
                    case 'memories': return <MemoriesPage onCreateSession={handleCreateSession} />;
                    case 'settings': return <SettingsPage googleAuth={{isConnected, signIn}} />;
                    default: return <HomePage onPageChange={setCurrentPage} />;
                }
            };
            
            return (
                <div className="min-h-screen bg-gradient-to-br from-amber-50 to-orange-100">
                    <header className="sticky top-0 z-10 p-3 bg-white/90 backdrop-blur-md border-b">
                        <h1 className="text-xl font-bold text-amber-900">{currentPage.charAt(0).toUpperCase() + currentPage.slice(1)}</h1>
                    </header>
                    <main className="p-4 pb-24"><div className="max-w-6xl mx-auto"><div className="bg-white/80 backdrop-blur rounded-xl shadow-lg p-6">{PageContent()}</div></div></main>
                    <footer className="fixed bottom-0 left-0 right-0 h-16 bg-white/90 backdrop-blur-md border-t flex justify-around">
                        {['home', 'sessions', 'memories', 'settings'].map(p => (
                            <button key={p} onClick={() => setCurrentPage(p)} className={`flex flex-col items-center justify-center w-full h-full transition-colors ${currentPage === p ? 'text-amber-600' : 'text-gray-500'}`}>
                                {React.createElement({home: Home, sessions: BookOpen, memories: Cloud, settings: Settings}[p], {className: "w-6 h-6 mb-1"})}
                                <span className="text-xs font-medium">{p.charAt(0).toUpperCase() + p.slice(1)}</span>
                            </button>
                        ))}
                    </footer>
                    <Toast message={toast.msg} type={toast.type} onDismiss={() => setToast({msg: '', type: ''})} />
                </div>
            );
        };

        ReactDOM.createRoot(document.getElementById('root')).render(<MemoireMekong />);
    </script>
</body>
</html>
