<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>M√©moire du M√©kong V0.5.3</title>
    <script src="https://apis.google.com/js/api.js"></script>
    <script src="https://accounts.google.com/gsi/client"></script>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
</head>
<body class="bg-gradient-to-br from-orange-50 to-amber-50">

<div id="root"></div>

<script type="text/babel">

// ===== STORAGE =====
const Storage = {
    get: (key, defaultValue = null) => {
        try {
            const item = localStorage.getItem(`mekong_${key}`);
            return item ? JSON.parse(item) : defaultValue;
        } catch { return defaultValue; }
    },
    set: (key, value) => {
        try {
            localStorage.setItem(`mekong_${key}`, JSON.stringify(value));
            return true;
        } catch { return false; }
    },
    remove: (key) => localStorage.removeItem(`mekong_${key}`),
    clear: () => {
        Object.keys(localStorage).forEach(key => {
            if (key.startsWith('mekong_')) localStorage.removeItem(key);
        });
    }
};

// ===== GOOGLE DRIVE API - V0.5.0 AVEC PHOTOS =====
const GOOGLE_CONFIG = {
    API_KEY: 'AIzaSyDiyLLN4EsyVREGxF4TzqbuKyugaq4TUXw',
    CLIENT_ID: '82966045106-hso0nr386agcuojllnud0dr41vcsh45a.apps.googleusercontent.com',
    SCOPES: 'https://www.googleapis.com/auth/drive.readonly https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/userinfo.profile https://www.googleapis.com/auth/userinfo.email'
};

const GoogleDriveAPI = {
    isSignedIn: false,
    isInitialized: false,
    tokenClient: null,
    
    // Cache pour √©viter les appels r√©p√©t√©s
    _photoCache: {
        folders: null,
        mastodonPhotos: null,
        contentIndex: null,
        lastRefresh: null
    },
    
    async init() {
        if (this.isInitialized) return;
        
        try {
            console.log('üîÑ Initialisation Google Drive API v0.5.0...');
            
            await new Promise((resolve) => {
                gapi.load('client', resolve);
            });
            
            await gapi.client.init({
                apiKey: GOOGLE_CONFIG.API_KEY,
                discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest']
            });
            
            this.tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: GOOGLE_CONFIG.CLIENT_ID,
                scope: GOOGLE_CONFIG.SCOPES,
                callback: ''
            });
            
            this.isInitialized = true;
            console.log('‚úÖ Google Drive API initialis√©e');
        } catch (error) {
            console.error('‚ùå Erreur init Google Drive API:', error);
            throw error;
        }
    },
    
    async signIn() {
        if (!this.isInitialized) await this.init();
        
        return new Promise((resolve, reject) => {
            if (!this.tokenClient) {
                reject(new Error('Token client non initialis√©'));
                return;
            }
            
            this.tokenClient.callback = async (response) => {
                if (response.error) {
                    console.error('‚ùå Erreur OAuth:', response);
                    this.isSignedIn = false;
                    reject(new Error(`Erreur OAuth: ${response.error}`));
                    return;
                }
                
                console.log('‚úÖ Token OAuth re√ßu');
                
                try {
                    await new Promise(resolve => setTimeout(resolve, 200));
                    await gapi.client.drive.files.list({ pageSize: 1 });
                    console.log('‚úÖ API Drive fonctionnelle');
                    this.isSignedIn = true;
                    
                    // Invalidation du cache √† la reconnexion
                    this._photoCache = {
                        folders: null,
                        mastodonPhotos: null,
                        contentIndex: null,
                        lastRefresh: null
                    };
                    
                    resolve(true);
                } catch (error) {
                    console.error('‚ùå Test API Drive √©chou√©:', error);
                    this.isSignedIn = false;
                    reject(new Error('Acc√®s API Drive impossible - Permissions insuffisantes'));
                }
            };
            
            const token = gapi.client.getToken();
            if (token) {
                console.log('üîÑ Token existant trouv√©, test de validit√©...');
                gapi.client.drive.files.list({ pageSize: 1 })
                    .then(() => {
                        this.isSignedIn = true;
                        console.log('‚úÖ Token existant valide');
                        resolve(true);
                    })
                    .catch(() => {
                        console.log('üîÑ Token expir√©, demande de nouveau token...');
                        gapi.client.setToken('');
                        this.tokenClient.requestAccessToken({ prompt: 'consent' });
                    });
            } else {
                console.log('üîÑ Aucun token, demande d\'autorisation...');
                this.tokenClient.requestAccessToken({ prompt: 'consent' });
            }
        });
    },
    
    async signOut() {
        const token = gapi.client.getToken();
        if (token) {
            google.accounts.oauth2.revoke(token.access_token);
            gapi.client.setToken('');
        }
        this.isSignedIn = false;
        
        // Vider le cache
        this._photoCache = {
            folders: null,
            mastodonPhotos: null,
            contentIndex: null,
            lastRefresh: null
        };
        
        console.log('‚úÖ D√©connect√© de Google Drive');
    },

    // ===== M√âTHODES SESSIONS (existantes, inchang√©es) =====
    async findMekongFile() {
        if (!this.isSignedIn) return null;
        try {
            const response = await gapi.client.drive.files.list({
                q: "name='mekong_sessions.json' and trashed=false",
                fields: 'files(id, name)'
            });
            return response.result.files[0] || null;
        } catch (error) {
            console.error('‚ùå Erreur recherche fichier:', error);
            throw new Error('Impossible de rechercher le fichier sessions');
        }
    },
    
    async loadSessions() {
        const file = await this.findMekongFile();
        if (!file) {
            console.log('üìÑ Aucun fichier sessions trouv√©, retour tableau vide');
            return [];
        }
        
        try {
            const response = await gapi.client.drive.files.get({
                fileId: file.id,
                alt: 'media'
            });
            return JSON.parse(response.body);
        } catch (error) {
            console.error('‚ùå Erreur lecture sessions:', error);
            throw new Error('Impossible de lire le fichier sessions');
        }
    },
    
    async saveSessions(sessions) {
        const file = await this.findMekongFile();
        const content = JSON.stringify(sessions, null, 2);
        
        if (file) {
            try {
                await gapi.client.request({
                    path: `https://www.googleapis.com/upload/drive/v3/files/${file.id}`,
                    method: 'PATCH',
                    params: { uploadType: 'media' },
                    headers: { 'Content-Type': 'application/json' },
                    body: content
                });
                console.log('‚úÖ Sessions mises √† jour dans Google Drive');
            } catch (error) {
                console.error('‚ùå Erreur mise √† jour sessions:', error);
                throw new Error('Impossible de mettre √† jour le fichier sessions');
            }
        } else {
            try {
                await gapi.client.request({
                    path: 'https://www.googleapis.com/upload/drive/v3/files',
                    method: 'POST',
                    params: { uploadType: 'media' },
                    headers: { 'Content-Type': 'application/json' },
                    body: content
                });
                console.log('‚úÖ Nouveau fichier sessions cr√©√© dans Google Drive');
            } catch (error) {
                console.error('‚ùå Erreur cr√©ation sessions:', error);
                throw new Error('Impossible de cr√©er le fichier sessions');
            }
        }
    },

    // ===== NOUVELLES M√âTHODES PHOTOS V0.5.0 =====
    
    /**
     * Trouve le dossier Medias dans Mon Drive/
     */
    async findMediasFolder() {
        try {
            // Chercher directement "Medias" dans la racine (Mon Drive)
            const response = await gapi.client.drive.files.list({
                q: "name='Medias' and mimeType='application/vnd.google-apps.folder' and trashed=false and 'root' in parents",
                fields: 'files(id, name, parents)'
            });
            
            const folders = response.result.files;
            if (folders.length === 0) {
                throw new Error('Dossier "Medias" non trouv√© dans Mon Drive');
            }
            
            console.log(`üìÅ Dossier Medias trouv√©: ${folders[0].id} (${folders[0].name})`);
            return folders[0];
        } catch (error) {
            console.error('‚ùå Erreur recherche dossier Medias:', error);
            throw new Error('Impossible de localiser Mon Drive/Medias');
        }
    },
    
    /**
     * Scan tous les dossiers photos principaux (Medias/photos/)
     */
    async scanPhotoFolders() {
        if (this._photoCache.folders && this._isCacheValid()) {
            console.log('üìã Cache dossiers photos utilis√©');
            return this._photoCache.folders;
        }
        
        try {
            console.log('üîç Scan dossiers photos...');
            
            const mediasFolder = await this.findMediasFolder();
            
            // Chercher le sous-dossier "photos"
            const photosResponse = await gapi.client.drive.files.list({
                q: `name='photos' and '${mediasFolder.id}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
                fields: 'files(id, name)'
            });
            
            if (photosResponse.result.files.length === 0) {
                throw new Error('Sous-dossier "photos" non trouv√©');
            }
            
            const photosFolder = photosResponse.result.files[0];
            
            // Lister tous les sous-dossiers jour
            const dayFoldersResponse = await gapi.client.drive.files.list({
                q: `'${photosFolder.id}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
                fields: 'files(id, name, createdTime)',
                orderBy: 'name'
            });
            
            const folders = dayFoldersResponse.result.files.map(folder => {
                // Parser le nom du dossier - formats accept√©s : "025-Bangkok", "025.Bangkok", "025 Bangkok"
                const matchTiret = folder.name.match(/^(\d+)-(.+)$/);
                const matchPoint = folder.name.match(/^(\d+)\.(.+)$/);
                const matchEspace = folder.name.match(/^(\d+)\s+(.+)$/);
                
                const match = matchTiret || matchPoint || matchEspace;
                
                return {
                    id: folder.id,
                    name: folder.name,
                    dayNumber: match ? parseInt(match[1]) : null,
                    location: match ? match[2] : folder.name,
                    createdTime: folder.createdTime,
                    type: 'day-folder',
                    parsed: !!match // Pour debug
                };
            });
            
            console.log(`üìÅ ${folders.length} dossiers photos trouv√©s`);
            this._photoCache.folders = folders;
            this._photoCache.lastRefresh = Date.now();
            
            return folders;
        } catch (error) {
            console.error('‚ùå Erreur scan dossiers photos:', error);
            throw new Error(`Scan dossiers photos √©chou√©: ${error.message}`);
        }
    },
    
    /**
     * Scan photos Mastodon (media_attachments)
     */
    async scanMastodonPhotos() {
        if (this._photoCache.mastodonPhotos && this._isCacheValid()) {
            console.log('üìã Cache photos Mastodon utilis√©');
            return this._photoCache.mastodonPhotos;
        }
        
        try {
            console.log('üîç Scan photos Mastodon...');
            
            const mediasFolder = await this.findMediasFolder();
            
            // Chercher Medias/Mastodon/
            const mastodonResponse = await gapi.client.drive.files.list({
                q: `name='Mastodon' and '${mediasFolder.id}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
                fields: 'files(id, name)'
            });
            
            if (mastodonResponse.result.files.length === 0) {
                console.log('‚ö†Ô∏è Dossier Mastodon non trouv√©, retour liste vide');
                this._photoCache.mastodonPhotos = [];
                return [];
            }
            
            const mastodonFolder = mastodonResponse.result.files[0];
            
            // Chercher media_attachments/
            const attachmentsResponse = await gapi.client.drive.files.list({
                q: `name='media_attachments' and '${mastodonFolder.id}' in parents and mimeType='application/vnd.google-apps.folder' and trashed=false`,
                fields: 'files(id, name)'
            });
            
            if (attachmentsResponse.result.files.length === 0) {
                console.log('‚ö†Ô∏è Dossier media_attachments non trouv√©');
                this._photoCache.mastodonPhotos = [];
                return [];
            }
            
            const attachmentsFolder = attachmentsResponse.result.files[0];
            
            // Lister toutes les images
            const photosResponse = await gapi.client.drive.files.list({
                q: `'${attachmentsFolder.id}' in parents and trashed=false and (mimeType contains 'image' or name contains '.jpg' or name contains '.png' or name contains '.jpeg' or name contains '.gif')`,
                fields: 'files(id, name, createdTime, size, mimeType, webViewLink)',
                pageSize: 1000
            });
            
            const photos = photosResponse.result.files.map(photo => ({
                id: photo.id,
                name: photo.name,
                createdTime: photo.createdTime,
                size: photo.size,
                mimeType: photo.mimeType,
                webViewLink: photo.webViewLink,
                type: 'mastodon-photo'
            }));
            
            console.log(`üì∏ ${photos.length} photos Mastodon trouv√©es`);
            this._photoCache.mastodonPhotos = photos;
            this._photoCache.lastRefresh = Date.now();
            
            return photos;
        } catch (error) {
            console.error('‚ùå Erreur scan photos Mastodon:', error);
            throw new Error(`Scan photos Mastodon √©chou√©: ${error.message}`);
        }
    },
    
    /**
     * R√©cup√®re photos d'un dossier jour sp√©cifique
     */
    async getPhotosFromDayFolder(folderId) {
        try {
            const response = await gapi.client.drive.files.list({
                q: `'${folderId}' in parents and trashed=false and (mimeType contains 'image' or name contains '.jpg' or name contains '.png' or name contains '.jpeg' or name contains '.gif')`,
                fields: 'files(id, name, createdTime, size, mimeType, webViewLink)',
                orderBy: 'name'
            });
            
            return response.result.files.map(photo => ({
                id: photo.id,
                name: photo.name,
                createdTime: photo.createdTime,
                size: photo.size,
                mimeType: photo.mimeType,
                webViewLink: photo.webViewLink,
                type: 'day-photo'
            }));
        } catch (error) {
            console.error(`‚ùå Erreur lecture photos dossier ${folderId}:`, error);
            return [];
        }
    },
    
    /**
     * Cr√©e l'index unifi√© : jours ‚Üí contenu consolid√©
     */
    async buildContentIndex() {
        if (this._photoCache.contentIndex && this._isCacheValid()) {
            console.log('üìã Cache index contenu utilis√©');
            return this._photoCache.contentIndex;
        }
        
        try {
            console.log('üèóÔ∏è Construction index contenu...');
            
            // R√©cup√©rer les donn√©es existantes
            const posts = Storage.get('mastodonPosts', []);
            const folders = await this.scanPhotoFolders();
            const mastodonPhotos = await this.scanMastodonPhotos();
            
            // Cr√©er l'index par jour
            const index = {};
            
            // 1. Indexer les posts par jour
            posts.forEach(post => {
                if (post.dayNumber) {
                    const key = `day-${post.dayNumber.toString().padStart(3, '0')}`;
                    if (!index[key]) {
                        index[key] = { 
                            dayNumber: post.dayNumber,
                            posts: [],
                            photos: { main: [], mastodon: [] },
                            completeness: 'empty'
                        };
                    }
                    index[key].posts.push(post);
                }
            });
            
            // 2. Indexer les dossiers photos par jour
            for (const folder of folders) {
                if (folder.dayNumber) {
                    const key = `day-${folder.dayNumber.toString().padStart(3, '0')}`;
                    if (!index[key]) {
                        index[key] = {
                            dayNumber: folder.dayNumber,
                            posts: [],
                            photos: { main: [], mastodon: [] },
                            completeness: 'empty'
                        };
                    }
                    
                    // R√©cup√©rer les photos de ce dossier
                    const dayPhotos = await this.getPhotosFromDayFolder(folder.id);
                    index[key].photos.main = dayPhotos;
                    index[key].location = folder.location;
                }
            }
            
            // 3. Associer photos Mastodon aux jours (via metadata posts si possible)
            // Pour l'instant, on les met dans orphans, l'association sera affin√©e plus tard
            
            // 4. Calculer completeness pour chaque jour
            Object.values(index).forEach(dayData => {
                const hasPosts = dayData.posts.length > 0;
                const hasPhotos = dayData.photos.main.length > 0 || dayData.photos.mastodon.length > 0;
                
                if (hasPosts && hasPhotos) {
                    dayData.completeness = 'full';
                } else if (hasPosts || hasPhotos) {
                    dayData.completeness = 'partial';
                } else {
                    dayData.completeness = 'empty';
                }
            });
            
            // 5. G√©rer les orphelins
            const orphanPosts = posts.filter(p => !p.dayNumber);
            const orphanFolders = folders.filter(f => !f.dayNumber);
            
            index['orphans'] = {
                posts: orphanPosts,
                photos: { 
                    main: [], // Sera peupl√© si n√©cessaire
                    mastodon: mastodonPhotos // Toutes les photos Mastodon pour l'instant
                },
                folders: orphanFolders,
                completeness: 'orphan'
            };
            
            console.log(`‚úÖ Index contenu construit: ${Object.keys(index).length - 1} jours + orphelins`);
            this._photoCache.contentIndex = index;
            
            return index;
        } catch (error) {
            console.error('‚ùå Erreur construction index:', error);
            throw new Error(`Construction index √©chou√©e: ${error.message}`);
        }
    },
    
    /**
     * R√©cup√®re l'URL de t√©l√©chargement direct d'une photo
     */
    async getPhotoUrl(photoId) {
        try {
            const response = await gapi.client.drive.files.get({
                fileId: photoId,
                fields: 'webContentLink'
            });
            
            // Convertir en URL d'affichage direct
            const directUrl = response.result.webContentLink?.replace('&export=download', '&export=view') || 
                             `https://drive.google.com/uc?id=${photoId}`;
            
            return directUrl;
        } catch (error) {
            console.error(`‚ùå Erreur r√©cup√©ration URL photo ${photoId}:`, error);
            return null;
        }
    },
    
    /**
     * Helper pour v√©rifier validit√© du cache (5 minutes)
     */
    _isCacheValid() {
        return this._photoCache.lastRefresh && 
               (Date.now() - this._photoCache.lastRefresh) < 5 * 60 * 1000;
    },
    
    /**
     * Force le rafra√Æchissement du cache photos
     */
    async refreshPhotoCache() {
        console.log('üîÑ Rafra√Æchissement cache photos...');
        this._photoCache = {
            folders: null,
            mastodonPhotos: null,
            contentIndex: null,
            lastRefresh: null
        };
        return this.buildContentIndex();
    }
};

// ===== MASTODON DATA =====
const MastodonData = {
    posts: [],
    stats: null,
    
    loadPosts() {
        const stored = Storage.get('mastodonPosts');
        if (stored) {
            this.posts = stored;
            this.updateStats();
            console.log(`üìñ ${this.posts.length} posts Mastodon charg√©s du cache`);
        }
        return this.posts;
    },
    
    savePosts(posts) {
        this.posts = posts;
        Storage.set('mastodonPosts', posts);
        this.updateStats();
        console.log(`üíæ ${posts.length} posts sauvegard√©s`);
    },
    
    updateStats() {
        if (this.posts.length === 0) {
            this.stats = null;
            return;
        }
        
        const postsWithDays = this.posts.filter(p => p.dayNumber);
        const importedAt = Storage.get('mastodonImportedAt');
        
        this.stats = {
            total: this.posts.length,
            withDayNumber: postsWithDays.length,
            withoutDayNumber: this.posts.length - postsWithDays.length,
            dateRange: postsWithDays.length > 0 ? {
                min: Math.min(...postsWithDays.map(p => p.dayNumber)),
                max: Math.max(...postsWithDays.map(p => p.dayNumber))
            } : null,
            importedAt
        };
    }
};

// ===== CLOUD SESSION STORAGE =====
const CloudSessionStorage = {
    async getSessions() {
        try {
            if (!GoogleDriveAPI.isSignedIn) {
                console.log('üì± Pas connect√© au cloud, utilisation cache local');
                return Storage.get('sessions', []);
            }
            
            const cloudSessions = await GoogleDriveAPI.loadSessions();
            if (cloudSessions) {
                Storage.set('sessions', cloudSessions);
                console.log(`‚úÖ ${cloudSessions.length} sessions charg√©es depuis Google Drive`);
                return cloudSessions;
            }
        } catch (error) {
            console.warn('‚ö†Ô∏è Erreur chargement cloud:', error.message);
        }
        return Storage.get('sessions', []);
    },
    
    async saveSession(session) {
        const sessions = Storage.get('sessions', []);
        const existingIndex = sessions.findIndex(s => s.id === session.id);
        
        if (existingIndex >= 0) {
            sessions[existingIndex] = session;
        } else {
            sessions.unshift(session);
        }
        
        Storage.set('sessions', sessions);
        
        if (!GoogleDriveAPI.isSignedIn) {
            console.log('üì± Session sauvegard√©e localement (cloud d√©connect√©)');
            return;
        }
        
        try {
            await GoogleDriveAPI.saveSessions(sessions);
            console.log('‚úÖ Session sauvegard√©e localement + cloud');
        } catch (error) {
            console.warn('‚ö†Ô∏è Erreur sauvegarde cloud:', error.message);
            throw new Error(`Sauvegarde cloud √©chou√©e: ${error.message}. Session sauvegard√©e localement.`);
        }
    },
    
    async deleteSession(sessionId) {
        const sessions = Storage.get('sessions', []).filter(s => s.id !== sessionId);
        Storage.set('sessions', sessions);
        
        if (!GoogleDriveAPI.isSignedIn) {
            console.log('üóëÔ∏è Session supprim√©e localement (cloud d√©connect√©)');
            return;
        }
        
        try {
            await GoogleDriveAPI.saveSessions(sessions);
            console.log('‚úÖ Session supprim√©e localement + cloud');
        } catch (error) {
            console.warn('‚ö†Ô∏è Erreur suppression cloud:', error.message);
            throw new Error(`Suppression cloud √©chou√©e: ${error.message}. Session supprim√©e localement.`);
        }
    }
};

// ===== COMPOSANTS UTILITAIRES =====
const LoadingSpinner = ({ size = 'md', color = 'orange' }) => {
    const sizeClasses = {
        sm: 'w-4 h-4',
        md: 'w-6 h-6', 
        lg: 'w-8 h-8'
    };
    
    const colorClasses = {
        orange: 'border-orange-500',
        blue: 'border-blue-500',
        green: 'border-green-500'
    };
    
    return (
        <div className={`${sizeClasses[size]} ${colorClasses[color]} border-2 border-t-transparent rounded-full animate-spin`}></div>
    );
};

// ===== NOUVEAU COMPOSANT : PHOTO CONTENT INDEX =====
const PhotoContentIndex = () => {
    const [contentIndex, setContentIndex] = React.useState(null);
    const [loading, setLoading] = React.useState(false);
    const [error, setError] = React.useState(null);
    
    // Charger l'index de contenu
    const loadContentIndex = async () => {
        if (!GoogleDriveAPI.isSignedIn) {
            setError('Connexion Google Drive requise');
            return;
        }
        
        setLoading(true);
        setError(null);
        
        try {
            const index = await GoogleDriveAPI.buildContentIndex();
            setContentIndex(index);
            console.log('‚úÖ Index contenu charg√©:', index);
        } catch (err) {
            setError(err.message);
            console.error('‚ùå Erreur chargement index:', err);
        } finally {
            setLoading(false);
        }
    };
    
    React.useEffect(() => {
        if (GoogleDriveAPI.isSignedIn) {
            loadContentIndex();
        }
    }, [GoogleDriveAPI.isSignedIn]);
    
    if (!GoogleDriveAPI.isSignedIn) {
        return (
            <div className="bg-yellow-100 border-l-4 border-yellow-500 p-4 rounded-r">
                <div className="flex items-center">
                    <span className="text-yellow-600">‚ö†Ô∏è Connexion Google Drive requise pour les photos</span>
                </div>
            </div>
        );
    }
    
    if (loading) {
        return (
            <div className="flex items-center justify-center p-8">
                <LoadingSpinner size="lg" />
                <span className="ml-3 text-gray-600">Construction de l'index des photos...</span>
            </div>
        );
    }
    
    if (error) {
        return (
            <div className="bg-red-100 border-l-4 border-red-500 p-4 rounded-r">
                <div className="flex items-center justify-between">
                    <span className="text-red-700">‚ùå {error}</span>
                    <button 
                        onClick={loadContentIndex}
                        className="px-3 py-1 bg-red-500 text-white rounded hover:bg-red-600 text-sm"
                    >
                        R√©essayer
                    </button>
                </div>
            </div>
        );
    }
    
    if (!contentIndex) return null;
    
    // Calculer statistiques
    const days = Object.keys(contentIndex).filter(key => key.startsWith('day-'));
    const stats = {
        totalDays: days.length,
        fullDays: days.filter(day => contentIndex[day].completeness === 'full').length,
        partialDays: days.filter(day => contentIndex[day].completeness === 'partial').length,
        emptyDays: days.filter(day => contentIndex[day].completeness === 'empty').length,
        orphans: contentIndex.orphans
    };
    
    return (
        <div className="space-y-4">
            {/* Header avec stats */}
            <div className="bg-white rounded-lg p-4 border border-orange-200">
                <h3 className="text-lg font-semibold text-orange-800 mb-3">üì∏ Index Photos & Contenu</h3>
                
                <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                    <div className="text-center p-2 bg-green-50 rounded">
                        <div className="text-2xl font-bold text-green-600">{stats.fullDays}</div>
                        <div className="text-green-700">Jours complets</div>
                        <div className="text-xs text-green-600">(posts + photos)</div>
                    </div>
                    
                    <div className="text-center p-2 bg-yellow-50 rounded">
                        <div className="text-2xl font-bold text-yellow-600">{stats.partialDays}</div>
                        <div className="text-yellow-700">Jours partiels</div>
                        <div className="text-xs text-yellow-600">(posts ou photos)</div>
                    </div>
                    
                    <div className="text-center p-2 bg-gray-50 rounded">
                        <div className="text-2xl font-bold text-gray-600">{stats.emptyDays}</div>
                        <div className="text-gray-700">Jours vides</div>
                        <div className="text-xs text-gray-600">(ni posts ni photos)</div>
                    </div>
                    
                    <div className="text-center p-2 bg-purple-50 rounded">
                        <div className="text-2xl font-bold text-purple-600">
                            {(stats.orphans.posts.length + stats.orphans.photos.mastodon.length + stats.orphans.folders.length)}
                        </div>
                        <div className="text-purple-700">Orphelins</div>
                        <div className="text-xs text-purple-600">(sans jour)</div>
                    </div>
                </div>
                
                <button 
                    onClick={() => GoogleDriveAPI.refreshPhotoCache().then(setContentIndex)}
                    className="mt-3 px-3 py-1 bg-orange-500 text-white rounded hover:bg-orange-600 text-sm"
                >
                    üîÑ Actualiser
                </button>
            </div>
            
            {/* Liste d√©taill√©e */}
            <div className="bg-white rounded-lg border border-orange-200">
                <div className="p-4 border-b border-orange-200">
                    <h4 className="font-semibold text-orange-800">D√©tail par jour</h4>
                </div>
                
                <div className="max-h-96 overflow-y-auto">
                    {days.sort().map(dayKey => {
                        const dayData = contentIndex[dayKey];
                        const statusIcon = {
                            'full': 'üü¢',
                            'partial': 'üü°', 
                            'empty': 'üî¥'
                        }[dayData.completeness];
                        
                        return (
                            <div key={dayKey} className="p-3 border-b border-gray-100 hover:bg-orange-50">
                                <div className="flex items-center justify-between">
                                    <div className="flex items-center space-x-3">
                                        <span className="text-lg">{statusIcon}</span>
                                        <div>
                                            <div className="font-medium">Jour {dayData.dayNumber}</div>
                                            {dayData.location && (
                                                <div className="text-sm text-gray-600">{dayData.location}</div>
                                            )}
                                        </div>
                                    </div>
                                    
                                    <div className="flex items-center space-x-4 text-sm text-gray-600">
                                        <span>üìù {dayData.posts.length}</span>
                                        <span>üì∏ {dayData.photos.main.length}</span>
                                        <span>üñºÔ∏è {dayData.photos.mastodon.length}</span>
                                    </div>
                                </div>
                            </div>
                        );
                    })}
                </div>
            </div>
            
            {/* Orphelins */}
            {(stats.orphans.posts.length > 0 || stats.orphans.folders.length > 0 || stats.orphans.photos.mastodon.length > 0) && (
                <div className="bg-purple-50 border border-purple-200 rounded-lg p-4">
                    <h4 className="font-semibold text-purple-800 mb-2">üîç Contenu orphelin</h4>
                    <div className="text-sm text-purple-700">
                        <div>üìù {stats.orphans.posts.length} posts sans num√©ro de jour</div>
                        <div>üìÅ {stats.orphans.folders.length} dossiers sans jour associ√©</div>
                        <div>üñºÔ∏è {stats.orphans.photos.mastodon.length} photos Mastodon</div>
                    </div>
                </div>
            )}
        </div>
    );
};

// ===== COMPOSANT PRINCIPAL (temporaire pour test) =====
const TestApp = () => {
    const [isSignedIn, setIsSignedIn] = React.useState(false);
    const [loading, setLoading] = React.useState(false);
    
    React.useEffect(() => {
        // Initialiser l'API et v√©rifier l'√©tat de connexion
        GoogleDriveAPI.init().then(() => {
            setIsSignedIn(GoogleDriveAPI.isSignedIn);
        });
        
        // Charger les posts Mastodon existants
        MastodonData.loadPosts();
    }, []);
    
    const handleSignIn = async () => {
        setLoading(true);
        try {
            await GoogleDriveAPI.signIn();
            setIsSignedIn(true);
        } catch (error) {
            console.error('Erreur connexion:', error);
        } finally {
            setLoading(false);
        }
    };
    
    const handleSignOut = async () => {
        await GoogleDriveAPI.signOut();
        setIsSignedIn(false);
    };
    
    return (
        <div className="min-h-screen p-4">
            <div className="max-w-4xl mx-auto">
                {/* Header */}
                <div className="bg-white rounded-lg shadow-lg p-6 mb-6">
                    <h1 className="text-2xl font-bold text-orange-800">üì∏ M√©moire du M√©kong V0.5.3</h1>
                    <p className="text-gray-600 mt-1">Parsing adaptatif noms dossiers (point/tiret/espace)</p>
                    
                    <div className="mt-4 flex items-center justify-between">
                        <div className="flex items-center space-x-4">
                            <div className={`w-3 h-3 rounded-full ${isSignedIn ? 'bg-green-500' : 'bg-red-500'}`}></div>
                            <span className={`font-medium ${isSignedIn ? 'text-green-700' : 'text-red-700'}`}>
                                {isSignedIn ? 'Connect√© √† Google Drive' : 'D√©connect√©'}
                            </span>
                        </div>
                        
                        {!isSignedIn ? (
                            <button 
                                onClick={handleSignIn}
                                disabled={loading}
                                className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50 flex items-center space-x-2"
                            >
                                {loading && <LoadingSpinner size="sm" color="blue" />}
                                <span>Se connecter</span>
                            </button>
                        ) : (
                            <button 
                                onClick={handleSignOut}
                                className="px-4 py-2 bg-red-500 text-white rounded hover:bg-red-600"
                            >
                                Se d√©connecter
                            </button>
                        )}
                    </div>
                </div>
                
                {/* Test API Photos avec bon scope */}
                <PhotoContentIndex />
            </div>
        </div>
    );
};

// ===== RENDU =====
const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(<TestApp />);

</script>
</body>
</html>
