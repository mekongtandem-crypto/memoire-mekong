<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üêò M√©moire du M√©kong V0.5.7d : revision affichage des post (r√©ecriture du code) </title>
    
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <script src="https://apis.google.com/js/api.js"></script>
	<script src="https://accounts.google.com/gsi/client"></script>
	<script>
	window.onload = () => {
  		google.accounts.id.initialize({
    		client_id: '82966045106-hso0nr386agcuojllnud0dr41vcsh45a.apps.googleusercontent.com',
    		scope: 'https://www.googleapis.com/auth/drive.readonly' // Ajoutez cette ligne cruciale
  		});
	};
	</script>

    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        .lucide { width: 1em; height: 1em; fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; }
        .fade-in { animation: fadeIn 0.3s ease-in; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
		.pulse-warning { animation: pulseWarning 2s infinite; }
		@keyframes pulseWarning { 
    		0%, 100% { background-color: rgb(254 242 242); border-color: rgb(252 165 165); }
    		50% { background-color: rgb(239 68 68); border-color: rgb(185 28 28); color: white; }
		}
    </style>
</head>
<body>
    <div id="root"></div>

    // D√©claration des ic√¥nes
const { LogOut, Cloud, Menu, BookOpen, User, Sun, Camera, Plus, Trash2, ArrowUpCircle, ArrowDownCircle, ArrowLeftCircle, ArrowRightCircle } = lucide;

// ===== UTILITAIRES ET API =====
const Storage = {
    set: (key, value) => {
        try {
            localStorage.setItem(key, JSON.stringify(value));
        } catch (e) {
            console.error("Error setting item to local storage", e);
        }
    },
    get: (key, defaultValue) => {
        try {
            const value = localStorage.getItem(key);
            return value ? JSON.parse(value) : defaultValue;
        } catch (e) {
            console.error("Error getting item from local storage", e);
            return defaultValue;
        }
    }
};

const GoogleDriveAPI = {
    isSignedIn: false,
    init: async () => {
        await gapi.client.init({
            apiKey: 'AIzaSyDiyLLN4EsyVREGxF4TzqbuKyugaq4TUXw',
            discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest']
        });
        console.log('‚úÖ API initialis√©e');
    },
    signIn: () => {
        return new Promise((resolve) => {
            const tokenClient = google.accounts.oauth2.initTokenClient({
                client_id: '82966045106-hso0nr386agcuojllnud0dr41vcsh45a.apps.googleusercontent.com',
                scope: 'https://www.googleapis.com/auth/drive.readonly profile',
                callback: (tokenResponse) => {
                    if (tokenResponse && tokenResponse.access_token) {
                        gapi.client.setToken({ access_token: tokenResponse.access_token });
                        GoogleDriveAPI.isSignedIn = true;
                        resolve(true);
                    } else {
                        resolve(false);
                    }
                }
            });
            tokenClient.requestAccessToken({ prompt: 'consent' });
        });
    },
    signOut: () => {
        const token = gapi.client.getToken();
        if (token) {
            google.accounts.oauth2.revoke(token.access_token, () => {
                gapi.client.setToken('');
                GoogleDriveAPI.isSignedIn = false;
                console.log('Token r√©voqu√©.');
            });
        }
    },
    _findFile: async (name, parentId = 'root', mimeType = null) => {
        let q = `name='${name}' and '${parentId}' in parents and trashed = false`;
        if (mimeType) {
            q += ` and mimeType='${mimeType}'`;
        }
        try {
            const response = await gapi.client.drive.files.list({
                q: q,
                fields: 'files(id, name, mimeType)'
            });
            return response.result.files.length > 0 ? response.result.files[0] : null;
        } catch (e) {
            console.error(`Erreur lors de la recherche du fichier ${name}:`, e);
            return null;
        }
    },
    listPhotoFiles: async (folderId) => {
        try {
            const response = await gapi.client.drive.files.list({
                q: `'${folderId}' in parents and mimeType contains 'image/' and trashed = false`,
                fields: 'files(id, name, webContentLink, thumbnailLink, mimeType)',
                pageSize: 1000
            });
            return response.result.files;
        } catch (e) {
            console.error(`Erreur lors de la liste des fichiers dans le dossier ${folderId}:`, e);
            throw new Error(`Acc√®s API Drive impossible: ${e.result.error.message}`);
        }
    },
    getFileContent: async (fileId) => {
        try {
            const response = await gapi.client.drive.files.get({
                fileId: fileId,
                alt: 'media'
            });
            return response.body;
        } catch (e) {
            console.error(`Erreur lors du chargement du contenu du fichier ${fileId}:`, e);
            throw e;
        }
    },
};

// ===== DATA MANAGEMENT =====
const MastodonData = {
    _posts: [],
    _stats: null,
    isImported: () => MastodonData._posts.length > 0,
    getStats: () => MastodonData._stats,
    getPostByDay: (dayNumber) => MastodonData._posts.find(p => p.dayNumber === dayNumber),
    decodeHtmlEntities: (text) => {
        const textArea = document.createElement('textarea');
        textArea.innerHTML = text;
        return textArea.value;
    },
    parseOutbox: (jsonData) => {
        try {
            const data = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;
            let orderedItems;
            if (data.orderedItems) {
                orderedItems = data.orderedItems;
            } else if (data.data && data.data.orderedItems) {
                orderedItems = data.data.orderedItems;
            } else {
                throw new Error('Format ActivityPub invalide - orderedItems non trouv√©');
            }

            if (!Array.isArray(orderedItems)) {
                throw new Error('orderedItems n\'est pas un tableau');
            }

            const allPosts = orderedItems
                .filter(item => item.type === 'Create' && item.object?.type === 'Note')
                .map((item, index) => {
                    const note = item.object;
                    const content = note.content || '';
                    const cleanContentHtml = content.replace(/<[^>]*>/g, '');
                    const decodedContent = MastodonData.decodeHtmlEntities(cleanContentHtml);
                    const dayMatch = decodedContent.match(/^J(\d{1,3})[\s:]/);
                    const dayNumber = dayMatch ? parseInt(dayMatch[1]) : null;
                    const hasJourNumber = dayNumber !== null;
                    let title = '';
                    let postContent = decodedContent;

                    if (hasJourNumber) {
                        const afterJour = decodedContent.replace(/^J\d{1,3}[\s:]+/, '');
                        const lines = afterJour.split('\n').filter(line => line.trim() !== '');
                        if (lines.length > 0) {
                            title = lines[0].trim().replace(/[#]/g, '');
                            if (lines.length > 1) {
                                postContent = lines.slice(1).join('\n').trim();
                            } else {
                                postContent = '';
                            }
                        }
                    } else {
                        const lines = decodedContent.split('\n').filter(line => line.trim() !== '');
                        if (lines.length > 0) {
                            title = lines[0].trim();
                            if (lines.length > 1) {
                                postContent = lines.slice(1).join('\n').trim();
                            } else {
                                postContent = '';
                            }
                        }
                    }
                    title = title.replace(/[‚õ©Ô∏èü¶©‚úàÔ∏èüá®üáµüî•‚ö°üåüüéØüí™üöÄ‚ú®üéâüéäüéàüéÅüéÄüéáüéÜ]/g, '').replace(/\s+/g, ' ').trim();

                    return {
                        id: note.id || `post-${index}`,
                        dayNumber,
                        hasJourNumber,
                        title: title || 'Post sans titre',
                        content: postContent,
                        published: note.published || item.published,
                        attachments: note.attachment || [],
                        url: note.url,
                        originalIndex: index
                    };
                });

            const postsWithDay = allPosts.filter(post => post.hasJourNumber);
            const postsWithoutDay = allPosts.filter(post => !post.hasJourNumber);

            postsWithDay.sort((a, b) => a.dayNumber - b.dayNumber);

            const maxDayNumber = postsWithDay.length > 0 ? Math.max(...postsWithDay.map(p => p.dayNumber)) : 0;
            postsWithoutDay.forEach((post, index) => {
                post.dayNumber = maxDayNumber + index + 1;
                post.isExtraPost = true;
            });

            const finalPosts = [...postsWithDay, ...postsWithoutDay];

            finalPosts.forEach(post => {
                delete post.hasJourNumber;
                delete post.originalIndex;
            });

            MastodonData._posts = finalPosts;
            MastodonData._stats = {
                dayRange: finalPosts.length > 0 ? { min: finalPosts[0].dayNumber, max: finalPosts[finalPosts.length - 1].dayNumber } : null,
                postCount: finalPosts.length,
                withDayCount: postsWithDay.length,
                withoutDayCount: postsWithoutDay.length
            };

            console.log(`‚úÖ ${finalPosts.length} posts Mastodon import√©s`);
            return MastodonData._posts;
        } catch (error) {
            console.error('‚ùå Erreur parsing outbox:', error);
            throw error;
        }
    },
};

const PhotoData = {
    _index: null,
    isImported: () => PhotoData._index !== null,
    getIndex: () => PhotoData._index,
    getPhotosByDay: (dayNumber) => {
        if (!PhotoData._index || !PhotoData._index.photos) return [];
        return PhotoData._index.photos.filter(p => p.day === dayNumber);
    },
    parsePhotoIndex: (jsonData) => {
        try {
            const data = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;
            if (!data.photos) {
                throw new Error('Index des photos invalide');
            }
            const normalizedPhotos = data.photos.map(p => {
                const dayMatch = p.folder.match(/^J(\d+)/);
                return {
                    day: dayMatch ? parseInt(dayMatch[1]) : 0,
                    filename: p.filename,
                    folderName: p.folder,
                    id: p.id // Ajout de l'ID pour r√©f√©rence future
                };
            });
            PhotoData._index = {
                metadata: data.metadata,
                allPhotos: normalizedPhotos
            };
            console.log(`‚úÖ ${normalizedPhotos.length} photos import√©es depuis l'index`);
            return PhotoData._index;
        } catch (error) {
            console.error('‚ùå Erreur parsing index photo:', error);
            throw error;
        }
    },
};

// ===== HOOKS =====
const useGoogleAuth = () => {
    const [isConnected, setIsConnected] = React.useState(false);
    const [isLoading, setIsLoading] = React.useState(true);
    const [userInfo, setUserInfo] = React.useState(null);
    const [connectionMode, setConnectionMode] = React.useState('checking');
    const [lastConnectionError, setLastConnectionError] = React.useState(null);

    const forceDisconnect = React.useCallback((reason) => {
        console.log('üî¥ D√©connexion forc√©e:', reason);
        setIsConnected(false);
        setConnectionMode('disconnected');
        setLastConnectionError(reason);
        GoogleDriveAPI.isSignedIn = false;
        
        const token = gapi.client.getToken();
        if (token) {
            google.accounts.oauth2.revoke(token.access_token);
            gapi.client.setToken('');
        }
    }, []);

    React.useEffect(() => {
        const initGoogle = async () => {
            setIsLoading(true);
            setConnectionMode('checking');
            
            try {
                await GoogleDriveAPI.init();
                const token = gapi.client.getToken();
                if (token) {
                    try {
                        await gapi.client.drive.files.list({ pageSize: 1 });
                        const response = await fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
                            headers: { 'Authorization': `Bearer ${token.access_token}` }
                        });
                        if (response.ok) {
                            const profile = await response.json();
                            setUserInfo(profile);
                            setIsConnected(true);
                            GoogleDriveAPI.isSignedIn = true;
                            setConnectionMode('connected');
                            setLastConnectionError(null);
                            console.log('‚úÖ Reconnexion automatique r√©ussie');
                        } else {
                            throw new Error('Token invalide');
                        }
                    } catch (error) {
                        console.log('‚ö†Ô∏è Token expir√© ou invalide:', error.message);
                        gapi.client.setToken('');
                        setConnectionMode('disconnected');
                        setLastConnectionError('Token expir√©');
                    }
                } else {
                    setConnectionMode('disconnected');
                }
            } catch (error) {
                console.error('Erreur init Google:', error);
                setConnectionMode('disconnected');
                setLastConnectionError(error.message);
            } finally {
                setIsLoading(false);
            }
        };
        initGoogle();
    }, [forceDisconnect]);

    const signIn = async () => {
        setIsLoading(true);
        setLastConnectionError(null);

        try {
            const success = await GoogleDriveAPI.signIn();
            if (success) {
                const token = gapi.client.getToken();
                const response = await fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
                    headers: { 'Authorization': `Bearer ${token.access_token}` }
                });
                if (!response.ok) {
                    throw new Error('Impossible de r√©cup√©rer le profil utilisateur');
                }
                const profile = await response.json();
                setUserInfo(profile);
                setIsConnected(true);
                setConnectionMode('connected');
                setLastConnectionError(null);
                console.log('Connexion r√©ussie:', profile.name);
                return true;
            } else {
                throw new Error('√âchec de la connexion Google Drive');
            }
        } catch (error) {
            console.error('Erreur connexion:', error);
            setIsConnected(false);
            setUserInfo(null);
            setConnectionMode('disconnected');
            setLastConnectionError(error.message);
            return { success: false, error: error.message };
        } finally {
            setIsLoading(false);
        }
    };

    const signOut = async () => {
        setIsLoading(true);
        try {
            const token = gapi.client.getToken();
            if (token) {
                google.accounts.oauth2.revoke(token.access_token);
                gapi.client.setToken('');
            }
            GoogleDriveAPI.isSignedIn = false;
            setIsConnected(false);
            setUserInfo(null);
            setConnectionMode('disconnected');
            setLastConnectionError(null);
            console.log('‚úÖ D√©connexion r√©ussie');
        } catch (error) {
            console.error('‚ùå Erreur d√©connexion:', error);
            setLastConnectionError(error.message);
        } finally {
            setIsLoading(false);
        }
    };

    const testConnection = React.useCallback(async () => {
        if (!isConnected) return false;
        try {
            await gapi.client.drive.files.list({ pageSize: 1 });
            return true;
        } catch (error) {
            console.log('üî¥ Test de connexion √©chou√©:', error.message);
            forceDisconnect('Test de connexion √©chou√©');
            return false;
        }
    }, [isConnected, forceDisconnect]);

    return { 
        isConnected, 
        isLoading, 
        userInfo, 
        connectionMode,
        lastConnectionError,
        signIn, 
        signOut,
        forceDisconnect,
        testConnection
    };
};

// ===== COMPOSANTS DE BASE =====
const LoadingSpinner = ({ message = "Chargement...", size = "large" }) => {
    const sizeClasses = { large: "w-16 h-16", medium: "w-8 h-8", small: "w-6 h-6" };
    const spinnerClass = sizeClasses[size] || sizeClasses.large;
    return (
        <div className="flex flex-col items-center justify-center p-8 text-center text-gray-500">
            <svg className={`animate-spin ${spinnerClass} text-amber-500`} xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <p className="mt-3 text-sm font-semibold">{message}</p>
        </div>
    );
};

const Header = ({ onMenuClick }) => (
    <header className="flex items-center justify-between p-4 bg-amber-500 text-white shadow-lg">
        <h1 className="text-xl font-bold">M√©moire du M√©kong</h1>
        <button onClick={onMenuClick} className="p-2">
            <Menu className="w-6 h-6" />
        </button>
    </header>
);

const BottomNavBar = ({ currentPage, onPageChange, currentUser }) => (
    <nav className="fixed bottom-0 left-0 right-0 bg-white shadow-2xl p-2 flex justify-around text-gray-500">
        <button onClick={() => onPageChange('memories')} className={`flex flex-col items-center p-2 text-xs font-semibold ${currentPage === 'memories' ? 'text-amber-500' : ''}`}>
            <BookOpen className="w-6 h-6 mb-1" />
            M√©moires
        </button>
        <button onClick={() => onPageChange('home')} className={`flex flex-col items-center p-2 text-xs font-semibold ${currentPage === 'home' ? 'text-amber-500' : ''}`}>
            <Cloud className="w-6 h-6 mb-1" />
            Accueil
        </button>
        <button onClick={() => onPageChange('users')} className={`flex flex-col items-center p-2 text-xs font-semibold ${currentPage === 'users' ? 'text-amber-500' : ''}`}>
            <div className="relative">
                {currentUser && currentUser.picture && (
                    <img src={currentUser.picture} alt="Profil" className="w-6 h-6 rounded-full" />
                )}
                {!currentUser && <User className="w-6 h-6" />}
            </div>
            <span>Profil</span>
        </button>
    </nav>
);

const Toast = ({ message, type, onDismiss }) => {
    if (!message) return null;
    const colorClasses = type === 'success' ? 'bg-green-500' : 'bg-red-500';
    return (
        <div className={`fixed bottom-20 left-1/2 -translate-x-1/2 p-4 rounded-lg text-white shadow-xl ${colorClasses} z-50`}>
            {message}
        </div>
    );
};

// ===== COMPOSANT: Timeline (Horizontal) =====
const Timeline = ({ currentDay, maxDay, onDaySelect }) => {
    const days = Array.from({ length: maxDay }, (_, i) => i + 1);
    const scrollRef = React.useRef(null);

    React.useEffect(() => {
        if (scrollRef.current) {
            const element = scrollRef.current;
            const dayWidth = 50; // Approximativement la largeur d'un jour + padding
            const scrollPosition = (currentDay - 1) * dayWidth - element.clientWidth / 2;
            element.scrollTo({
                left: scrollPosition,
                behavior: 'smooth'
            });
        }
    }, [currentDay]);

    return (
        <div className="flex items-center space-x-2 overflow-x-auto p-2 hide-scrollbar bg-gray-100 rounded-lg shadow-inner" ref={scrollRef}>
            <style jsx>{`
                .hide-scrollbar::-webkit-scrollbar { display: none; }
                .hide-scrollbar { -ms-overflow-style: none; scrollbar-width: none; }
            `}</style>
            {days.map(day => (
                <button
                    key={day}
                    onClick={() => onDaySelect(day)}
                    className={`flex-shrink-0 w-12 h-12 flex flex-col items-center justify-center p-1 rounded-full text-sm font-semibold transition-colors duration-200 ${
                        day === currentDay ? 'bg-amber-500 text-white shadow-md transform scale-110' : 'bg-white text-gray-700 hover:bg-gray-200'
                    }`}
                >
                    J{day}
                </button>
            ))}
        </div>
    );
};

// ===== COMPOSANT PHOTOGRID (GRILLE PHOTOS) =====
const PhotoGrid = ({ photos, onPhotoSelect, className = "" }) => {
    if (!photos || photos.length === 0) {
        return (
            <div className="text-center py-12 text-gray-500">
                <Camera className="w-12 h-12 mx-auto mb-3 opacity-30" />
                <p>Aucune photo trouv√©e pour ce jour.</p>
            </div>
        );
    }
    return (
        <div className={`grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4 ${className}`}>
            {photos.map((photo, index) => (
                <div key={photo.id || index} className="relative aspect-square overflow-hidden rounded-lg shadow-md cursor-pointer transition-transform duration-200 hover:scale-105" onClick={() => onPhotoSelect(index)}>
                    <img
                        src={photo.thumbnailLink}
                        alt={photo.filename}
                        className="w-full h-full object-cover"
                        loading="lazy"
                    />
                </div>
            ))}
        </div>
    );
};

// NOUVEAU: COMPOSANT MastodonPostViewer
const MastodonPostViewer = ({ post, photos, isLoadingPhotos, onCreateSession }) => {
    if (!post) {
        return (
            <div className="text-center py-12 text-gray-500">
                <BookOpen className="w-12 h-12 mx-auto mb-3 opacity-30" />
                <p>Aucun post de blog pour ce jour.</p>
            </div>
        );
    }

    const hasPhotos = photos && photos.length > 0;
    
    return (
        <div className="space-y-6">
            <div className="flex justify-between items-start">
                <h3 className="text-2xl font-bold text-amber-900 pr-4">
                    Jour {post.dayNumber} : {post.title}
                </h3>
                <button onClick={onCreateSession} className="flex-shrink-0 flex items-center space-x-2 px-3 py-2 bg-green-500 text-white rounded-lg text-sm">
                    <Plus className="w-4 h-4" />
                    <span>Session</span>
                </button>
            </div>
            
            <div className="prose max-w-none text-gray-700">
                <p>{post.content}</p>
            </div>
            
            <div className="flex items-center space-x-2 text-gray-500 text-sm">
                <Cloud className="w-4 h-4" />
                <span>Publi√© sur Mastodon le {new Date(post.published).toLocaleDateString('fr-FR')}</span>
            </div>
            
            {/* Encadr√© pour les photos du post */}
            {isLoadingPhotos ? (
                 <LoadingSpinner message="Chargement des photos du post..." size="small" />
            ) : hasPhotos ? (
                <div className="border border-gray-200 rounded-lg p-4 bg-gray-50 space-y-4">
                    <h4 className="font-semibold text-gray-800 flex items-center space-x-2">
                        <Camera className="w-5 h-5 text-gray-600" />
                        <span>Photos associ√©es ({photos.length})</span>
                    </h4>
                    <PhotoGrid photos={photos} onPhotoSelect={() => {}} /> 
                </div>
            ) : null}
            
        </div>
    );
};

// COMPOSANT: PhotoViewer avec base64 pour grand format
const PhotoViewer = ({ photos, selectedIndex, onClose, onNavigate, onCreateSession }) => {
    const photo = photos[selectedIndex];
    if (!photo) return null;

    return (
        <div className="fixed inset-0 bg-black bg-opacity-90 flex flex-col items-center justify-center p-4 z-50">
            <div className="relative w-full max-w-4xl h-full flex flex-col items-center justify-center">
                <button onClick={onClose} className="absolute top-4 right-4 p-2 text-white bg-black bg-opacity-50 rounded-full z-10">
                    <LogOut className="w-6 h-6" />
                </button>
                <div className="relative w-full h-full flex items-center justify-center">
                    <img src={photo.webContentLink} alt={photo.filename} className="max-w-full max-h-full object-contain rounded-lg shadow-lg" />
                </div>
                <div className="absolute bottom-4 left-0 right-0 flex items-center justify-center space-x-4 text-white">
                    <button onClick={() => onNavigate('prev')} disabled={selectedIndex === 0} className="p-2 bg-black bg-opacity-50 rounded-full disabled:opacity-30">
                        <ArrowLeftCircle className="w-8 h-8" />
                    </button>
                    <button onClick={() => onCreateSession(photo)} className="p-2 bg-green-500 rounded-lg text-sm font-semibold">
                        <Plus className="w-5 h-5 inline mr-1" /> Cr√©er une session
                    </button>
                    <button onClick={() => onNavigate('next')} disabled={selectedIndex === photos.length - 1} className="p-2 bg-black bg-opacity-50 rounded-full disabled:opacity-30">
                        <ArrowRightCircle className="w-8 h-8" />
                    </button>
                </div>
            </div>
        </div>
    );
};

// Page d'accueil
const HomePage = ({ onImport, importState, authState, onGoogleDisconnect }) => (
    <div className="p-4 space-y-6 fade-in">
        <h2 className="text-3xl font-bold text-gray-800">Commencer l'aventure</h2>
        <div className="bg-white p-6 rounded-lg shadow-md space-y-4 text-center">
            {authState.connectionMode === 'connected' && (
                <div className="flex flex-col items-center space-y-4">
                    <div className="flex items-center space-x-2 text-green-600">
                        <Sun className="w-6 h-6" />
                        <span className="font-semibold">Connect√© √† Google Drive</span>
                    </div>
                    <p className="text-sm text-gray-600">Les fichiers sont pr√™ts √† √™tre import√©s.</p>
                </div>
            )}
            {authState.connectionMode === 'disconnected' && (
                <div className="flex flex-col items-center space-y-4">
                    <div className="flex items-center space-x-2 text-red-600">
                        <LogOut className="w-6 h-6" />
                        <span className="font-semibold">D√©connect√© de Google Drive</span>
                    </div>
                    <p className="text-sm text-gray-600">Vous devez vous reconnecter pour importer les donn√©es.</p>
                </div>
            )}
            {authState.connectionMode === 'checking' && (
                <LoadingSpinner message="V√©rification de la connexion..." size="medium" />
            )}
            
            <button
                onClick={() => onImport('all')}
                className={`w-full py-3 px-4 rounded-lg font-semibold text-white transition-colors duration-200 ${
                    authState.isConnected ? 'bg-amber-500 hover:bg-amber-600' : 'bg-gray-400 cursor-not-allowed'
                }`}
                disabled={!authState.isConnected || importState.isImporting}
            >
                {importState.isImporting ? <LoadingSpinner message="" size="small" /> : "Importer toutes les donn√©es"}
            </button>
            <div className="space-y-2">
                <p className="text-sm font-semibold text-gray-700">Statut de l'import :</p>
                <p className="text-xs text-gray-500">Mastodon : {importState.mastodon.status}</p>
                <p className="text-xs text-gray-500">Photos : {importState.photos.status}</p>
                {importState.lastError && (
                    <div className="text-red-500 text-xs">
                        <p>Erreur: {importState.lastError.message}</p>
                    </div>
                )}
            </div>
        </div>
        <div className="text-center pt-4">
            <button onClick={onGoogleDisconnect} className="text-sm text-gray-500 hover:text-red-500 transition-colors duration-200">
                Se d√©connecter
            </button>
        </div>
    </div>
);

// Page Utilisateur
const UsersPage = ({ currentUser, onUserChange, onPageChange }) => (
    <div className="p-4 space-y-6 fade-in">
        <h2 className="text-3xl font-bold text-gray-800">Profil de l'utilisateur</h2>
        <div className="bg-white p-6 rounded-lg shadow-md space-y-4 text-center">
            {currentUser ? (
                <div className="flex flex-col items-center">
                    <img src={currentUser.picture} alt="Profil" className="w-24 h-24 rounded-full mb-4 shadow-md" />
                    <h3 className="text-xl font-bold text-gray-800">{currentUser.name}</h3>
                    <p className="text-sm text-gray-500">{currentUser.email}</p>
                    <button onClick={() => { onUserChange(null); onPageChange('home'); }} className="mt-4 px-4 py-2 bg-red-500 text-white rounded-lg text-sm font-semibold">
                        D√©connexion
                    </button>
                </div>
            ) : (
                <p className="text-sm text-gray-500">Aucun utilisateur connect√©.</p>
            )}
        </div>
    </div>
);

// Page Memoire (V4.1 - CORRECTION APPELS API)
const MemoriesPage = ({ currentUser, onCreateSession, isCreatingSession }) => {
    const [currentDay, setCurrentDay] = React.useState(1);
    const [activeTab, setActiveTab] = React.useState('blog');
    const [currentPost, setCurrentPost] = React.useState(null);
    const [dayPhotos, setDayPhotos] = React.useState([]);
    const [isLoadingPhotos, setIsLoadingPhotos] = React.useState(false);
    const [selectedPhotoIndex, setSelectedPhotoIndex] = React.useState(null);
    
    const isMastodonImported = MastodonData.isImported();
    const mastodonStats = MastodonData.getStats();
    const isPhotoIndexImported = PhotoData.isImported();
    
    const [postPhotos, setPostPhotos] = React.useState([]);
    const [isLoadingPostPhotos, setIsLoadingPostPhotos] = React.useState(false);

    React.useEffect(() => {
        const loadDataForDay = async () => {
            let hasContent = false;
            if (isMastodonImported) {
                const post = MastodonData.getPostByDay(currentDay);
                setCurrentPost(post);
                if (post) {
                    hasContent = true;
                    await loadPostPhotos(post);
                } else {
                    setPostPhotos([]);
                }
            } else {
                setCurrentPost(null);
            }

            if (isPhotoIndexImported) {
                const photosInIndex = PhotoData.getPhotosByDay(currentDay);
                if (photosInIndex.length > 0) {
                    hasContent = true;
                    await loadPhotosForDay(currentDay);
                } else {
                    setDayPhotos([]);
                }
            }
            if (!hasContent) setDayPhotos([]);
        };
        loadDataForDay();
    }, [currentDay, isMastodonImported, isPhotoIndexImported]);

    const cleanThumbnailLink = (url) => {
        if (!url) return null;
        return url.split('=')[0];
    };
    
    const loadPostPhotos = async (post) => {
        setIsLoadingPostPhotos(true);
        setPostPhotos([]);
        
        if (!post?.attachments || post.attachments.length === 0) {
            setIsLoadingPostPhotos(false);
            return;
        }

        let allFoundPhotos = [];
        for (const attachment of post.attachments) {
            if (attachment.url) {
                const filename = attachment.url.split('/').pop();
                const photoEntry = PhotoData.getIndex()?.allPhotos.find(p => p.filename === filename);
                
                if (photoEntry) {
                     const mediasFolder = await GoogleDriveAPI._findFile('Medias', 'root', 'application/vnd.google-apps.folder');
                     const photosRootFolder = await GoogleDriveAPI._findFile('Photos', mediasFolder.id, 'application/vnd.google-apps.folder');
                     const dayFolder = await GoogleDriveAPI._findFile(photoEntry.folderName, photosRootFolder.id, 'application/vnd.google-apps.folder');
                     if (dayFolder) {
                        const filesInDrive = await GoogleDriveAPI.listPhotoFiles(dayFolder.id);
                        const fileData = filesInDrive.find(f => f.name === filename);
                        if(fileData) {
                            allFoundPhotos.push({
                                id: fileData.id,
                                filename: filename,
                                webContentLink: fileData.webContentLink,
                                thumbnailLink: cleanThumbnailLink(fileData.thumbnailLink),
                                mimeType: fileData.mimeType || 'image/jpeg'
                            });
                        }
                     }
                }
            }
        }
        setPostPhotos(allFoundPhotos);
        setIsLoadingPostPhotos(false);
    };

    const loadPhotosForDay = async (day) => {
        setIsLoadingPhotos(true);
        setDayPhotos([]);
        
        const photoIndexEntries = PhotoData.getPhotosByDay(day);
        if (photoIndexEntries.length === 0) {
            setIsLoadingPhotos(false);
            return;
        }

        const foldersToQuery = photoIndexEntries.reduce((acc, photo) => {
            if (!acc[photo.folderName]) acc[photo.folderName] = [];
            acc[photo.folderName].push(photo.filename);
            return acc;
        }, {});

        let allFoundPhotos = [];
        const FOLDER_MIME_TYPE = 'application/vnd.google-apps.folder';

        const mediasFolder = await GoogleDriveAPI._findFile('Medias', 'root', FOLDER_MIME_TYPE);
        if (!mediasFolder) { setIsLoadingPhotos(false); return; }
        const photosRootFolder = await GoogleDriveAPI._findFile('Photos', mediasFolder.id, FOLDER_MIME_TYPE);
        if (!photosRootFolder) { setIsLoadingPhotos(false); return; }

        for (const folderName in foldersToQuery) {
            const dayFolder = await GoogleDriveAPI._findFile(folderName, photosRootFolder.id, FOLDER_MIME_TYPE);
            if (dayFolder) {
                const filesInDrive = await GoogleDriveAPI.listPhotoFiles(dayFolder.id);
                const driveFilesMap = new Map(filesInDrive.map(file => [file.name, file]));
                
                const photosInThisFolder = foldersToQuery[folderName];
                for (const filename of photosInThisFolder) {
                    if (driveFilesMap.has(filename)) {
                        const fileData = driveFilesMap.get(filename);
                        allFoundPhotos.push({
                            id: fileData.id,
                            filename: filename,
                            webContentLink: fileData.webContentLink,
                            thumbnailLink: cleanThumbnailLink(fileData.thumbnailLink),
                            mimeType: fileData.mimeType || 'image/jpeg'
                        });
                    }
                }
            }
        }
        setDayPhotos(allFoundPhotos);
        setIsLoadingPhotos(false);
    };

    const handleDaySelect = (day) => setCurrentDay(day);
    const createSessionFromPost = (post) => { const game = getGameById(7); const postPreview = post.content.slice(0, 200) + '...'; onCreateSession({ type: 'game', game: { ...game, title: `Jour ${post.dayNumber} - ${post.title || 'Souvenir'}` }, postContent: postPreview }); };
    const createSessionFromPhoto = (photo) => { const game = { id: 1, title: `Souvenir photo du jour ${photo.day}` }; const initialNoteContent = `[IMAGE]${photo.webContentLink}[/IMAGE]\n\n√Ä propos de cette photo : ${photo.filename}`; onCreateSession({ type: 'game', game: game, postContent: initialNoteContent }); };
    const handlePhotoSelect = (index) => setSelectedPhotoIndex(index);
	const handlePhotoNavigate = (direction) => { if (direction === 'prev' && selectedPhotoIndex > 0) setSelectedPhotoIndex(selectedPhotoIndex - 1); else if (direction === 'next' && selectedPhotoIndex < dayPhotos.length - 1) setSelectedPhotoIndex(selectedPhotoIndex + 1); };
    
    if (isCreatingSession) return <LoadingSpinner message="Cr√©ation de session..." size="large" />;
    
    return (
        <div className="space-y-6 fade-in">
            <Timeline currentDay={currentDay} maxDay={mastodonStats?.dayRange?.max || 275} onDaySelect={handleDaySelect} />
            <div className="flex justify-center border-b border-gray-200">
                <button onClick={() => setActiveTab('blog')} className={`px-6 py-3 text-sm font-semibold ${activeTab === 'blog' ? 'border-b-2 border-amber-500 text-amber-600' : 'text-gray-500'}`} disabled={!isMastodonImported}><BookOpen className="w-5 h-5 inline mr-2"/>Blog</button>
                <button onClick={() => setActiveTab('photos')} className={`px-6 py-3 text-sm font-semibold ${activeTab === 'photos' ? 'border-b-2 border-amber-500 text-amber-600' : 'text-gray-500'}`} disabled={!isPhotoIndexImported}><Camera className="w-5 h-5 inline mr-2"/>Photos</button>
            </div>
            <div className="bg-white p-4 sm:p-6 rounded-lg border border-gray-200 min-h-[300px]">
                {activeTab === 'photos' ? (
                    isLoadingPhotos ? <LoadingSpinner message="Chargement des photos..." /> : <PhotoGrid photos={dayPhotos} onPhotoSelect={handlePhotoSelect} />
                ) : (
                    <MastodonPostViewer 
                        post={currentPost} 
                        photos={postPhotos}
                        isLoadingPhotos={isLoadingPostPhotos}
                        onCreateSession={() => createSessionFromPost(currentPost)}
                    />
                )}
            </div>
            {selectedPhotoIndex !== null && <PhotoViewer photos={dayPhotos} selectedIndex={selectedPhotoIndex} onClose={() => setSelectedPhotoIndex(null)} onNavigate={handlePhotoNavigate} onCreateSession={createSessionFromPhoto} />}
        </div>
    );
};

// Page de session de jeu
const getGameById = (id) => {
    return { id: id, title: "R√©cit d'Aventure" };
};

// Application principale
const MemoireMekong = () => {
    const [currentPage, setCurrentPage] = React.useState('home');
    const [currentUser, setCurrentUser] = React.useState(null);
    const [toast, setToast] = React.useState({ message: '', type: '' });
    const [isCreatingSession, setIsCreatingSession] = React.useState(false);

    const authState = useGoogleAuth();
    const [importState, setImportState] = React.useState({
        isImporting: false,
        mastodon: { status: 'non import√©' },
        photos: { status: 'non import√©' },
        lastError: null,
    });
    
    const handleGoogleConnect = async () => {
        const success = await authState.signIn();
        if (success) {
            setToast({ message: "Connexion r√©ussie", type: 'success' });
            setCurrentUser(authState.userInfo);
            setCurrentPage('home');
        } else {
            setToast({ message: "√âchec de la connexion", type: 'error' });
        }
    };

    const handleGoogleDisconnect = async () => {
        await authState.signOut();
        setCurrentUser(null);
        setToast({ message: "D√©connexion r√©ussie", type: 'success' });
        setImportState({
            isImporting: false,
            mastodon: { status: 'non import√©' },
            photos: { status: 'non import√©' },
            lastError: null,
        });
        setCurrentPage('home');
    };

    const handleImportData = async (type) => {
        setImportState({ ...importState, isImporting: true, lastError: null });
        try {
            if (type === 'all' || type === 'mastodon') {
                setImportState(prev => ({ ...prev, mastodon: { status: 'import en cours...' } }));
                const outboxFile = await GoogleDriveAPI._findFile('outbox.json');
                if (!outboxFile) {
                    throw new Error('Fichier outbox.json introuvable');
                }
                const outboxContent = await GoogleDriveAPI.getFileContent(outboxFile.id);
                MastodonData.parseOutbox(outboxContent);
                setImportState(prev => ({ ...prev, mastodon: { status: 'import√©' } }));
            }
            if (type === 'all' || type === 'photos') {
                setImportState(prev => ({ ...prev, photos: { status: 'import en cours...' } }));
                const photoIndexFile = await GoogleDriveAPI._findFile('photo_index.json');
                if (!photoIndexFile) {
                    throw new Error('Fichier photo_index.json introuvable');
                }
                const photoIndexContent = await GoogleDriveAPI.getFileContent(photoIndexFile.id);
                PhotoData.parsePhotoIndex(photoIndexContent);
                setImportState(prev => ({ ...prev, photos: { status: 'import√©' } }));
            }
            setToast({ message: "Importation des donn√©es termin√©e", type: 'success' });
            setCurrentPage('memories');
        } catch (error) {
            console.error('Erreur lors de l\'importation:', error);
            setImportState(prev => ({ ...prev, lastError: error }));
            setToast({ message: "Erreur lors de l'importation", type: 'error' });
        } finally {
            setImportState(prev => ({ ...prev, isImporting: false }));
        }
    };
    
    const handleCreateSession = (sessionData) => {
        setIsCreatingSession(true);
        // Simuler une session de jeu cr√©√©e
        setTimeout(() => {
            console.log("Session cr√©√©e:", sessionData);
            setIsCreatingSession(false);
            setToast({ message: "Session de jeu cr√©√©e!", type: 'success' });
            setCurrentPage('home');
        }, 1500);
    };

    React.useEffect(() => {
        if (authState.connectionMode === 'connected' && !currentUser) {
            setCurrentUser(authState.userInfo);
        }
        if (authState.connectionMode === 'disconnected' && currentUser) {
            setCurrentUser(null);
        }
    }, [authState, currentUser]);
    
    return (
        <div className="min-h-screen bg-gray-100 font-sans antialiased text-gray-800 pb-20">
            <Header onMenuClick={() => {}} />
            <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
                <div className="bg-white rounded-lg shadow-xl overflow-hidden">
                    <div className="p-4 sm:p-6 lg:p-8">
                        {authState.isLoading && <LoadingSpinner message="Connexion en cours..." />}
                        {authState.lastConnectionError && (
                            <div className="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded relative mb-4" role="alert">
                                <strong className="font-bold">Erreur de connexion:</strong>
                                <span className="block sm:inline ml-2">{authState.lastConnectionError}</span>
                            </div>
                        )}
                        {authState.connectionMode === 'disconnected' && !authState.isLoading && (
                            <div className="flex flex-col items-center justify-center p-8 text-center">
                                <Cloud className="w-16 h-16 text-gray-400 mb-4" />
                                <h2 className="text-xl font-semibold mb-2">Connectez-vous pour commencer</h2>
                                <p className="text-sm text-gray-500 mb-4">
                                    Veuillez vous connecter √† votre compte Google pour acc√©der √† vos donn√©es.
                                </p>
                                <button onClick={handleGoogleConnect} className="px-6 py-3 bg-amber-500 text-white rounded-lg font-semibold shadow-lg hover:bg-amber-600 transition-colors duration-200">
                                    Se connecter avec Google
                                </button>
                            </div>
                        )}
                        {authState.connectionMode === 'connected' && !authState.isLoading && (
                            <React.Fragment>
                                {currentPage === 'home' && (
                                    <HomePage 
                                        onImport={handleImportData} 
                                        importState={importState}
                                        authState={authState}
                                        onGoogleDisconnect={handleGoogleDisconnect}
                                    />
                                )}
                                {currentPage === 'memories' && (
                                    <MemoriesPage
                                        currentUser={currentUser}
                                        onCreateSession={handleCreateSession}
                                        isCreatingSession={isCreatingSession}
                                    />
                                )}
                                {currentPage === 'users' && (
                                    <UsersPage 
                                        currentUser={currentUser}
                                        onUserChange={setCurrentUser}
                                        onPageChange={setCurrentPage}
                                    />
                                )}
                            </React.Fragment>
                        )}
                    </div>
                </div>
            </main>
            <BottomNavBar
                currentPage={currentPage}
                onPageChange={setCurrentPage}
                currentUser={currentUser}
            />
            <Toast 
                message={toast.message} 
                type={toast.type} 
                onDismiss={() => setToast({ message: '', type: '' })} 
            />
        </div>
    );
};
        
        // ===== RENDER =====
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(MemoireMekong));
    </script>
</body>
</html>
