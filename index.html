<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üêò M√©moire du M√©kong V0.5.9g : reprise 0.5.9g par Claude pour correction Mastodon/blog </title>
    
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    
    <script src="https://apis.google.com/js/api.js"></script>
	<script src="https://accounts.google.com/gsi/client"></script>
	<script>
	window.onload = () => {
  		google.accounts.id.initialize({
    		client_id: '82966045106-hso0nr386agcuojllnud0dr41vcsh45a.apps.googleusercontent.com',
    		scope: 'https://www.googleapis.com/auth/drive.readonly' // Ajoutez cette ligne cruciale
  		});
	};
	</script>

    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        .lucide { width: 1em; height: 1em; fill: none; stroke: currentColor; stroke-width: 2; stroke-linecap: round; stroke-linejoin: round; }
        .fade-in { animation: fadeIn 0.3s ease-in; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
		.pulse-warning { animation: pulseWarning 2s infinite; }
		@keyframes pulseWarning { 
    		0%, 100% { background-color: rgb(254 242 242); border-color: rgb(252 165 165); }
    		50% { background-color: rgb(239 68 68); border-color: rgb(185 28 28); color: white; }
		}
    </style>
</head>
<body>
    <div id="root"></div>

    <script type="text/babel">
        // ===== ICONS LUCIDE =====
        const Home = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="m3 9 9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/><polyline points="9,22 9,12 15,12 15,22"/></svg>;
        const Users = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="m22 21-2-2"/></svg>;
        const User = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>;
        const Play = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><polygon points="5,3 19,12 5,21"/></svg>;
        const Camera = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M14.5 4h-5L7 7H4a2 2 0 0 0-2 2v9a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2V9a2 2 0 0 0-2-2h-3l-2.5-3z"/><circle cx="12" cy="13" r="3"/></svg>;
        const Cloud = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M17.5 19H9a7 7 0 1 1 6.71-9h1.79a4.5 4.5 0 1 1 0 9Z"/></svg>;
        const Settings = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M12.22 2h-.44a2 2 0 0 0-2 2.18l.2 1.81c-.26.06-.51.14-.76.23l-1.5-1.16a2 2 0 0 0-2.83.32l-.22.38a2 2 0 0 0 .32 2.83l1.16 1.5c-.09.25-.17.5-.23.76l-1.81.2a2 2 0 0 0-2.18 2v.44a2 2 0 0 0 2.18 2l1.81.2c.06.26.14.51.23.76l-1.16 1.5a2 2 0 0 0-.32 2.83l.38.22a2 2 0 0 0 2.83-.32l1.5-1.16c.25.09.5.17.76.23l.2 1.81a2 2 0 0 0 2 2.18h.44a2 2 0 0 0 2-2.18l.2-1.81c.26-.06.51-.14.76-.23l1.5 1.16a2 2 0 0 0 2.83-.32l.22-.38a2 2 0 0 0-.32-2.83l-1.16-1.5c.09-.25.17-.5.23-.76l1.81-.2a2 2 0 0 0 2.18-2v-.44a2 2 0 0 0-2.18-2l-1.81-.2c-.06-.26-.14-.51-.23-.76l1.16-1.5a2 2 0 0 0 .32-2.83l-.38-.22a2 2 0 0 0-2.83.32l-1.5 1.16c-.25-.09-.5-.17-.76-.23l-.2-1.81a2 2 0 0 0-2-2.18Z"/><circle cx="12" cy="12" r="3"/></svg>;
        const ChevronLeft = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="m15 18-6-6 6-6"/></svg>;
        const ChevronRight = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="m9 18 6-6-6-6"/></svg>;
        const Clock = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><polyline points="12,6 12,12 16,14"/></svg>;
        const Mic = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z"/><path d="M19 10v2a7 7 0 0 1-14 0v-2"/><line x1="12" x2="12" y1="19" y2="22"/><line x1="8" x2="16" y1="22" y2="22"/></svg>;
        const Zap = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><polygon points="13,2 3,14 12,14 11,22 21,10 12,10"/></svg>;
        const MapPin = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M20 10c0 6-8 12-8 12s-8-6-8-12a8 8 0 0 1 16 0Z"/><circle cx="12" cy="10" r="3"/></svg>;
        const BookOpen = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></svg>;
        const Edit = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"/><path d="m18.5 2.5 3 3L12 15l-4 1 1-4 9.5-9.5Z"/></svg>;
        const Plus = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M5 12h14"/><path d="M12 5v14"/></svg>;
        const Shuffle = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><polyline points="16,3 21,3 21,8"/><line x1="4" x2="21" y1="20" y2="3"/><polyline points="21,16 21,21 16,21"/><line x1="15" x2="21" y1="15" y2="21"/><line x1="4" x2="9" y1="4" y2="9"/></svg>;
        const Pause = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><rect width="4" height="16" x="6" y="4"/><rect width="4" height="16" x="14" y="4"/></svg>;
        const ArrowLeft = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="m12 19-7-7 7-7"/><path d="M19 12H5"/></svg>;
        const Send = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="m22 2-7 20-4-9-9-4Z"/><path d="M22 2 11 13"/></svg>;
        const Trash2 = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="m8 6V4c0-1 1-2 2-2h4c0-1-1-2-2-2v2"/><line x1="10" x2="10" y1="11" y2="17"/><line x1="14" x2="14" y1="11" y2="17"/></svg>;
        const Search = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"/><path d="m21 21-4.35-4.35"/></svg>;
        const Upload = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7,10 12,5 17,10"/><line x1="12" x2="12" y1="5" y2="15"/></svg>;
        const FileText = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="M14.5 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V7.5L14.5 2z"/><polyline points="14,2 14,8 20,8"/><line x1="16" x2="8" y1="13" y2="13"/><line x1="16" x2="8" y1="17" y2="17"/><line x1="10" x2="8" y1="9" y2="9"/></svg>;
		const CloudOff = ({ className = "" }) => <svg className={`lucide ${className}`} viewBox="0 0 24 24"><path d="m2 2 20 20"/><path d="M5.782 5.782A7 7 0 0 0 9 19h8.5a4.5 4.5 0 0 0 1.307-.193"/><path d="M21.532 16.5A4.5 4.5 0 0 0 17.5 10h-1.79A7.008 7.008 0 0 0 10 5.07"/></svg>;


		// ===== COMPOSANT TOAST - POSITION ET DISMISSABLE FIXES =====
	const Toast = ({ message, type, onDismiss }) => {
    if (!message) return null;

    const styles = {
        error: { bg: 'bg-red-100', text: 'text-red-800', border: 'border-red-300' },
        success: { bg: 'bg-green-100', text: 'text-green-800', border: 'border-green-300' }
    };
    const style = styles[type] || styles.error;

    // Auto-dismiss apr√®s 5 secondes
    React.useEffect(() => {
        const timer = setTimeout(() => {
            onDismiss();
        }, 5000);
        return () => clearTimeout(timer);
    }, [message, onDismiss]);

    return (
        <div className={`fixed bottom-20 right-4 left-4 sm:left-auto sm:max-w-sm p-4 border-2 rounded-lg shadow-lg fade-in z-50 ${style.bg} ${style.text} ${style.border}`}>
            <div className="flex justify-between items-start">
                <span className="flex-1 pr-2 text-sm leading-relaxed">{message}</span>
                <button 
                    onClick={onDismiss} 
                    className="ml-2 text-xl font-bold hover:opacity-70 flex-shrink-0 w-6 h-6 flex items-center justify-center"
                    title="Fermer"
                >
                    √ó
                </button>
            </div>
        </div>
    );
};

		// ===== COMPOSANT LOADING =====
	const LoadingSpinner = ({ message = "Chargement...", size = "normal" }) => {
    const sizeClasses = {
        small: "w-4 h-4 border-2",
        normal: "w-8 h-8 border-2", 
        large: "w-12 h-12 border-4"
    };

    return (
        <div className="flex flex-col items-center justify-center py-12 fade-in">
            <div className={`animate-spin border-amber-600 border-t-transparent rounded-full mb-4 ${sizeClasses[size]}`}></div>
            <p className="text-amber-700 text-center">{message}</p>
        </div>
    );
};

		// ===== COMPOSANT TIMELINE (FRISE CHRONOLOGIQUE) =====
const Timeline = ({ currentDay, maxDay, onDaySelect }) => {
    const timelineRef = React.useRef(null);
    const dayRef = React.useRef(null);

    React.useEffect(() => {
        if (dayRef.current) {
            dayRef.current.scrollIntoView({
                behavior: 'smooth',
                inline: 'center',
                block: 'nearest'
            });
        }
    }, [currentDay]);

    const days = Array.from({ length: maxDay }, (_, i) => i + 1);

    return (
        <div className="bg-gray-100 p-2 rounded-lg border border-gray-200">
            <div ref={timelineRef} className="flex overflow-x-auto space-x-1 py-2 scrollbar-thin scrollbar-thumb-amber-400 scrollbar-track-gray-200">
                {days.map(day => {
                    const isCurrent = day === currentDay;
                    const isDecade = day % 10 === 0;

                    return (
                        <button
                            key={day}
                            ref={isCurrent ? dayRef : null}
                            onClick={() => onDaySelect(day)}
                            className={`flex-shrink-0 flex flex-col items-center justify-end h-16 w-8 rounded transition-colors duration-200 ${
                                isCurrent ? 'bg-amber-500 text-white' : 'hover:bg-amber-100'
                            }`}
                        >
                            <span className={`text-xs font-semibold ${isCurrent ? 'font-bold' : 'text-gray-600'}`}>
                                {isDecade || day === 1 || day === maxDay ? day : ''}
                            </span>
                            <div className={`w-px h-full ${isDecade ? 'bg-amber-400 h-8' : 'bg-gray-300 h-4'}`}></div>
                        </button>
                    );
                })}
            </div>
        </div>
    );
};


// ===== COMPOSANT PHOTOGRID (GRILLE PHOTOS) =====
const PhotoGrid = ({ photos, onPhotoSelect }) => {
    if (!photos || photos.length === 0) {
        return (
            <div className="text-center py-12 bg-gray-50 rounded-lg">
                <Camera className="w-16 h-16 text-gray-300 mx-auto mb-4" />
                <h3 className="text-lg font-medium text-gray-600">Aucune photo pour ce jour</h3>
                <p className="text-gray-500">S√©lectionnez un autre jour sur la frise.</p>
            </div>
        );
    }

    return (
        <div className="grid grid-cols-3 sm:grid-cols-4 md:grid-cols-6 lg:grid-cols-8 gap-2">
            {photos.map((photo, index) => (
                <button 
                    key={photo.filename + index} 
                    onClick={() => onPhotoSelect(index)}
                    className="aspect-square bg-gray-200 rounded-md overflow-hidden hover:opacity-80 transition-opacity focus:outline-none focus:ring-2 focus:ring-amber-500"
                >
                    <img 
                        src={photo.thumbnailLink} 
                        alt={photo.filename} 
                        loading="lazy"
                        className="w-full h-full object-cover"
                    />
                </button>
            ))}
        </div>
    );
};


// COMPOSANT: PhotoViewer avec base64 pour grand format
const PhotoViewer = ({ photos, selectedIndex, onClose, onNavigate, onCreateSession }) => {
    const [fullImageSrc, setFullImageSrc] = React.useState('');
    const [isLoadingFullImage, setIsLoadingFullImage] = React.useState(false);
    const photoRef = React.useRef(null);

    if (selectedIndex === null || !photos[selectedIndex]) return null;

    const photo = photos[selectedIndex];

    React.useEffect(() => {
        const loadFullImage = async () => {
            setIsLoadingFullImage(true);
            setFullImageSrc('');

            const base64Src = await GoogleDriveAPI.getPhotoAsBase64(photo.id, photo.mimeType || 'image/jpeg');
            if (base64Src) {
                setFullImageSrc(base64Src);
            } else {
                setFullImageSrc(photo.webContentLink);
            }
            setIsLoadingFullImage(false);
        };

        if (photo.id && photo.mimeType) {
            loadFullImage();
        } else {
            setFullImageSrc(photo.webContentLink);
        }
    }, [photo]);

    React.useEffect(() => {
        const handleKeyDown = (e) => {
            if (e.key === 'Escape') onClose();
            if (e.key === 'ArrowLeft') onNavigate('prev');
            if (e.key === 'ArrowRight') onNavigate('next');
        };
        window.addEventListener('keydown', handleKeyDown);
        return () => window.removeEventListener('keydown', handleKeyDown);
    }, [onClose, onNavigate]);

    const canGoPrev = selectedIndex > 0;
    const canGoNext = selectedIndex < photos.length - 1;

    return (
        <div className="fixed inset-0 bg-black/95 z-50 flex items-center justify-center">

            {/* Bouton de fermeture */}
            <button
                onClick={onClose}
                className="absolute top-6 left-6 z-10 p-2 rounded-full bg-gray-800/50 hover:bg-gray-800 text-white transition-all"
                title="Fermer"
            >
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className="lucide lucide-x"><path d="M18 6 6 18"/><path d="m6 6 12 12"/></svg>
            </button>

            <div className="relative max-w-full max-h-full flex items-center justify-center">
                {isLoadingFullImage ? (
                    <div className="flex items-center justify-center py-12">
                        <div className="animate-spin rounded-full h-16 w-16 border-b-2 border-white"></div>
                        <span className="ml-3 text-white text-lg">Chargement...</span>
                    </div>
                ) : (
                    <img
                        ref={photoRef}
                        src={fullImageSrc}
                        alt="Photo du voyage"
                        className="max-w-[90vw] max-h-[85vh] object-contain"
                    />
                )}

                {/* Navigation - Positionn√©es par rapport √† l'image elle-m√™me */}
                {photos.length > 1 && (
                    <>
                        <button
                            onClick={() => onNavigate('prev')}
                            disabled={!canGoPrev}
                            className="absolute -left-12 p-3 rounded-full bg-gray-800/50 hover:bg-gray-800 text-white transition-all disabled:opacity-20 disabled:cursor-not-allowed"
                        >
                            <ChevronLeft className="w-8 h-8" />
                        </button>
                        <button
                            onClick={() => onNavigate('next')}
                            disabled={!canGoNext}
                            className="absolute -right-12 p-3 rounded-full bg-gray-800/50 hover:bg-gray-800 text-white transition-all disabled:opacity-20 disabled:cursor-not-allowed"
                        >
                            <ChevronRight className="w-8 h-8" />
                        </button>
                    </>
                )}
            </div>

            {/* Bouton pour cr√©er une session - Positionn√© par rapport √† l'image */}
            <div className="absolute bottom-6 right-6 z-10">
                <button
                    onClick={() => onCreateSession(photo)}
                    className="flex-shrink-0 flex items-center space-x-2 px-4 py-2 bg-green-500 hover:bg-green-600 text-white rounded-lg text-sm font-semibold"
                >
                    <Plus className="w-4 h-4" />
                    <span>Cr√©er une Session</span>
                </button>
            </div>
        </div>
    );
};
		
        // ===== CORE STORAGE =====
	const Storage = {
    get: (key, defaultValue = null) => {
        try {
            const item = localStorage.getItem(`mekong_${key}`);
            return item ? JSON.parse(item) : defaultValue;
        } catch { return defaultValue; }
    },
    set: (key, value) => {
        try {
            localStorage.setItem(`mekong_${key}`, JSON.stringify(value));
            return true;
        } catch { return false; }
    },
    remove: (key) => localStorage.removeItem(`mekong_${key}`),
    clear: () => {
        Object.keys(localStorage).forEach(key => {
            if (key.startsWith('mekong_')) localStorage.removeItem(key);
        });
    }
};
		
// ===== MASTODON DATA MANAGEMENT - IMPORT TOUS LES POSTS =====
	const MastodonData = {
    // D√©coder les entit√©s HTML
    decodeHtmlEntities: (text) => {
        const textArea = document.createElement('textarea');
        textArea.innerHTML = text;
        return textArea.value;
    },

    // Parser le fichier outbox.json - MODIFI√â POUR IMPORTER TOUS LES POSTS
    parseOutbox: (jsonData) => {
        try {
            const data = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;
            
            let orderedItems;
            if (data.orderedItems) {
                orderedItems = data.orderedItems;
            } else if (data.data && data.data.orderedItems) {
                orderedItems = data.data.orderedItems;
            } else {
                throw new Error('Format ActivityPub invalide - orderedItems non trouv√©');
            }

            if (!Array.isArray(orderedItems)) {
                throw new Error('orderedItems n\'est pas un tableau');
            }

            // √âTAPE 1 : Traiter tous les posts et identifier ceux avec/sans num√©ro de jour
            const allPosts = orderedItems
                .filter(item => item.type === 'Create' && item.object?.type === 'Note')
                .map((item, index) => {
                    const note = item.object;
                    const content = note.content || '';
                    
                    // Nettoyer le HTML et d√©coder les entit√©s HTML
                    const cleanContent = content.replace(/<[^>]*>/g, '');
                    const decodedContent = MastodonData.decodeHtmlEntities(cleanContent);
                    
                    // Extraire le num√©ro de jour - format "Jnnn:" ou "Jnnn "
                    const dayMatch = decodedContent.match(/^J(\d{1,3})[\s:]/);
                    const dayNumber = dayMatch ? parseInt(dayMatch[1]) : null;
                    const hasJourNumber = dayNumber !== null;
                    
                    // NOUVEAU : Extraire le titre
                    let title;
                    if (hasJourNumber) {
                        const afterJour = decodedContent.replace(/^J\d{1,3}[\s:]+/, '');
                        title = afterJour.split('\n')[0].slice(0, 60).trim();
                        if (title.length === 60) title += '...';
                    } else {
                        title = decodedContent.split('\n')[0].slice(0, 60).trim();
                        if (title.length === 60) title += '...';
                    }
                    
                    title = title.replace(/[‚õ©Ô∏èü¶©‚úàÔ∏èüá®üáµüî•‚ö°üåüüéØüí™üöÄ‚ú®üéâüéäüéàüéÅüéÄüéáüéÜ]/g, '').replace(/\s+/g, ' ').trim();
                    
                    // --- CORRECTION MAJEURE ICI ---
                    // Logique pour trouver les "media_attachments" qui sont parfois imbriqu√©s
                    let foundAttachments = [];
                    // Cherche dans le tableau `attachments` de l'objet Note
                    if (note.attachments && Array.isArray(note.attachments)) {
                        foundAttachments = note.attachments;
                    } 
                    // Si ce n'est pas trouv√© l√†, cherche dans l'objet lui-m√™me (certains exports les placent au m√™me niveau que l'objet Note)
                    else if (note.attachment && Array.isArray(note.attachment)) {
                        foundAttachments = note.attachment;
                    }
                    // Finalement, si une "pi√®ce jointe de media" est trouv√©e, on l'utilise
                    if (item.object.media_attachments && Array.isArray(item.object.media_attachments)) {
                        foundAttachments = item.object.media_attachments;
                    }

                    // On filtre pour ne garder que les images et on les transforme
                    const photos = foundAttachments.filter(att => att.type === 'Image' && att.url);
                    
                    // Si aucune photo n'est trouv√©e avec le type 'Image', on essaie de trouver un objet plus g√©n√©rique
                    // C'est une correction pour le cas o√π le type serait diff√©rent
                    if (photos.length === 0) {
                        const genericPhotos = foundAttachments.filter(att => att.url);
                        if (genericPhotos.length > 0) {
                             console.warn('‚ö†Ô∏è Found generic attachments, assuming they are photos:', genericPhotos);
                             photos.push(...genericPhotos);
                        }
                    }

                    return {
                        id: note.id || `post-${index}`,
                        dayNumber,
                        hasJourNumber,
                        title: title || 'Post sans titre',
                        content: decodedContent,
                        published: note.published || item.published,
                        attachments: photos, // On s'assure que c'est bien le tableau d'images
                        url: note.url,
                        originalIndex: index
                    };
                });

            // √âTAPE 2 : S√©parer les posts avec et sans num√©ro de jour
            const postsWithDay = allPosts.filter(post => post.hasJourNumber);
            const postsWithoutDay = allPosts.filter(post => !post.hasJourNumber);

            // √âTAPE 3 : Trier les posts avec num√©ro de jour
            postsWithDay.sort((a, b) => a.dayNumber - b.dayNumber);

            // √âTAPE 4 : Attribuer des num√©ros aux posts sans jour (apr√®s le dernier jour)
            const maxDayNumber = postsWithDay.length > 0 ? Math.max(...postsWithDay.map(p => p.dayNumber)) : 0;
            postsWithoutDay.forEach((post, index) => {
                post.dayNumber = maxDayNumber + index + 1;
                post.isExtraPost = true;
            });

            // √âTAPE 5 : Combiner tous les posts
            const finalPosts = [...postsWithDay, ...postsWithoutDay];

            // √âTAPE 6 : Nettoyer les propri√©t√©s temporaires
            finalPosts.forEach(post => {
                delete post.hasJourNumber;
                delete post.originalIndex;
            });
            
            // Log de d√©bogage pour v√©rifier le parsing
            console.log('--- TEST PARSING ATTACHMENTS ---');
            const postWithAttachments = finalPosts.find(p => p.attachments && p.attachments.length > 0);
            if (postWithAttachments) {
                 console.log(`‚úÖ Exemple de post avec attachments (Jour ${postWithAttachments.dayNumber}):`, postWithAttachments);
            } else {
                 console.log('‚ùå Aucun post avec attachments trouv√©. Le fichier outbox.json pourrait ne pas en contenir.');
            }
            console.log('---------------------------------');

            console.log(`‚úÖ ${finalPosts.length} posts Mastodon import√©s`);
            console.log(`   - ${postsWithDay.length} posts avec num√©ro de jour (J1 √† J${maxDayNumber})`);
            console.log(`   - ${postsWithoutDay.length} posts additionnels (J${maxDayNumber + 1} √† J${maxDayNumber + postsWithoutDay.length})`);
            
            if (postsWithoutDay.length > 0) {
                console.log('üìã Posts sans num√©ro de jour ajout√©s :');
                postsWithoutDay.slice(0, 3).forEach(post => {
                    console.log(`   J${post.dayNumber}: "${post.content.slice(0, 60)}..."`);
                });
                if (postsWithoutDay.length > 3) {
                    console.log(`   ... et ${postsWithoutDay.length - 3} autres`);
                }
            }
            
            return finalPosts;
        } catch (error) {
            console.error('‚ùå Erreur parsing outbox:', error);
            throw error;
        }
    },

    // Sauvegarder les posts
    savePosts: (posts) => {
        Storage.set('mastodon_posts', posts);
        Storage.set('mastodon_imported_at', new Date().toISOString());
    },

    // R√©cup√©rer les posts
    getPosts: () => {
        return Storage.get('mastodon_posts', []);
    },

    // Rechercher dans les posts
    searchPosts: (query) => {
        const posts = MastodonData.getPosts();
        if (!query.trim()) return posts;
        
        const searchTerms = query.toLowerCase().trim().split(/\s+/);
        return posts.filter(post => 
            searchTerms.every(term => 
                post.content.toLowerCase().includes(term)
            )
        );
    },

    // Obtenir un post par num√©ro de jour
    getPostByDay: (dayNumber) => {
        const posts = MastodonData.getPosts();
        return posts.find(post => post.dayNumber === dayNumber);
    },

    // Obtenir un post al√©atoire
    getRandomPost: () => {
        const posts = MastodonData.getPosts();
        if (posts.length === 0) return null;
        return posts[Math.floor(Math.random() * posts.length)];
    },

    // V√©rifier si les donn√©es sont import√©es
    isImported: () => {
        const posts = MastodonData.getPosts();
        return posts.length > 0;
    },

    // Obtenir les stats
    getStats: () => {
        const posts = MastodonData.getPosts();
        const importedAt = Storage.get('mastodon_imported_at');
        const extraPosts = posts.filter(p => p.isExtraPost);
        
        return {
            totalPosts: posts.length,
            regularPosts: posts.length - extraPosts.length,
            extraPosts: extraPosts.length,
            dayRange: posts.length > 0 ? {
                min: Math.min(...posts.map(p => p.dayNumber)),
                max: Math.max(...posts.map(p => p.dayNumber))
            } : null,
            importedAt
        };
    }
};

// ===== PHOTO DATA MANAGEMENT - GESTION DE L'INDEX DES PHOTOS =====
const PhotoData = {
    // Parser l'index des photos et le normaliser
    parsePhotoIndex: (jsonData) => {
        try {
            const data = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;
            let allPhotos = [];
            const photosByDay = {};

            for (const key in data) {
                if (data.hasOwnProperty(key)) {
                    const entry = data[key];
                    const dayStr = key.trim();
                    
                    if (dayStr && entry.photos && entry.photos.length > 0) {
                        const dayRanges = dayStr.split('-').map(d => parseInt(d, 10));
                        const startDay = dayRanges[0];
                        const endDay = dayRanges.length > 1 ? dayRanges[1] : startDay;

                        for (let day = startDay; day <= endDay; day++) {
                            if (!isNaN(day)) {
                                if (!photosByDay[day]) {
                                    photosByDay[day] = [];
                                }
                                const photoEntries = entry.photos.map(filename => ({
                                    day: day,
                                    folderName: entry.folderName,
                                    filename: filename
                                }));
                                photosByDay[day].push(...photoEntries);
                                allPhotos.push(...photoEntries);
                            }
                        }
                    }
                }
            }
            
            allPhotos.sort((a, b) => a.day - b.day);

            console.log(`INFO: ${allPhotos.length} photos index√©es sur ${Object.keys(photosByDay).length} jours.`);
            
            return { allPhotos, photosByDay };
        } catch (error) {
            console.error("Erreur lors du parsing de l'index des photos:", error);
            throw error;
        }
    },

    // Sauvegarder l'index
    saveIndex: (indexData) => {
        Storage.set('photo_index', indexData);
        Storage.set('photo_index_imported_at', new Date().toISOString());
    },

    // R√©cup√©rer l'index
    getIndex: () => {
        return Storage.get('photo_index', null);
    },

    // Obtenir les photos pour un jour donn√©
    getPhotosByDay: (dayNumber) => {
        const index = PhotoData.getIndex();
        return index?.photosByDay?.[dayNumber] || [];
    },

    // V√©rifier si l'index est import√©
    isImported: () => {
        return !!PhotoData.getIndex();
    },

    // Obtenir les stats
    getStats: () => {
        const index = PhotoData.getIndex();
        const importedAt = Storage.get('photo_index_imported_at');
        if (!index) return { totalPhotos: 0, totalDays: 0, importedAt: null };

        return {
            totalPhotos: index.allPhotos.length,
            totalDays: Object.keys(index.photosByDay).length,
            importedAt
        };
    }
};       

// ===== GOOGLE DRIVE API - VERSION STABLE ET CORRIG√âE =====
const GOOGLE_CONFIG = {
    API_KEY: 'AIzaSyDiyLLN4EsyVREGxF4TzqbuKyugaq4TUXw',
    CLIENT_ID: '82966045106-hso0nr386agcuojllnud0dr41vcsh45a.apps.googleusercontent.com',
    SCOPES: 'https://www.googleapis.com/auth/drive.file https://www.googleapis.com/auth/userinfo.profile https://www.googleapis.com/auth/userinfo.email https://www.googleapis.com/auth/drive.readonly'
};

const GoogleDriveAPI = {
    isSignedIn: false,
    isInitialized: false,
    tokenClient: null,
    _folderCache: new Map(),

    async init() { if (this.isInitialized) return; try { console.log('üîÑ Initialisation...'); await new Promise(r => gapi.load('client', r)); await gapi.client.init({ apiKey: GOOGLE_CONFIG.API_KEY, discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'] }); this.tokenClient = google.accounts.oauth2.initTokenClient({ client_id: GOOGLE_CONFIG.CLIENT_ID, scope: GOOGLE_CONFIG.SCOPES, callback: '' }); this.isInitialized = true; console.log('‚úÖ API initialis√©e'); } catch (e) { console.error('‚ùå Erreur init API:', e); throw e; } },
    async signIn() { if (!this.isInitialized) await this.init(); return new Promise((resolve, reject) => { if (!this.tokenClient) return reject(new Error('Token client non initialis√©')); this.tokenClient.callback = async (res) => { if (res.error) { this.isSignedIn = false; return reject(new Error(`Erreur OAuth: ${res.error}`)); } try { await gapi.client.drive.files.list({ pageSize: 1 }); this.isSignedIn = true; resolve(true); } catch (e) { this.isSignedIn = false; reject(new Error('Acc√®s API Drive impossible')); } }; const token = gapi.client.getToken(); if (token) { this.isSignedIn = true; resolve(true); } else { this.tokenClient.requestAccessToken({ prompt: 'consent' }); } }); },
    async signOut() { const token = gapi.client.getToken(); if (token) { google.accounts.oauth2.revoke(token.access_token); gapi.client.setToken(''); } this.isSignedIn = false; },
    async getUserInfo() { if (!this.isSignedIn) throw new Error('Non connect√©'); try { const response = await gapi.client.request({ path: 'https://www.googleapis.com/oauth2/v2/userinfo' }); return response.result; } catch (e) { console.error('‚ùå Erreur getUserInfo:', e); throw e; } },
    async _findFile(name, parentId, mimeType) { try { const q = `'${parentId}' in parents and name='${name}' and trashed=false` + (mimeType ? ` and mimeType='${mimeType}'` : ''); const response = await gapi.client.drive.files.list({ q, fields: 'files(id, name)', pageSize: 1 }); return response.result.files?.[0] || null; } catch (e) { console.error(`‚ùå Erreur _findFile ${name}:`, e); return null; } },
    async _loadJSONFromDrive(fileName) { const fileId = await this._findFileByName(fileName); if (!fileId) throw new Error(`Fichier ${fileName} non trouv√©`); try { const response = await gapi.client.drive.files.get({ fileId, alt: 'media' }); return JSON.parse(response.body); } catch (e) { console.error(`‚ùå Erreur chargement JSON '${fileName}':`, e); throw e; } },
    async _findFileByName(fileName) { try { const response = await gapi.client.drive.files.list({ q: `name='${fileName}' and trashed=false`, fields: 'files(id)', pageSize: 1 }); return response.result.files?.[0]?.id || null; } catch (e) { console.error(`‚ùå Erreur recherche ${fileName}:`, e); return null; } },
    
    // CORRECTION: Fonction manquante pour l'import de l'index photos
    async loadJsonFile(fileName) {
        return await this._loadJSONFromDrive(fileName);
    },
    
    async loadSessions() { try { return await this._loadJSONFromDrive('mekong_sessions.json'); } catch (e) { console.error('‚ùå Erreur chargement sessions:', e); return null; } },
    async saveSessions(sessions) { if (!this.isSignedIn) throw new Error('Pas connect√©'); try { const fileName = 'mekong_sessions.json'; let fileId = await this._findFileByName(fileName); const fileMetadata = { name: fileName }; const form = new FormData(); form.append('metadata', new Blob([JSON.stringify(fileMetadata)], { type: 'application/json' })); form.append('file', new Blob([JSON.stringify(sessions, null, 2)], { type: 'application/json' })); const url = fileId ? `https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=multipart` : 'https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart'; const response = await fetch(url, { method: fileId ? 'PATCH' : 'POST', headers: { Authorization: `Bearer ${gapi.client.getToken().access_token}` }, body: form }); if (!response.ok) throw new Error(`Erreur HTTP: ${response.status}`); return await response.json(); } catch (e) { console.error(`‚ùå Erreur sauvegarde sessions:`, e); throw e; } },

    async listPhotoFiles(folderId) {
        if (!this.isSignedIn) throw new Error('Pas connect√©');
        try {
            const response = await gapi.client.drive.files.list({
                q: `'${folderId}' in parents and mimeType contains 'image/' and trashed=false`,
                fields: 'files(id, name, webContentLink, thumbnailLink, mimeType)',
                pageSize: 500
            });
            return response.result.files || [];
        } catch (e) { console.error(`‚ùå Erreur listing photos du dossier ${folderId}:`, e); return []; }
    },

    // NOUVELLE FONCTION: listAllFiles pour trouver tous les fichiers dans un dossier et ses sous-dossiers
    async listAllFiles(folderId, allFiles = []) {
        let pageToken = null;
        try {
            do {
                const response = await gapi.client.drive.files.list({
                    q: `'${folderId}' in parents and trashed=false`,
                    fields: 'nextPageToken, files(id, name, webContentLink, thumbnailLink, mimeType, mimeType)',
                    pageToken: pageToken
                });
                
                const files = response.result.files || [];
                for (const file of files) {
                    if (file.mimeType === 'application/vnd.google-apps.folder') {
                        // C'est un dossier, on recherche r√©cursivement
                        await this.listAllFiles(file.id, allFiles);
                    } else {
                        // C'est un fichier, on l'ajoute
                        allFiles.push(file);
                    }
                }
                pageToken = response.result.nextPageToken;
            } while (pageToken);
        } catch (e) {
            console.error('‚ùå Erreur listAllFiles:', e);
        }
        return allFiles;
    },

    // NOUVEAU: Fonction pour charger une photo en base64 (utilis√©e seulement √† la demande)
    async getPhotoAsBase64(fileId, mimeType) {
        if (!this.isSignedIn) throw new Error('Pas connect√©');
        try {
            console.log('üîÑ Chargement photo en base64:', fileId);
            const response = await gapi.client.drive.files.get({
                fileId: fileId,
                alt: 'media'
            });

            // Conversion des donn√©es binaires en Base64
            const raw = response.body;
            const rawLength = raw.length;
            const array = new Uint8Array(rawLength);
            
            for (let i = 0; i < rawLength; i++) {
                array[i] = raw.charCodeAt(i);
            }
            
            const blob = new Blob([array], { type: mimeType });
            
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onloadend = () => {
                    console.log('‚úÖ Photo charg√©e en base64');
                    resolve(reader.result);
                };
                reader.onerror = (error) => {
                    console.error('‚ùå Erreur conversion base64:', error);
                    reject(error);
                };
                reader.readAsDataURL(blob);
            });
            
        } catch (error) {
            console.error(`‚ùå Erreur chargement photo ${fileId} en base64:`, error);
            return null;
        }
    }
};

// ===== USER CONFIG =====
        const USERS = {
            tom: { name: 'Tom le jeune √©l√©phanteau', color: 'blue', emoji: 'üêò' },
            lambert: { name: 'Lambert, le Vieux Pachiderme', color: 'green', emoji: 'üêò' },
            duo: { name: 'Duo Mekong Tandem', color: 'amber', emoji: 'üêòüêò' }
        };
        
        const getUserStyle = (userKey) => {
            const user = USERS[userKey];
            if (!user) return { bg: 'bg-gray-100', border: 'border-gray-300', text: 'text-gray-800' };
            
            const styles = {
                blue: { bg: 'bg-blue-100 hover:bg-blue-200', border: 'border-blue-300', text: 'text-blue-800' },
                green: { bg: 'bg-green-100 hover:bg-green-200', border: 'border-green-300', text: 'text-green-800' },
                amber: { bg: 'bg-amber-100 hover:bg-amber-200', border: 'border-amber-300', text: 'text-amber-800' }
            };
            return styles[user.color] || styles.blue;
        };

        // ===== CORE STATES =====
        const useAppState = () => {
            const [currentPage, setCurrentPage] = React.useState('home');
            const [currentUser, setCurrentUser] = React.useState(Storage.get('currentUser', ''));
            
            // Sauvegarde automatique
            React.useEffect(() => {
                Storage.set('currentUser', currentUser);
            }, [currentUser]);

            const resetApp = () => {
                setCurrentPage('home');
                setCurrentUser('');
                Storage.clear();
            };

            return {
                currentPage, setCurrentPage,
                currentUser, setCurrentUser,
                resetApp
            };
        };
        
        // ===== PAGE USERS =====
        const UsersPage = ({ currentUser, onUserChange, onPageChange }) => {
            return (
                <div className="space-y-6 fade-in">
                    <div className="text-center mb-6">
                        <h2 className="text-2xl font-bold text-amber-900 mb-2">Gestion des Utilisateurs</h2>
                        <p className="text-amber-700">
                            Actuellement connect√© en tant que <strong>{USERS[currentUser]?.name}</strong>
                        </p>
                    </div>

                    <div className="space-y-4">
                        <h3 className="text-lg font-semibold text-amber-900">Changer d'utilisateur :</h3>
                        
                        <div className="grid grid-cols-1 gap-4">
                            {Object.entries(USERS).map(([key, user]) => (
                                <button
                                    key={key}
                                    onClick={() => {
                                        onUserChange(key);
                                        onPageChange('home');
                                    }}
                                    className={`flex items-center space-x-4 p-4 border-2 rounded-lg transition-all ${
                                        key === currentUser 
                                            ? `${getUserStyle(key).bg} ${getUserStyle(key).border} ring-2 ring-amber-300` 
                                            : `${getUserStyle(key).bg} hover:${getUserStyle(key).border} border-gray-200 hover:border-amber-300`
                                    }`}
                                >
                                    <span className="text-3xl">{user.emoji}</span>
                                    <div className="flex-1 text-left">
                                        <div className={`font-semibold text-lg ${getUserStyle(key).text}`}>
                                            {user.name}
                                            {key === currentUser && (
                                                <span className="ml-2 text-sm bg-amber-200 text-amber-800 px-2 py-1 rounded-full">
                                                    Actuel
                                                </span>
                                            )}
                                        </div>
                                        <div className="text-sm text-gray-600">
                                            {key === 'tom' && "Le jeune aventurier"}
                                            {key === 'lambert' && "Le sage guide"}  
                                            {key === 'duo' && "Session p√®re-fils"}
                                        </div>
                                    </div>
                                    {key !== currentUser && (
                                        <div className="text-amber-600 font-medium">‚Üí Changer</div>
                                    )}
                                </button>
                            ))}
                        </div>
                    </div>

                    <div className="bg-amber-50 border border-amber-200 rounded-lg p-4 mt-6">
                        <h4 className="font-semibold text-amber-900 mb-2">üí° √Ä propos des utilisateurs</h4>
                        <div className="text-amber-700 text-sm space-y-1">
                            <div><strong>Tom :</strong> Voit ses propres messages √† droite, ceux de Lambert √† gauche</div>
                            <div><strong>Lambert :</strong> Voit ses propres messages √† droite, ceux de Tom √† gauche</div>
                            <div><strong>Duo :</strong> Mode session partag√©e, messages centr√©s</div>
                        </div>
                    </div>

                    <div className="flex justify-center pt-4">
                        <button
                            onClick={() => onPageChange('home')}
                            className="px-6 py-3 bg-amber-500 hover:bg-amber-600 text-white rounded-lg font-medium"
                        >
                            Retour √† l'accueil
                        </button>
                    </div>
                </div>
            );
        };

        // ===== GAMES CATALOG =====
        const GAMES = [
            { 
                id: 1, 
                title: "Photo roulette", 
                duration: "15 min", 
                type: "pr√©sentiel",
                icon: Camera, 
                description: "S√©lectionnez une photo au hasard et racontez tout ce qui vous revient en m√©moire" 
            },
            { 
                id: 2, 
                title: "Timeline aveugle", 
                duration: "20 min", 
                type: "pr√©sentiel",
                icon: Clock, 
                description: "Reconstituez la chronologie d'une √©tape sans regarder les dates" 
            },
            { 
                id: 3, 
                title: "Interview journaliste", 
                duration: "25 min", 
                type: "pr√©sentiel",
                icon: Mic, 
                description: "L'un interviewe l'autre sur une √©tape pr√©cise du voyage" 
            },
            { 
                id: 4, 
                title: "Photo sans l√©gende", 
                duration: "async", 
                type: "distanciel",
                icon: Camera, 
                description: "Envoyez une photo, l'autre devine le contexte et ses souvenirs" 
            },
            { 
                id: 5, 
                title: "Mot d√©clencheur", 
                duration: "async", 
                type: "distanciel",
                icon: Zap, 
                description: "Un mot-cl√© pour d√©clencher un souvenir chez l'autre" 
            },
            { 
                id: 6, 
                title: "G√©olocalisation myst√®re", 
                duration: "async", 
                type: "distanciel",
                icon: MapPin, 
                description: "Partagez une position GPS, l'autre raconte ce lieu" 
            },
            { 
                id: 7, 
                title: "Souvenir du jour", 
                duration: "libre", 
                type: "m√©moire",
                icon: BookOpen, 
                description: "Discussion autour d'un post sp√©cifique du blog Mastodon" 
            }
        ];

// ===== CLOUD SESSION STORAGE - VERSION STABLE ET CORRIG√âE =====
const CloudSessionStorage = {
    onConnectionLost: null,

    async getSessions() {
        try {
            if (!GoogleDriveAPI.isSignedIn) { return Storage.get('sessions', []); }
            const cloudSessions = await GoogleDriveAPI.loadSessions();
            if (cloudSessions) {
                Storage.set('sessions', cloudSessions);
                return cloudSessions;
            }
        } catch (error) {
            console.warn('‚ö†Ô∏è Erreur chargement cloud:', error.message);
            if (this.isConnectionError(error) && this.onConnectionLost) {
                this.onConnectionLost('Perte de connexion lors du chargement des sessions');
            }
        }
        return Storage.get('sessions', []);
    },
    
    async saveSession(session) {
        // CORRECTION: S'assurer que sessions est bien un tableau
        let sessions = Storage.get('sessions', []);
        if (!Array.isArray(sessions)) {
            console.warn('‚ö†Ô∏è Sessions corrompues d√©tect√©es, r√©initialisation');
            sessions = [];
            Storage.set('sessions', []);
        }
        
        const existingIndex = sessions.findIndex(s => s.id === session.id);
        if (existingIndex >= 0) { sessions[existingIndex] = session; } else { sessions.unshift(session); }
        Storage.set('sessions', sessions);
        
        if (!GoogleDriveAPI.isSignedIn) { return; }
        
        try {
            await GoogleDriveAPI.saveSessions(sessions);
        } catch (error) {
            console.warn('‚ö†Ô∏è Erreur sauvegarde cloud:', error.message);
            if (this.isConnectionError(error)) {
                if (this.onConnectionLost) { this.onConnectionLost('Impossible de synchroniser - Connexion perdue'); }
                throw new Error(`Connexion Google Drive perdue. Session sauvegard√©e localement.`);
            } else {
                throw new Error(`Sauvegarde cloud √©chou√©e: ${error.message}. Session sauvegard√©e localement.`);
            }
        }
    },
    
    async deleteSession(sessionId) {
        // CORRECTION: S'assurer que sessions est bien un tableau
        let sessions = Storage.get('sessions', []);
        if (!Array.isArray(sessions)) {
            console.warn('‚ö†Ô∏è Sessions corrompues d√©tect√©es, r√©initialisation');
            sessions = [];
        } else {
            sessions = sessions.filter(s => s.id !== sessionId);
        }
        Storage.set('sessions', sessions);
        
        if (!GoogleDriveAPI.isSignedIn) { return; }
        try {
            await GoogleDriveAPI.saveSessions(sessions);
        } catch (error) {
            console.warn('‚ö†Ô∏è Erreur suppression cloud:', error.message);
            if (this.isConnectionError(error)) {
                if (this.onConnectionLost) { this.onConnectionLost('Impossible de synchroniser la suppression - Connexion perdue');}
                throw new Error(`Connexion Google Drive perdue. Suppression locale effectu√©e.`);
            } else {
                throw new Error(`Suppression cloud √©chou√©e: ${error.message}. Suppression locale effectu√©e.`);
            }
        }
    },

    async forceSyncFromCloud() {
        if (!GoogleDriveAPI.isSignedIn) throw new Error('Non connect√©');
        try {
            const cloudSessions = await GoogleDriveAPI.loadSessions();
            if (cloudSessions) {
                Storage.set('sessions', cloudSessions);
                return cloudSessions;
            }
            return Storage.get('sessions', []);
        } catch (error) {
            console.error('‚ùå Erreur synchronisation:', error);
            if (this.isConnectionError(error) && this.onConnectionLost) {
                this.onConnectionLost('√âchec de synchronisation - Connexion perdue');
            }
            throw new Error(`√âchec synchronisation: ${error.message}`);
        }
    },

    isConnectionError(error) {
        if (!error) return false;
        const msg = error.message?.toLowerCase() || '';
        const status = error.status;
        const netErrors = ['network', 'failed to fetch', 'offline', 'lost', 'timeout'];
        const authErrors = ['unauthorized', 'invalid_token', 'expired', 'denied', 'invalid_grant'];
        return netErrors.some(t => msg.includes(t)) || authErrors.some(t => msg.includes(t)) || [0, 401, 403, 500, 503].includes(status);
    }
};

// ===== SESSION STORAGE =====
        const SessionStorage = {
            getSessions: () => {
    			const sessions = Storage.get('sessions', []);
    			// Nettoyer les sessions corrompues
    			return sessions.filter(session => {
        			const isValid = session && 
                       			typeof session.id !== 'undefined' && 
                       			typeof session.gameId === 'number' && 
                       			session.gameId > 0 &&
                       			Array.isArray(session.notes);
        			if (!isValid) {
            			console.warn('Session corrompue supprim√©e:', session);
        			}
        			return isValid;
    			});
			},
            saveSession: (session) => {
                const sessions = SessionStorage.getSessions();
                const existingIndex = sessions.findIndex(s => s.id === session.id);
                if (existingIndex >= 0) {
                    sessions[existingIndex] = session;
                } else {
                    sessions.unshift(session);
                }
                Storage.set('sessions', sessions);
            },
            deleteSession: (sessionId) => {
                const sessions = SessionStorage.getSessions().filter(s => s.id !== sessionId);
                Storage.set('sessions', sessions);
            }
        };

        // ===== SESSION HELPERS =====
        const getGameIcon = (gameId) => {
            if (!gameId || typeof gameId !== 'number') {
                console.log('getGameIcon: gameId invalide', gameId);
                return BookOpen; // S√©curit√© si gameId undefined/invalide
            }
            const game = GAMES.find(g => g.id === gameId);
            if (!game) {
                console.log('getGameIcon: jeu non trouv√© pour gameId', gameId);
                return BookOpen;
            }
            return game.icon;
        };

        const renderGameIcon = (gameId, className = "w-6 h-6 text-amber-600") => {
    		try {
        		const game = GAMES.find(g => g.id === gameId);
        		if (!game || !game.icon) {
            		console.warn('renderGameIcon: Jeu non trouv√© pour gameId:', gameId);
            		return React.createElement(BookOpen, { className });
        		}
        
        		const IconComponent = game.icon;
        		if (typeof IconComponent !== 'function') {
            		console.warn('renderGameIcon: Icon n\'est pas une fonction:', IconComponent);
            		return React.createElement(BookOpen, { className });
        		}
        
        		return React.createElement(IconComponent, { className });
    		} catch (error) {
        		console.error('renderGameIcon: Erreur lors du rendu:', error);
        		return React.createElement(BookOpen, { className });
    		}
		};

        const getGameById = (gameId) => {
            return GAMES.find(g => g.id === gameId);
        };

// ===== SESSION HOOKS - AVEC LOADING STATES =====
const useSessionState = () => {
    const [currentSession, setCurrentSession] = React.useState(null);
    const [sessions, setSessions] = React.useState([]);
    const [isCreatingSession, setIsCreatingSession] = React.useState(false); // NOUVEAU
    const [isDeletingSession, setIsDeletingSession] = React.useState(null); // NOUVEAU - ID de la session en cours de suppression

    React.useEffect(() => {
        const loadSessions = async () => {
            const loadedSessions = await CloudSessionStorage.getSessions();
            setSessions(loadedSessions);
        };
        loadSessions();
    }, []);

    const createSession = async (game, user) => {
        console.log('createSession appel√©e avec:', { game, user });

        if (!game || !game.id) {
            console.error('createSession: jeu invalide', game);
            return null;
        }

        setIsCreatingSession(true); // NOUVEAU
        try {
            // Pr√©parer le premier message si on a un contenu de post
            const postContent = window.pendingGameSession?.postChapo;
            const initialNotes = [];
            
            if (postContent && postContent.trim()) {
                initialNotes.push({
                    id: Date.now() - 1,
                    content: postContent.trim(),
                    author: 'duo',
                    timestamp: new Date().toISOString()
                });
                console.log('Premier message ajout√© depuis post:', postContent.slice(0, 100) + '...');
            }

            const newSession = {
                id: Date.now(),
                gameId: Number(game.id),
                gameTitle: game.title || 'Titre inconnu',
                gameDescription: game.description || 'Description inconnue',
                gameDuration: game.duration || 'Dur√©e inconnue',
                postChapo: postContent || null,
                user: user,
                createdAt: new Date().toISOString(),
                updatedAt: new Date().toISOString(),
                status: 'active',
                notes: initialNotes,
                participants: [user]
            };

            console.log('Nouvelle session cr√©√©e:', newSession);

            await CloudSessionStorage.saveSession(newSession);
            const sessions = await CloudSessionStorage.getSessions();
            setSessions(sessions);
            setCurrentSession(newSession);
            
            // Nettoyer la session en attente
            if (window.pendingGameSession) {
                delete window.pendingGameSession;
            }
            
            return newSession;
        } catch (error) {
            console.error('Erreur cr√©ation session:', error);
            throw error;
        } finally {
            setIsCreatingSession(false); // NOUVEAU
        }
    };

    const updateSession = async (updatedSession) => {
        const sessionToSave = {
            ...updatedSession, 
            notes: updatedSession.notes || [],
            updatedAt: new Date().toISOString()
        };
        await CloudSessionStorage.saveSession(sessionToSave);
        const newSessions = await CloudSessionStorage.getSessions();
        setSessions(newSessions);
        setCurrentSession(sessionToSave);
    };

    const deleteSession = async (sessionId) => {
        setIsDeletingSession(sessionId); // NOUVEAU
        try {
            await CloudSessionStorage.deleteSession(sessionId);
            const sessions = await CloudSessionStorage.getSessions();
            setSessions(sessions);
            if (currentSession?.id === sessionId) {
                setCurrentSession(null);
            }
        } catch (error) {
            console.error('Erreur suppression session:', error);
            throw error;
        } finally {
            setIsDeletingSession(null); // NOUVEAU
        }
    };
    
    const syncSessions = React.useCallback(async () => {
        try {
            const syncedSessions = await CloudSessionStorage.forceSyncFromCloud();
            setSessions(syncedSessions);
            return syncedSessions;
        } catch (error) {
            console.error('Erreur sync:', error);
            throw error;
        }
    }, []);

    return {
        currentSession, setCurrentSession,
        sessions, setSessions,
        isCreatingSession, // NOUVEAU
        isDeletingSession, // NOUVEAU
        createSession,
        updateSession,
        deleteSession,
        getGameIcon,
        renderGameIcon,
        syncSessions
    };
};

// ===== GOOGLE AUTH HOOK - CONNECTION-FIRST - AVEC DETECTION DECONNEXION (REMPLACER CE BLOC COMPLET) =====
const useGoogleAuth = () => {
    const [isConnected, setIsConnected] = React.useState(false);
    const [isLoading, setIsLoading] = React.useState(true);
    const [userInfo, setUserInfo] = React.useState(null);
    const [connectionMode, setConnectionMode] = React.useState('checking');
    const [lastConnectionError, setLastConnectionError] = React.useState(null);

    const forceDisconnect = React.useCallback((reason) => {
        console.log('üî¥ D√©connexion forc√©e:', reason);
        setIsConnected(false);
        setConnectionMode('disconnected');
        setLastConnectionError(reason);
        GoogleDriveAPI.isSignedIn = false;

        const token = gapi.client.getToken();
        if (token) {
            google.accounts.oauth2.revoke(token.access_token);
            gapi.client.setToken('');
        }
    }, []);

    React.useEffect(() => {
        const initGoogle = async () => {
            setIsLoading(true);
            setConnectionMode('checking');

            try {
                await GoogleDriveAPI.init();
                const token = gapi.client.getToken();
                if (token) {
                    try {
                        await gapi.client.drive.files.list({ pageSize: 1 });
                        const response = await fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
                            headers: { 'Authorization': `Bearer ${token.access_token}` }
                        });
                        if (response.ok) {
                            const profile = await response.json();
                            setUserInfo(profile);
                            setIsConnected(true);
                            GoogleDriveAPI.isSignedIn = true;
                            setConnectionMode('connected');
                            setLastConnectionError(null);
                            console.log('‚úÖ Reconnexion automatique r√©ussie');
                        } else {
                            throw new Error('Token invalide');
                        }
                    } catch (error) {
                        console.log('‚ö†Ô∏è Token expir√© ou invalide:', error.message);
                        gapi.client.setToken('');
                        setConnectionMode('disconnected');
                        setLastConnectionError('Token expir√©');
                    }
                } else {
                    setConnectionMode('disconnected');
                }
            } catch (error) {
                console.error('Erreur init Google:', error);
                setConnectionMode('disconnected');
                setLastConnectionError(error.message);
            } finally {
                setIsLoading(false);
            }
        };
        initGoogle();
    }, []);

    const signIn = async () => {
        setIsLoading(true);
        setLastConnectionError(null);

        try {
            const success = await GoogleDriveAPI.signIn();
            if (success) {
                const token = gapi.client.getToken();
                const response = await fetch('https://www.googleapis.com/oauth2/v3/userinfo', {
                    headers: { 'Authorization': `Bearer ${token.access_token}` }
                });
                if (!response.ok) {
                    throw new Error('Impossible de r√©cup√©rer le profil utilisateur');
                }
                const profile = await response.json();
                setUserInfo(profile);
                setIsConnected(true);
                setConnectionMode('connected');
                setLastConnectionError(null);
                console.log('Connexion r√©ussie:', profile.name);
                return true;
            } else {
                throw new Error('√âchec de la connexion Google Drive');
            }
        } catch (error) {
            console.error('Erreur connexion:', error);
            setIsConnected(false);
            setUserInfo(null);
            setConnectionMode('disconnected');
            setLastConnectionError(error.message);
            return { success: false, error: error.message };
        } finally {
            setIsLoading(false);
        }
    };

    const signOut = async () => {
        setIsLoading(true);

        try {
            const token = gapi.client.getToken();
            if (token) {
                google.accounts.oauth2.revoke(token.access_token);
                gapi.client.setToken('');
            }
            GoogleDriveAPI.isSignedIn = false;
            setIsConnected(false);
            setUserInfo(null);
            setConnectionMode('disconnected');
            setLastConnectionError(null);
            console.log('‚úÖ D√©connexion r√©ussie');
        } catch (error) {
            console.error('‚ùå Erreur d√©connexion:', error);
            setLastConnectionError(error.message);
        } finally {
            setIsLoading(false);
        }
    };

    const testConnection = React.useCallback(async () => {
        if (!isConnected) return false;
        try {
            await gapi.client.drive.files.list({ pageSize: 1 });
            return true;
        } catch (error) {
            console.log('üî¥ Test de connexion √©chou√©:', error.message);
            forceDisconnect('Test de connexion √©chou√©');
            return false;
        }
    }, [isConnected, forceDisconnect]);

    return {
        isConnected,
        isLoading,
        userInfo,
        connectionMode,
        lastConnectionError,
        signIn,
        signOut,
        forceDisconnect,
        testConnection
    };
};

// ===== NAVIGATION : TOP BAR - CONNECTION-FIRST =====
		const TopBar = ({ currentPage, currentUser, onUserChange, onPageChange, connectionMode, googleAuth, onGoogleAction }) => {
    const PAGE_TITLES = {
        home: "M√©moire du M√©kong",
        sessions: "Vos Sessions", 
        games: "Choisir un jeu",
        chat: "Conversation",
        memories: "M√©moires du Voyage",
        settings: "R√©glages",
        users: "Gestion des Utilisateurs"
    };

    // Fonction pour obtenir le style du bouton de connexion selon l'√©tat
    const getConnectionButtonStyle = () => {
        if (googleAuth.isLoading) {
            return 'bg-blue-100 text-blue-700 cursor-wait border-2 border-blue-300';
        }
        
        switch(connectionMode) {
            case 'connected':
                return 'bg-green-100 text-green-700 hover:bg-green-200 border-2 border-green-300';
            case 'disconnected':
                return 'bg-red-100 text-red-700 hover:bg-red-200 border-2 border-red-400 pulse-warning';
            case 'never-connected':
                return 'bg-orange-100 text-orange-700 hover:bg-orange-200 border-2 border-orange-300';
            default:
                return 'bg-gray-100 text-gray-700 border-2 border-gray-300';
        }
    };

    // Fonction pour obtenir le texte du bouton de connexion
    const getConnectionButtonText = () => {
        if (googleAuth.isLoading) return 'Connexion...';
        
        switch(connectionMode) {
            case 'connected':
                return googleAuth.userInfo?.name?.split(' ')[0] || 'Connect√©';
            case 'disconnected':
                return 'Reconnecter';
            case 'never-connected':
                return 'Se connecter';
            default:
                return 'Drive';
        }
    };

    // Fonction pour obtenir l'ic√¥ne du bouton de connexion
    const getConnectionIcon = () => {
        if (googleAuth.isLoading) {
            return <div className="animate-spin w-4 h-4 border-2 border-blue-600 border-t-transparent rounded-full"></div>;
        }
        
        switch(connectionMode) {
            case 'connected':
                return <Cloud className="w-5 h-5" />;
            case 'disconnected':
                return <CloudOff className="w-5 h-5" />;
            case 'never-connected':
                return <Cloud className="w-5 h-5" />;
            default:
                return <Cloud className="w-5 h-5" />;
        }
    };

    return (
        <header className="sticky top-0 z-10 p-3 bg-white/90 backdrop-blur-md border-b border-gray-200">
            <div className="flex justify-between items-center h-10">
                {/* Titre de la page */}
                <h1 className="text-xl font-bold text-amber-900 truncate">
                    {PAGE_TITLES[currentPage] || "M√©moire du M√©kong"}
                </h1>

                {/* Section droite : Connexion + Utilisateur */}
                <div className="flex items-center space-x-2">
                    {/* Bouton de connexion Google Drive - Plus pro√©minent */}
                    <button
                        onClick={onGoogleAction}
                        className={`flex items-center justify-center h-10 px-4 rounded-lg text-sm font-semibold transition-all ${getConnectionButtonStyle()}`}
                        title={
                            connectionMode === 'connected' 
                                ? `Connect√©: ${googleAuth.userInfo?.email}` 
                                : connectionMode === 'disconnected'
                                ? 'Connexion Google Drive perdue - Cliquer pour reconnecter'
                                : 'Non connect√© √† Google Drive'
                        }
                    >
                        <div className="flex items-center space-x-2">
                            {getConnectionIcon()}
                            <span className="hidden sm:inline">{getConnectionButtonText()}</span>
                        </div>
                    </button>

                    {/* Bouton utilisateur */}
                    {currentUser && (
                        <button
                            onClick={() => onPageChange('users')}
                            className={`flex items-center justify-center w-10 h-10 rounded-full border-2 transition-all ${getUserStyle(currentUser).bg} ${getUserStyle(currentUser).border} ${
                                connectionMode === 'disconnected' ? 'opacity-75' : ''
                            }`}
                            title={`Connect√© en tant que ${USERS[currentUser]?.name}. Cliquer pour g√©rer les utilisateurs.`}
                        >
                            <span className="text-xl">{USERS[currentUser]?.emoji}</span>
                        </button>
                    )}
                </div>
            </div>

            {/* Banni√®re d'alerte si d√©connect√© - Uniquement sur les pages autres que home */}
            {connectionMode === 'disconnected' && currentPage !== 'home' && (
                <div className="mt-2 px-3 py-2 bg-red-50 border border-red-200 rounded-lg">
                    <div className="flex items-center justify-between text-sm">
                        <div className="flex items-center space-x-2 text-red-700">
                            <CloudOff className="w-4 h-4" />
                            <span><strong>Mode d√©connect√© :</strong> Sessions non synchronis√©es</span>
                        </div>
                        <button
                            onClick={onGoogleAction}
                            disabled={googleAuth.isLoading}
                            className="px-2 py-1 bg-red-100 hover:bg-red-200 text-red-800 rounded text-xs font-medium"
                        >
                            Reconnecter
                        </button>
                    </div>
                </div>
            )}
        </header>
    );
};

// ===== NAVIGATION : BOTTOM NAV BAR (Version √† 4 ic√¥nes) =====
		const BottomNavBar = ({ currentPage, onPageChange, currentUser }) => {
    const navItems = [
        { id: 'home', icon: Home, label: 'Accueil' },
        { id: 'sessions', icon: BookOpen, label: 'Sessions' },
        { id: 'memories', icon: Cloud, label: 'M√©moires' },
        { id: 'settings', icon: Settings, label: 'R√©glages' },
    ];

    return (
        <div className="fixed bottom-0 left-0 right-0 h-16 bg-white/90 backdrop-blur-md border-t border-gray-200 shadow-t-lg z-10">
            <div className="flex justify-around items-center h-full">
                {navItems.map((item) => {
                    const Icon = item.icon;
                    const isActive = currentPage === item.id;
                    const isDisabled = !currentUser && item.id !== 'home';
                    
                    return (
                        <button
                            key={item.id}
                            onClick={() => onPageChange(item.id)}
                            disabled={isDisabled}
                            className={`flex flex-col items-center justify-center w-full h-full transition-colors duration-200 ${
                                isActive ? 'text-amber-600' : 'text-gray-500 hover:text-amber-500'
                            } ${isDisabled ? 'opacity-40 cursor-not-allowed' : ''}`}
                        >
                            <Icon className="w-6 h-6 mb-1" />
                            <span className={`text-xs font-medium ${isActive ? 'font-bold' : ''}`}>
                                {item.label}
                            </span>
                        </button>
                    );
                })}
            </div>
        </div>
    );
};

     
// ===== GOOGLE CONNECTION COMPONENT =====
const GoogleConnection = ({ isConnected, isLoading, userInfo, onSignIn, onSignOut }) => {
    if (isLoading) {
        return (
            <div className="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4">
                <div className="flex items-center space-x-3">
                    <div className="animate-spin w-5 h-5 border-2 border-blue-600 border-t-transparent rounded-full"></div>
                    <span className="text-blue-700">Connexion Google Drive...</span>
                </div>
            </div>
        );
    }

    if (!isConnected) {
        return (
            <div className="bg-red-50 border border-red-200 rounded-lg p-4 mb-4">
                <div className="flex items-center justify-between">
                    <div className="flex items-center space-x-3">
                        <div className="w-8 h-8 bg-red-100 rounded-full flex items-center justify-center">
                            <Cloud className="w-4 h-4 text-red-600" />
                        </div>
                        <div>
                            <div className="font-medium text-red-900">Connexion Google Drive requise</div>
                            <div className="text-sm text-red-700">Vos sessions seront partag√©es avec Tom/Lambert</div>
                        </div>
                    </div>
                    <button
                        onClick={onSignIn}
                        className="px-4 py-2 bg-red-600 hover:bg-red-700 text-white rounded-lg text-sm font-medium"
                    >
                        Se connecter
                    </button>
                </div>
            </div>
        );
    }

    return (
        <div className="bg-green-50 border border-green-200 rounded-lg p-3 mb-4">
            <div className="flex items-center justify-between">
                <div className="flex items-center space-x-3">
                    <div className="w-8 h-8 bg-green-100 rounded-full flex items-center justify-center">
                        <Cloud className="w-4 h-4 text-green-600" />
                    </div>
                    <div>
                        <div className="font-medium text-green-900">Connect√© √† Google Drive</div>
                        <div className="text-xs text-green-700">{userInfo?.email}</div>
                    </div>
                </div>
                <button
                    onClick={onSignOut}
                    className="px-3 py-1 bg-green-600 hover:bg-green-700 text-white rounded text-xs"
                >
                    D√©connecter
                </button>
            </div>
        </div>
    );
};


// ===== COMPOSANT CONNEXION OBLIGATOIRE =====
const ForceGoogleConnection = ({ onSignIn }) => (
    <div className="min-h-screen bg-gradient-to-br from-amber-50 to-orange-100 flex items-center justify-center p-4">
        <div className="bg-white rounded-xl shadow-lg p-8 max-w-md w-full text-center">
            <div className="w-16 h-16 bg-amber-100 rounded-full flex items-center justify-center mx-auto mb-4">
                <Cloud className="w-8 h-8 text-amber-600" />
            </div>
            <h1 className="text-2xl font-bold text-amber-900 mb-4">M√©moire du M√©kong</h1>
            <h2 className="text-lg font-semibold text-gray-900 mb-4">Connexion Google Drive requise</h2>
            <p className="text-gray-600 mb-6">
                Cette application utilise Google Drive pour synchroniser vos sessions entre vos appareils. 
                La connexion est obligatoire pour garantir la sauvegarde de vos m√©moires.
            </p>
            <div className="bg-amber-50 border border-amber-200 rounded-lg p-4 mb-6">
                <p className="text-amber-800 text-sm">
                    <strong>Conseil :</strong> Connectez-vous avec le compte Google partag√© 
                    <strong> mekongmemoire@gmail.com</strong> pour synchroniser avec Tom/Lambert.
                </p>
            </div>
            <button
                onClick={onSignIn}
                className="w-full px-6 py-3 bg-amber-600 hover:bg-amber-700 text-white rounded-lg font-medium flex items-center justify-center space-x-2"
            >
                <Cloud className="w-5 h-5" />
                <span>Se connecter √† Google Drive</span>
            </button>
        </div>
    </div>
);

// =========== MAIN PAGES =====
       
        // ===== HOME PAGE - CONNECTION-FIRST =====
	const HomePage = ({ currentUser, onUserChange, onPageChange, connectionMode, googleAuth }) => {
    // Mode "Checking" - V√©rification en cours
    if (connectionMode === 'checking') {
        return (
            <div className="flex flex-col items-center justify-center py-16 fade-in">
                <div className="w-20 h-20 bg-amber-100 rounded-full flex items-center justify-center mb-6">
                    <div className="animate-spin w-10 h-10 border-4 border-amber-600 border-t-transparent rounded-full"></div>
                </div>
                <h2 className="text-2xl font-bold text-amber-900 mb-4">M√©moire du M√©kong</h2>
                <p className="text-amber-700 text-center">V√©rification de la connexion Google Drive...</p>
            </div>
        );
    }

    // Mode "Never Connected" - Onboarding obligatoire
    if (connectionMode === 'never-connected') {
        return (
            <div className="space-y-8 fade-in">
                <div className="text-center">
                    <div className="w-24 h-24 bg-gradient-to-br from-amber-400 to-orange-500 rounded-full flex items-center justify-center mx-auto mb-6 shadow-lg">
                        <span className="text-4xl">üêòüêò</span>
                    </div>
                    <h1 className="text-3xl font-bold text-amber-900 mb-4">Bienvenue sur M√©moire du M√©kong</h1>
                    <p className="text-lg text-amber-700 mb-2">L'application de rem√©moration p√®re-fils</p>
                    <p className="text-amber-600">Revivez ensemble votre voyage √† v√©lo de 4,5 mois en Asie du Sud-Est</p>
                </div>

                <div className="bg-blue-50 border-2 border-blue-200 rounded-xl p-6">
                    <div className="flex items-start space-x-4">
                        <div className="w-12 h-12 bg-blue-100 rounded-full flex items-center justify-center flex-shrink-0">
                            <Cloud className="w-6 h-6 text-blue-600" />
                        </div>
                        <div className="flex-1">
                            <h3 className="text-xl font-semibold text-blue-900 mb-3">Connexion Google Drive requise</h3>
                            <div className="text-blue-800 space-y-3">
                                <div className="flex items-start space-x-2">
                                    <span className="text-blue-500 mt-1">‚Ä¢</span>
                                    <span>Vos sessions sont <strong>partag√©es automatiquement</strong> entre Tom et Lambert</span>
                                </div>
                                <div className="flex items-start space-x-2">
                                    <span className="text-blue-500 mt-1">‚Ä¢</span>
                                    <span>Synchronisation <strong>temps r√©el</strong> sur tous vos appareils</span>
                                </div>
                                <div className="flex items-start space-x-2">
                                    <span className="text-blue-500 mt-1">‚Ä¢</span>
                                    <span>Sauvegarde automatique dans le cloud</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>

                <div className="bg-amber-50 border border-amber-200 rounded-lg p-4">
                    <p className="text-amber-800 text-sm text-center">
                        <strong>Conseil :</strong> Utilisez le compte Google partag√© 
                        <strong> mekongmemoire@gmail.com</strong> pour une synchronisation parfaite
                    </p>
                </div>

                <div className="text-center">
                    <button
                        onClick={googleAuth.signIn}
                        disabled={googleAuth.isLoading}
                        className="w-full max-w-md px-8 py-4 bg-gradient-to-r from-blue-600 to-blue-700 hover:from-blue-700 hover:to-blue-800 disabled:from-gray-400 disabled:to-gray-500 text-white rounded-xl font-semibold text-lg shadow-lg transition-all flex items-center justify-center space-x-3"
                    >
                        {googleAuth.isLoading ? (
                            <div className="animate-spin w-6 h-6 border-2 border-white border-t-transparent rounded-full"></div>
                        ) : (
                            <Cloud className="w-6 h-6" />
                        )}
                        <span>{googleAuth.isLoading ? 'Connexion...' : 'Se connecter √† Google Drive'}</span>
                    </button>
                </div>
            </div>
        );
    }

    // Mode "Disconnected" - Critique, mais permet usage limit√©
    if (connectionMode === 'disconnected') {
        return (
            <div className="space-y-6 fade-in">
                {/* Alerte critique en haut */}
                <div className="pulse-warning border-2 rounded-xl p-6 text-center">
                    <div className="flex items-center justify-center space-x-3 mb-4">
                        <CloudOff className="w-8 h-8 text-red-600" />
                        <h2 className="text-2xl font-bold text-red-900">Connexion Google Drive perdue !</h2>
                    </div>
                    <p className="text-red-800 mb-4">
                        Vous ne pouvez plus synchroniser avec Tom/Lambert. Vos nouvelles sessions resteront locales.
                    </p>
                    <button
                        onClick={googleAuth.signIn}
                        disabled={googleAuth.isLoading}
                        className="px-6 py-3 bg-red-600 hover:bg-red-700 disabled:bg-gray-400 text-white rounded-lg font-semibold flex items-center space-x-2 mx-auto"
                    >
                        {googleAuth.isLoading ? (
                            <div className="animate-spin w-5 h-5 border-2 border-white border-t-transparent rounded-full"></div>
                        ) : (
                            <Cloud className="w-5 h-5" />
                        )}
                        <span>{googleAuth.isLoading ? 'Reconnexion...' : 'Reconnecter Google Drive'}</span>
                    </button>
                </div>

                {/* Contenu normal mais avec avertissements */}
                <div className="text-center">
                    <h2 className="text-2xl font-bold text-amber-900 mb-4">Mode d√©connect√©</h2>
                    {currentUser && (
                        <p className="text-amber-700 mb-6">
                            Bonjour <strong>{USERS[currentUser]?.name}</strong> ! 
                            <span className="text-red-600 font-semibold"> (Mode local uniquement)</span>
                        </p>
                    )}
                </div>

                {!currentUser ? (
                    <div className="max-w-md mx-auto space-y-4">
                        <h3 className="text-lg font-semibold text-amber-900 text-center">Qui √™tes-vous ?</h3>
                        <div className="space-y-3">
                            <button
                                onClick={() => onUserChange('tom')}
                                className={`flex items-center space-x-3 p-4 border-2 rounded-lg w-full text-left transition-all ${getUserStyle('tom').bg} hover:${getUserStyle('tom').border} opacity-75`}
                            >
                                <span className="text-3xl">üêò</span>
                                <div>
                                    <div className={`font-medium text-lg ${getUserStyle('tom').text}`}>Tom le jeune √©l√©phanteau</div>
                                    <div className="text-sm text-gray-600">Le jeune aventurier (mode local)</div>
                                </div>
                            </button>
                            <button
                                onClick={() => onUserChange('lambert')}
                                className={`flex items-center space-x-3 p-4 border-2 rounded-lg w-full text-left transition-all ${getUserStyle('lambert').bg} hover:${getUserStyle('lambert').border} opacity-75`}
                            >
                                <span className="text-3xl">üêò</span>
                                <div>
                                    <div className={`font-medium text-lg ${getUserStyle('lambert').text}`}>Lambert, le vieux pachiderme</div>
                                    <div className="text-sm text-gray-600">Le sage guide (mode local)</div>
                                </div>
                            </button>
                        </div>
                    </div>
                ) : (
                    <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                        <div className="bg-white p-6 rounded-lg shadow-md hover:shadow-lg transition-shadow cursor-pointer opacity-75" onClick={() => onPageChange('sessions')}>
                            <div className="text-center">
                                <Play className="w-12 h-12 text-blue-600 mx-auto mb-4" />
                                <h3 className="text-lg font-semibold text-gray-900 mb-2">Sessions</h3>
                                <p className="text-gray-600 text-sm">Cr√©er ou reprendre (mode local)</p>
                                <div className="text-xs text-red-600 mt-2">‚ö†Ô∏è Non synchronis√©</div>
                            </div>
                        </div>
                        <div className="bg-white p-6 rounded-lg shadow-md hover:shadow-lg transition-shadow cursor-pointer" onClick={() => onPageChange('memories')}>
                            <div className="text-center">
                                <Cloud className="w-12 h-12 text-green-600 mx-auto mb-4" />
                                <h3 className="text-lg font-semibold text-gray-900 mb-2">M√©moires</h3>
                                <p className="text-gray-600 text-sm">Explorer le blog et les photos</p>
                            </div>
                        </div>
                        <div className="bg-white p-6 rounded-lg shadow-md hover:shadow-lg transition-shadow cursor-pointer" onClick={() => onPageChange('settings')}>
                            <div className="text-center">
                                <Settings className="w-12 h-12 text-purple-600 mx-auto mb-4" />
                                <h3 className="text-lg font-semibold text-gray-900 mb-2">R√©glages</h3>
                                <p className="text-gray-600 text-sm">Configuration et reconnexion</p>
                            </div>
                        </div>
                    </div>
                )}
            </div>
        );
    }

    // Mode "Connected" - Fonctionnement normal
    return (
        <div className="space-y-6 fade-in">
            <div className="text-center">
                <h2 className="text-2xl font-bold text-amber-900 mb-4">
                    Bienvenue dans vos m√©moires du M√©kong
                </h2>
                {currentUser && (
                    <p className="text-amber-700 mb-6">
                        Bonjour <strong>{USERS[currentUser]?.name}</strong> ! Que souhaitez-vous faire aujourd'hui ?
                    </p>
                )}
            </div>

            {!currentUser ? (
                <div className="max-w-md mx-auto space-y-4">
                    <h3 className="text-lg font-semibold text-amber-900 text-center">Qui √™tes-vous ?</h3>
                    <div className="space-y-3">
                        <button
                            onClick={() => onUserChange('tom')}
                            className={`flex items-center space-x-3 p-4 border-2 rounded-lg w-full text-left transition-all ${getUserStyle('tom').bg} hover:${getUserStyle('tom').border}`}
                        >
                            <span className="text-3xl">üêò</span>
                            <div>
                                <div className={`font-medium text-lg ${getUserStyle('tom').text}`}>Tom le jeune √©l√©phanteau</div>
                                <div className="text-sm text-gray-600">Le jeune aventurier</div>
                            </div>
                        </button>
                        <button
                            onClick={() => onUserChange('lambert')}
                            className={`flex items-center space-x-3 p-4 border-2 rounded-lg w-full text-left transition-all ${getUserStyle('lambert').bg} hover:${getUserStyle('lambert').border}`}
                        >
                            <span className="text-3xl">üêò</span>
                            <div>
                                <div className={`font-medium text-lg ${getUserStyle('lambert').text}`}>Lambert, le vieux pachiderme</div>
                                <div className="text-sm text-gray-600">Le sage guide</div>
                            </div>
                        </button>
                        <button
                            onClick={() => onUserChange('duo')}
                            className={`flex items-center space-x-3 p-4 border-2 rounded-lg w-full text-left transition-all ${getUserStyle('duo').bg} hover:${getUserStyle('duo').border}`}
                        >
                            <span className="text-3xl">üêòüêò</span>
                            <div>
                                <div className={`font-medium text-lg ${getUserStyle('duo').text}`}>Duo Mekong Tandem</div>
                                <div className="text-sm text-gray-600">Session p√®re-fils</div>
                            </div>
                        </button>
                    </div>
                </div>
            ) : (
                <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
                    <div className="bg-white p-6 rounded-lg shadow-md hover:shadow-lg transition-shadow cursor-pointer" onClick={() => onPageChange('sessions')}>
                        <div className="text-center">
                            <Play className="w-12 h-12 text-blue-600 mx-auto mb-4" />
                            <h3 className="text-lg font-semibold text-gray-900 mb-2">Sessions</h3>
                            <p className="text-gray-600 text-sm">Cr√©er ou reprendre une session de rem√©moration</p>
                        </div>
                    </div>
                    <div className="bg-white p-6 rounded-lg shadow-md hover:shadow-lg transition-shadow cursor-pointer" onClick={() => onPageChange('memories')}>
                        <div className="text-center">
                            <Cloud className="w-12 h-12 text-green-600 mx-auto mb-4" />
                            <h3 className="text-lg font-semibold text-gray-900 mb-2">M√©moires</h3>
                            <p className="text-gray-600 text-sm">Explorer le blog Mastodon et les photos</p>
                        </div>
                    </div>
                    <div className="bg-white p-6 rounded-lg shadow-md hover:shadow-lg transition-shadow cursor-pointer" onClick={() => onPageChange('settings')}>
                        <div className="text-center">
                            <Settings className="w-12 h-12 text-purple-600 mx-auto mb-4" />
                            <h3 className="text-lg font-semibold text-gray-900 mb-2">R√©glages</h3>
                            <p className="text-gray-600 text-sm">Configuration et pr√©f√©rences</p>
                        </div>
                    </div>
                </div>
            )}
        </div>
    );
};
		
		// Page Games - AVEC VRAI SPINNER CENTRAL
// Page Games - AVEC PROP EXTERNE
const GamesPage = ({ currentUser, onPageChange, onGameSelect, isCreatingSession }) => {

    if (isCreatingSession) {
        return (
            <div className="space-y-6 fade-in">
                <LoadingSpinner message="Cr√©ation de votre session de m√©moire..." size="normal" />
            </div>
        );
    }

    return (
        <div className="space-y-6 fade-in">
            <div className="flex justify-between items-center">
                <h2 className="text-2xl font-bold text-amber-900">Catalogue de jeux de rem√©moration</h2>
                <button
                    onClick={() => {
                        const randomGame = GAMES[Math.floor(Math.random() * GAMES.length)];
                        onGameSelect(randomGame);
                    }}
                    className="flex items-center space-x-2 px-4 py-2 bg-purple-500 hover:bg-purple-600 text-white rounded-lg"
                    disabled={isCreatingSession}
                >
                    <Shuffle className="w-4 h-4" />
                    <span>Jeu au hasard</span>
                </button>
            </div>

            <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                {GAMES.map(game => {
                    const IconComponent = game.icon;
                    return (
                        <button
                            key={game.id}
                            onClick={() => onGameSelect(game)}
                            disabled={isCreatingSession}
                            className="p-6 border-2 border-gray-200 rounded-lg hover:border-amber-300 hover:bg-amber-50 transition-all text-left group disabled:opacity-50 disabled:cursor-wait"
                        >
                            <div className="flex items-start space-x-4">
                                <IconComponent className="w-8 h-8 text-amber-600 mt-1 flex-shrink-0" />
                                <div className="flex-1">
                                    <div className="flex justify-between items-start mb-2">
                                        <h3 className="font-semibold text-lg text-amber-900 group-hover:text-amber-800">
                                            {game.title}
                                        </h3>
                                        <span className="text-xs bg-gray-100 px-2 py-1 rounded text-gray-600">
                                            {game.duration}
                                        </span>
                                    </div>
                                    <p className="text-gray-600 text-sm leading-relaxed mb-2">
                                        {game.description}
                                    </p>
                                    <div className="flex justify-between items-center">
                                        <div className="text-xs text-amber-600 font-medium">
                                            {game.type}
                                        </div>
                                        <div className="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded">
                                            ‚ñ∂Ô∏è Cr√©er session
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </button>
                    );
                })}
            </div>

            <div className="bg-amber-50 border border-amber-200 rounded-lg p-4">
                <h3 className="font-semibold text-amber-900 mb-2">üí° Comment √ßa marche ?</h3>
                <p className="text-amber-700 text-sm">
                    Choisissez un jeu pour cr√©er une nouvelle session de rem√©moration. 
                    Vous pourrez ensuite √©changer vos souvenirs dans un format de chat convivial.
                </p>
            </div>
        </div>
    );
};
		
    // Page Session (MODIFI√âE - Loading suppression + Derni√®re modification)
const SessionsPage = ({ currentUser, onPageChange, onSessionSelect }) => {
    const { sessions, deleteSession, renderGameIcon, syncSessions, isDeletingSession } = useSessionState(); // NOUVEAU: isDeletingSession
    const [isSyncing, setIsSyncing] = React.useState(true);
    const [syncComplete, setSyncComplete] = React.useState(false);

    // Synchronisation automatique au montage
    React.useEffect(() => {
        const performInitialSync = async () => {
            try {
                setIsSyncing(true);
                await syncSessions();
                setSyncComplete(true);
            } catch (error) {
                console.error('Erreur synchronisation initiale:', error);
                setSyncComplete(true);
            } finally {
                setIsSyncing(false);
            }
        };
        performInitialSync();
    }, []);

    const formatDate = (dateString) => {
        return new Date(dateString).toLocaleDateString('fr-FR', { 
            day: 'numeric', month: 'short', hour: '2-digit', minute: '2-digit'
        });
    };

    const getLastModifier = (session) => {
        if (!session.notes || session.notes.length === 0) {
            return session.user;
        }
        const lastNote = session.notes[session.notes.length - 1];
        return lastNote.author || session.user;
    };

    const getLastModificationDate = (session) => {
        if (!session.notes || session.notes.length === 0) {
            return session.createdAt;
        }
        const lastNote = session.notes[session.notes.length - 1];
        const lastNoteDate = new Date(lastNote.timestamp);
        const sessionUpdateDate = new Date(session.updatedAt);
        return lastNoteDate > sessionUpdateDate ? lastNote.timestamp : session.updatedAt;
    };

    // NOUVEAU: Fonction de suppression avec confirmation
    const handleDeleteSession = async (sessionId, sessionTitle) => {
        if (!confirm(`Supprimer la session "${sessionTitle}" ?`)) return;
        
        try {
            await deleteSession(sessionId);
        } catch (error) {
            alert('Erreur lors de la suppression: ' + error.message);
        }
    };
    
    const statusIcons = {
        active: { icon: Play, color: 'text-green-500', title: 'Active' },
        paused: { icon: Pause, color: 'text-orange-500', title: 'En pause' },
        pending: { icon: Clock, color: 'text-blue-500', title: 'En attente' },
        completed: { icon: FileText, color: 'text-gray-500', title: 'Termin√©e' }
    };

    return (
        <div className="space-y-4 fade-in">
            <div className="flex justify-between items-center">
                <button
                    onClick={() => onPageChange('games')}
                    className="w-full flex items-center justify-center space-x-2 px-4 py-3 bg-amber-500 hover:bg-amber-600 text-white rounded-lg font-semibold shadow"
                >
                    <Plus className="w-5 h-5" />
                    <span>Nouveau Jeu de M√©moire</span>
                </button>
            </div>

            {isSyncing && !syncComplete ? (
                <LoadingSpinner message="Synchronisation des sessions..." />
            ) : sessions.length === 0 ? (
                <div className="text-center py-12 bg-gray-50 rounded-lg">
                    <FileText className="w-16 h-16 text-gray-300 mx-auto mb-4" />
                    <h3 className="text-lg font-medium text-gray-600 mb-2">Aucune session</h3>
                    <p className="text-gray-500 mb-6">Cr√©ez votre premi√®re session de m√©moire</p>
                    <button
                        onClick={() => onPageChange('games')}
                        className="px-6 py-3 bg-amber-500 hover:bg-amber-600 text-white rounded-lg font-medium"
                    >
                        Commencer un jeu
                    </button>
                </div>
            ) : (
                <div className="space-y-3">
                    {sessions.map((session) => {
                        const StatusIcon = statusIcons[session.status]?.icon || FileText;
                        const statusColor = statusIcons[session.status]?.color || 'text-gray-500';
                        const statusTitle = statusIcons[session.status]?.title || 'Archiv√©e';
                        const lastModifier = getLastModifier(session);
                        const lastModificationDate = getLastModificationDate(session);
                        const userStyle = getUserStyle(lastModifier);
                        
                        // NOUVEAU: V√©rifier si cette session est en cours de suppression
                        const isBeingDeleted = isDeletingSession === session.id;

                        return (
                            <div
                                key={session.id}
                                className={`bg-white p-3 rounded-lg border border-gray-200 transition-all flex items-center space-x-3 ${
                                    isBeingDeleted 
                                        ? 'opacity-50 cursor-wait' 
                                        : 'hover:border-amber-400 cursor-pointer'
                                }`}
                                onClick={() => !isBeingDeleted && onSessionSelect(session)}
                            >
                                <div 
                                    className={`w-12 h-12 rounded-full border-2 ${userStyle.bg} ${userStyle.border} flex items-center justify-center flex-shrink-0 shadow-sm ${
                                        isBeingDeleted ? 'opacity-50' : ''
                                    }`}
                                    title={`Derni√®re modification par ${USERS[lastModifier]?.name} le ${formatDate(lastModificationDate)}`}
                                >
                                    <span className="text-xl">{USERS[lastModifier]?.emoji || 'üêò'}</span>
                                </div>

                                <div className="flex-1">
                                    <div className="flex justify-between items-start">
                                        <h3 className={`font-bold pr-2 ${isBeingDeleted ? 'text-gray-500' : 'text-gray-800'}`}>
                                            {session.gameTitle}
                                        </h3>
                                        <span className="text-xs text-gray-400 whitespace-nowrap">
                                            {(session.notes || []).length} notes
                                        </span>
                                    </div>
                                    <div className="flex items-center justify-between mt-1">
                                        <span className={`text-xs ${isBeingDeleted ? 'text-gray-400' : 'text-gray-500'}`}>
                                            {formatDate(lastModificationDate)}
                                        </span>
                                        <div className="flex items-center space-x-2">
                                            <StatusIcon className={`w-5 h-5 ${statusColor} ${isBeingDeleted ? 'opacity-50' : ''}`} title={statusTitle} />
                                            
                                            {/* NOUVEAU: Bouton de suppression avec spinner */}
                                            <button
                                                onClick={(e) => {
                                                    e.stopPropagation();
                                                    if (!isBeingDeleted) {
                                                        handleDeleteSession(session.id, session.gameTitle);
                                                    }
                                                }}
                                                disabled={isBeingDeleted}
                                                className="p-1 text-gray-400 hover:text-red-600 hover:bg-red-50 rounded-full disabled:cursor-wait"
                                            >
                                                {isBeingDeleted ? (
                                                    <div className="animate-spin w-4 h-4 border-2 border-red-400 border-t-transparent rounded-full"></div>
                                                ) : (
                                                    <Trash2 className="w-4 h-4" />
                                                )}
                                            </button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        );
                    })}
                </div>
            )}
        </div>
    );
}; 
// ===== COMPOSANT MESSAGE CONTENT - AFFICHAGE INTELLIGENT DES IMAGES =====
const MessageContent = ({ content }) => {
    const [processedContent, setProcessedContent] = React.useState(content);
    const [loadingImages, setLoadingImages] = React.useState(new Set());
    
    React.useEffect(() => {
        const processImagesInContent = async () => {
            // Rechercher toutes les balises [IMAGE]...[/IMAGE]
            const imageRegex = /\[IMAGE\](https:\/\/drive\.google\.com\/uc\?id=([^&]+)[^)]*)\[\/IMAGE\]/g;
            let match;
            let newContent = content;
            const imagesToLoad = [];
            
            while ((match = imageRegex.exec(content)) !== null) {
                const [fullMatch, driveUrl, fileId] = match;
                imagesToLoad.push({ fullMatch, driveUrl, fileId });
            }
            
            if (imagesToLoad.length === 0) {
                setProcessedContent(content);
                return;
            }
            
            // Marquer les images comme en cours de chargement
            const loadingIds = new Set(imagesToLoad.map(img => img.fileId));
            setLoadingImages(loadingIds);
            
            // Traiter chaque image
            for (const { fullMatch, driveUrl, fileId } of imagesToLoad) {
                try {
                    console.log('üñºÔ∏è Chargement image en base64:', fileId);
                    
                    // D√©terminer le type MIME (par d√©faut JPEG)
                    const mimeType = 'image/jpeg'; // On peut am√©liorer √ßa plus tard
                    
                    // Charger l'image en base64
                    const base64Data = await GoogleDriveAPI.getPhotoAsBase64(fileId, mimeType);
                    
                    if (base64Data) {
                        // Remplacer la balise par une balise img HTML
                        const imageHTML = `<img src="${base64Data}" alt="Photo du voyage" class="max-w-full h-auto rounded-lg shadow-md my-2" style="max-height: 300px; object-fit: contain;" />`;
                        newContent = newContent.replace(fullMatch, imageHTML);
                        console.log('‚úÖ Image remplac√©e en base64');
                    } else {
                        // Si le chargement base64 √©choue, garder l'URL originale
                        const imageHTML = `<img src="${driveUrl}" alt="Photo du voyage" class="max-w-full h-auto rounded-lg shadow-md my-2" style="max-height: 300px; object-fit: contain;" onerror="this.alt='Image non disponible'; this.className='text-red-500 italic'" />`;
                        newContent = newContent.replace(fullMatch, imageHTML);
                        console.log('‚ö†Ô∏è Fallback sur URL originale');
                    }
                } catch (error) {
                    console.error('‚ùå Erreur chargement image:', fileId, error);
                    // En cas d'erreur, remplacer par un texte d'erreur
                    const errorText = `<span class="text-red-500 italic text-sm">üì∑ Image non disponible</span>`;
                    newContent = newContent.replace(fullMatch, errorText);
                }
                
                // Retirer de la liste des images en cours de chargement
                setLoadingImages(prev => {
                    const next = new Set(prev);
                    next.delete(fileId);
                    return next;
                });
            }
            
            setProcessedContent(newContent);
        };
        
        processImagesInContent();
    }, [content]);
    
    // Si des images sont en cours de chargement, afficher un indicateur
    if (loadingImages.size > 0) {
        return (
            <div className="space-y-2">
                <div className="flex items-center space-x-2 text-blue-500 text-sm">
                    <div className="animate-spin rounded-full h-4 w-4 border-b-2 border-blue-500"></div>
                    <span>Chargement des images...</span>
                </div>
                <div dangerouslySetInnerHTML={{ __html: processedContent }} className="text-sm whitespace-pre-wrap" />
            </div>
        );
    }
    
    // Afficher le contenu trait√© (avec les images remplac√©es)
    return (
        <div dangerouslySetInnerHTML={{ __html: processedContent }} className="text-sm whitespace-pre-wrap" />
    );
};
		
// Page Chat (MODIFI√âE - HOOKS DANS LE BON ORDRE)
// Page Chat (VERSION 0.5.5.2 - AM√âLIOR√âE AVEC MESSAGECONTEN)
const ChatPage = ({ currentUser, currentSession, onUpdateSession, onBackToSessions }) => {
    const [newMessageContent, setNewMessageContent] = React.useState('');
    const [editingMessage, setEditingMessage] = React.useState(null);
    const [editContent, setEditContent] = React.useState('');
    const [editingTitle, setEditingTitle] = React.useState(false);
    const [titleContent, setTitleContent] = React.useState('');
    const [isSessionReady, setIsSessionReady] = React.useState(false);
    const [isSending, setIsSending] = React.useState(false);
    const messagesEndRef = React.useRef(null);

    // Auto-scroll vers le bas
    React.useEffect(() => {
        if (messagesEndRef.current) {
            messagesEndRef.current.scrollIntoView({ behavior: "smooth" });
        }
    }, [currentSession?.notes]);

    // V√©rifier si session valide
    React.useEffect(() => {
        if (currentSession && currentSession.gameId && currentSession.notes) {
            setIsSessionReady(true);
        }
    }, [currentSession]);

    if (!currentSession) {
        return (
            <div className="text-center py-12 text-gray-500 fade-in">
                <BookOpen className="w-16 h-16 mx-auto mb-4 opacity-30" />
                <h3 className="text-xl font-medium mb-2">Aucune session s√©lectionn√©e</h3>
                <p className="mb-4">S√©lectionnez une session pour commencer.</p>
                <button 
                    onClick={onBackToSessions}
                    className="px-4 py-2 bg-amber-500 text-white rounded-lg hover:bg-amber-600"
                >
                    Voir les sessions
                </button>
            </div>
        );
    }

    const handleUpdate = (updatedSession) => { 
        onUpdateSession(updatedSession); 
    };

    const sendMessage = async () => {
        if (!newMessageContent.trim() || isSending) return;
        
        setIsSending(true);
        try {
            const updatedSession = {
                ...currentSession,
                notes: [
                    ...(currentSession.notes || []), 
                    {
                        id: Date.now(),
                        content: newMessageContent.trim(),
                        author: currentUser,
                        timestamp: new Date().toISOString()
                    }
                ],
                lastModifiedBy: currentUser
            };
            
            await handleUpdate(updatedSession);
            setNewMessageContent('');
        } catch (error) {
            console.error('Erreur envoi message:', error);
        } finally {
            setIsSending(false);
        }
    };

    const startEditMessage = (message) => {
        setEditingMessage(message.id);
        setEditContent(message.content);
    };

    const saveEditMessage = async (messageId) => {
        if (!editContent.trim()) return;

        const updatedSession = {
            ...currentSession,
            notes: (currentSession.notes || []).map(note => 
                note.id === messageId 
                    ? { ...note, content: editContent.trim(), edited: true }
                    : note
            )
        };

        await handleUpdate(updatedSession);
        setEditingMessage(null);
        setEditContent('');
    };

    const cancelEdit = () => {
        setEditingMessage(null);
        setEditContent('');
    };

    const deleteMessage = async (messageId) => {
        if (!confirm('Supprimer ce message ?')) return;

        const updatedSession = {
            ...currentSession,
            notes: (currentSession.notes || []).filter(note => note.id !== messageId)
        };

        await handleUpdate(updatedSession);
    };

    const startEditTitle = () => {
        setTitleContent(currentSession.gameTitle);
        setEditingTitle(true);
    };

    const saveTitle = async () => {
        if (!titleContent.trim()) {
            setEditingTitle(false);
            return;
        }

        const updatedSession = {
            ...currentSession,
            gameTitle: titleContent.trim()
        };
        
        await handleUpdate(updatedSession);
        setEditingTitle(false);
    };

    const getBubbleStyle = (author) => {
        if (author === 'tom') return 'bg-blue-500 text-white';
        if (author === 'lambert') return 'bg-green-500 text-white'; 
        if (author === 'duo') return 'bg-amber-500 text-white';
        return 'bg-gray-500 text-white';
    };

    return (
        <div className="flex flex-col h-screen max-h-[85vh] fade-in">
            {/* Session Header */}
            <div className="bg-amber-50 border border-amber-200 rounded-lg p-3 mb-3 flex-shrink-0">
                <div className="flex items-center justify-between">
                    <div className="flex items-center space-x-3">
                        {renderGameIcon(currentSession.gameId, "w-6 h-6 text-amber-600")}
                        <div>
                            {editingTitle ? (
                                <input
                                    type="text"
                                    value={titleContent}
                                    onChange={(e) => setTitleContent(e.target.value)}
                                    onBlur={saveTitle}
                                    onKeyDown={(e) => e.key === 'Enter' && saveTitle()}
                                    className="font-bold text-amber-900 text-lg bg-white border border-amber-300 rounded px-2 py-1"
                                    autoFocus
                                />
                            ) : (
                                <div className="flex items-center space-x-2 group cursor-pointer" onClick={startEditTitle}>
                                    <h3 className="font-bold text-amber-900 text-lg">{currentSession.gameTitle}</h3>
                                    <Edit className="w-4 h-4 text-amber-400 opacity-0 group-hover:opacity-100 transition-opacity" />
                                </div>
                            )}
                        </div>
                    </div>
                    
                    <div className="flex items-center space-x-2">
                        <button
                            onClick={onBackToSessions}
                            className="p-2 text-amber-600 hover:bg-amber-100 rounded-lg"
                            title="Retour aux sessions"
                        >
                            <ArrowLeft className="w-5 h-5" />
                        </button>
                    </div>
                </div>
            </div>

            {/* Messages Container */}
            <div className="flex-1 bg-gray-50 rounded-lg border overflow-y-auto p-4 space-y-3">
                {(!currentSession.notes || currentSession.notes.length === 0) ? (
                    <div className="text-center py-12 text-gray-500">
                        <BookOpen className="w-12 h-12 mx-auto mb-3 opacity-30" />
                        <p className="text-lg font-medium mb-2">Aucun message</p>
                        <p className="text-sm">Commencez la conversation en √©crivant vos souvenirs !</p>
                    </div>
                ) : (
                    <>
                        <div className="text-center py-2 border-b border-gray-200 mb-4">
                            <div className="text-sm text-gray-600">
                                Conversation entre <span className="font-medium text-blue-700">{USERS.tom?.name}</span> et <span className="font-medium text-green-700">{USERS.lambert?.name}</span>
                            </div>
                        </div>

                        {(currentSession.notes || []).map((message) => {
                            const isOwnMessage = message.author === currentUser;
                            const isEditing = editingMessage === message.id;

                            return (
                                <div key={message.id} className={`flex ${
                                    message.author === 'duo' ? 'justify-center' : 
                                    isOwnMessage ? 'justify-end' : 'justify-start'
                                }`}>
                                    <div className={`max-w-[75%] ${
                                        message.author === 'duo' ? '' : 
                                        isOwnMessage ? 'order-2' : 'order-1'
                                    }`}>
                                        <div className={`rounded-2xl px-4 py-3 ${getBubbleStyle(message.author)} ${isOwnMessage ? 'rounded-br-md' : 'rounded-bl-md'} relative group`}>
                                            {isEditing ? (
                                                <div className="space-y-2">
                                                    <textarea
                                                        value={editContent}
                                                        onChange={(e) => setEditContent(e.target.value)}
                                                        className="w-full bg-white text-gray-800 rounded p-2 text-sm resize-none"
                                                        rows="3"
                                                        autoFocus
                                                    />
                                                    <div className="flex space-x-2">
                                                        <button
                                                            onClick={() => saveEditMessage(message.id)}
                                                            className="px-3 py-1 bg-white text-green-600 rounded text-xs font-medium"
                                                        >
                                                            Sauver
                                                        </button>
                                                        <button
                                                            onClick={cancelEdit}
                                                            className="px-3 py-1 bg-white text-gray-600 rounded text-xs font-medium"
                                                        >
                                                            Annuler
                                                        </button>
                                                    </div>
                                                </div>
                                            ) : (
                                                <>
                                                    <MessageContent content={message.content} />
                                                    {message.edited && (
                                                        <span className="text-xs opacity-70 italic">modifi√©</span>
                                                    )}
                                                    
                                                    {isOwnMessage && (
                                                        <div className="absolute top-1 right-1 opacity-0 group-hover:opacity-100 transition-opacity">
                                                            <button
                                                                onClick={() => startEditMessage(message)}
                                                                className="p-1 bg-white bg-opacity-20 hover:bg-opacity-40 rounded text-xs"
                                                                title="Modifier"
                                                            >
                                                                <Edit className="w-3 h-3" />
                                                            </button>
                                                            <button
                                                                onClick={() => deleteMessage(message.id)}
                                                                className="p-1 bg-white bg-opacity-20 hover:bg-opacity-40 rounded text-xs ml-1"
                                                                title="Supprimer"
                                                            >
                                                                <Trash2 className="w-3 h-3" />
                                                            </button>
                                                        </div>
                                                    )}
                                                </>
                                            )}
                                        </div>
                                        
                                        {/* Timestamp */}
                                        <div className={`text-xs text-gray-500 mt-1 ${
                                            isOwnMessage ? 'text-right' : 'text-left'
                                        }`}>
                                            {new Date(message.timestamp).toLocaleTimeString('fr-FR', { 
                                                hour: '2-digit', 
                                                minute: '2-digit' 
                                            })}
                                        </div>
                                    </div>
                                </div>
                            );
                        })}
                        <div ref={messagesEndRef} />
                    </>
                )}
            </div>

            {/* Message Input */}
            <div className="bg-white border-t p-4 flex-shrink-0">
                <div className="flex space-x-2">
                    <textarea
                        value={newMessageContent}
                        onChange={(e) => setNewMessageContent(e.target.value)}
                        onKeyDown={(e) => {
                            if (e.key === 'Enter' && !e.shiftKey) {
                                e.preventDefault();
                                sendMessage();
                            }
                        }}
                        placeholder="√âcrivez votre message... (Entr√©e pour envoyer)"
                        className="flex-1 p-3 border border-gray-300 rounded-lg resize-none focus:ring-2 focus:ring-amber-500 focus:border-amber-500"
                        rows="2"
                        disabled={isSending}
                    />
                    <button
                        onClick={sendMessage}
                        disabled={!newMessageContent.trim() || isSending}
                        className="px-4 py-3 bg-amber-500 text-white rounded-lg hover:bg-amber-600 disabled:opacity-50 disabled:cursor-not-allowed flex items-center"
                        title="Envoyer"
                    >
                        {isSending ? (
                            <div className="animate-spin w-5 h-5 border-2 border-white border-t-transparent rounded-full"></div>
                        ) : (
                            <Send className="w-6 h-6" />
                        )}
                    </button>
                </div>
            </div>
        </div>
    );
};

	
// Page Memoire (V4.5 - Recherche des photos dans l'arborescence d'origine du blog)
const MemoriesPage = ({ currentUser, onCreateSession, isCreatingSession }) => {
    const [currentDay, setCurrentDay] = React.useState(1);
    const [activeTab, setActiveTab] = React.useState('blog');
    const [currentPost, setCurrentPost] = React.useState(null);
    const [dayPhotos, setDayPhotos] = React.useState([]);
    const [blogPhotos, setBlogPhotos] = React.useState([]);
    const [isLoadingPhotos, setIsLoadingPhotos] = React.useState(false);
    const [selectedPhotoIndex, setSelectedPhotoIndex] = React.useState(null);
    const [photoSource, setPhotoSource] = React.useState('day'); // 'day' ou 'blog'

    const isMastodonImported = MastodonData.isImported();
    const mastodonStats = MastodonData.getStats();
    const isPhotoIndexImported = PhotoData.isImported();

    React.useEffect(() => {
        const loadDataForDay = async () => {
            let hasContent = false;
            // Charger les donn√©es du blog
            if (isMastodonImported) {
                const post = MastodonData.getPostByDay(currentDay);
                setCurrentPost(post);
                if (post) {
                    hasContent = true;
                    await loadBlogPhotos(post);
                } else {
                    setBlogPhotos([]);
                }
            } else {
                setCurrentPost(null);
                setBlogPhotos([]);
            }

            // Charger les photos de l'index pour le jour en cours, quel que soit l'onglet
            if (isPhotoIndexImported) {
                const photosInIndex = PhotoData.getPhotosByDay(currentDay);
                if (photosInIndex.length > 0) {
                    hasContent = true;
                    await loadPhotosForDay(currentDay);
                } else {
                    setDayPhotos([]);
                }
            } else {
                setDayPhotos([]);
            }
            if (!hasContent) setDayPhotos([]);
        };
        loadDataForDay();
    }, [currentDay, isMastodonImported, isPhotoIndexImported]);

    const cleanThumbnailLink = (url) => {
        if (!url) return null;
        return url.split('=')[0];
    };

    const loadPhotosForDay = async (day) => {
        setIsLoadingPhotos(true);
        setDayPhotos([]);
        if (!GoogleDriveAPI.isSignedIn) {
            setIsLoadingPhotos(false);
            return;
        }
        const photoIndexEntries = PhotoData.getPhotosByDay(day);
        if (photoIndexEntries.length === 0) {
            setIsLoadingPhotos(false);
            return;
        }

        const foldersToQuery = photoIndexEntries.reduce((acc, photo) => {
            if (!acc[photo.folderName]) acc[photo.folderName] = [];
            acc[photo.folderName].push(photo.filename);
            return acc;
        }, {});

        let allFoundPhotos = [];
        const FOLDER_MIME_TYPE = 'application/vnd.google-apps.folder';
        const mediasFolder = await GoogleDriveAPI._findFile('Medias', 'root', FOLDER_MIME_TYPE);
        if (!mediasFolder) { setIsLoadingPhotos(false); return; }
        const photosRootFolder = await GoogleDriveAPI._findFile('Photos', mediasFolder.id, FOLDER_MIME_TYPE);
        if (!photosRootFolder) { setIsLoadingPhotos(false); return; }

        for (const folderName in foldersToQuery) {
            const dayFolder = await GoogleDriveAPI._findFile(folderName, photosRootFolder.id, FOLDER_MIME_TYPE);
            if (dayFolder) {
                const filesInDrive = await GoogleDriveAPI.listPhotoFiles(dayFolder.id);
                const driveFilesMap = new Map(filesInDrive.map(file => [file.name, file]));
                const photosInThisFolder = foldersToQuery[folderName];
                for (const filename of photosInThisFolder) {
                    if (driveFilesMap.has(filename)) {
                        const fileData = driveFilesMap.get(filename);
                        allFoundPhotos.push({
                            id: fileData.id,
                            filename: filename,
                            webContentLink: fileData.webContentLink,
                            thumbnailLink: cleanThumbnailLink(fileData.thumbnailLink),
                            mimeType: fileData.mimeType || 'image/jpeg'
                        });
                    }
                }
            }
        }
        setDayPhotos(allFoundPhotos);
        setIsLoadingPhotos(false);
    };

    const loadBlogPhotos = async (post) => {
    console.log('üîç === DEBUG loadBlogPhotos ===');
    console.log('üìù Post re√ßu:', post);
    console.log('üìé Attachments dans le post:', post.attachments);
    
    if (!post || !GoogleDriveAPI.isSignedIn) {
        console.log('‚ùå Condition d\'arr√™t: post vide ou non connect√© √† Drive');
        setBlogPhotos([]);
        return;
    }
    
    const FOLDER_MIME_TYPE = 'application/vnd.google-apps.folder';
    
    // 1. Recherche du dossier racine
    console.log('üîç Recherche du dossier Medias...');
    const mediasFolder = await GoogleDriveAPI._findFile('Medias', 'root', FOLDER_MIME_TYPE);
    console.log('üìÅ Medias folder:', mediasFolder);
    
    if (!mediasFolder) { 
        console.log('‚ùå Dossier Medias non trouv√©');
        setBlogPhotos([]); 
        return; 
    }
    
    console.log('üîç Recherche du dossier Mastodon...');
    const mastodonFolder = await GoogleDriveAPI._findFile('Mastodon', mediasFolder.id, FOLDER_MIME_TYPE);
    console.log('üìÅ Mastodon folder:', mastodonFolder);
    
    if (!mastodonFolder) { 
        console.log('‚ùå Dossier Mastodon non trouv√©');
        setBlogPhotos([]); 
        return; 
    }
    
    console.log('üîç Recherche du dossier media_attachments...');
    const mediaAttachmentsFolder = await GoogleDriveAPI._findFile('media_attachments', mastodonFolder.id, FOLDER_MIME_TYPE);
    console.log('üìÅ media_attachments folder:', mediaAttachmentsFolder);
    
    if (!mediaAttachmentsFolder) { 
        console.log('‚ùå Dossier media_attachments non trouv√©');
        setBlogPhotos([]); 
        return; 
    }
    
    // 2. Lister tous les fichiers
    console.log('üîç Listing de tous les fichiers dans media_attachments...');
    const allBlogFiles = await GoogleDriveAPI.listAllFiles(mediaAttachmentsFolder.id);
    console.log('üìÑ Tous les fichiers trouv√©s:', allBlogFiles);
    console.log('üìä Nombre total de fichiers:', allBlogFiles.length);
    
    const driveFilesMap = new Map(allBlogFiles.map(file => [file.name, file]));
    console.log('üó∫Ô∏è Map des fichiers cr√©√©e, taille:', driveFilesMap.size);
    
    // 3. Processing des attachments
    console.log('‚öôÔ∏è Processing des attachments du post...');
    const photosForPost = post.attachments.map((att, index) => {
        console.log(`üìé Attachment ${index}:`, att);
        
        if (!att.url) {
            console.log(`‚ùå Attachment ${index}: pas d'URL`);
            return null;
        }
        
        const filename = att.url.split('/').pop();
        console.log(`üìÑ Filename extrait: "${filename}"`);
        
        const driveFile = driveFilesMap.get(filename);
        console.log(`üîç Fichier trouv√© sur Drive:`, driveFile);
        
        if (driveFile) {
            const photoData = {
                id: driveFile.id,
                filename: filename,
                webContentLink: driveFile.webContentLink,
                thumbnailLink: cleanThumbnailLink(driveFile.thumbnailLink),
                mimeType: driveFile.mimeType || 'image/jpeg'
            };
            console.log(`‚úÖ Photo cr√©√©e:`, photoData);
            return photoData;
        } else {
            console.log(`‚ùå Fichier "${filename}" non trouv√© sur Drive`);
            return null;
        }
    }).filter(Boolean);
    
    console.log('üì∏ Photos finales pour le post:', photosForPost);
    console.log('üìä Nombre de photos trouv√©es:', photosForPost.length);
    
    setBlogPhotos(photosForPost);
    console.log('‚úÖ === FIN DEBUG loadBlogPhotos ===');
};

    const handleDaySelect = (day) => setCurrentDay(day);
    const createSessionFromPost = (post) => {
        const game = getGameById(7);
        const postPreview = post.content.slice(0, 200) + '...';
        onCreateSession({ type: 'game', game: { ...game, title: post.title || `Jour ${post.dayNumber} - Souvenir` }, postContent: postPreview });
    };
    const createSessionFromPhoto = (photo) => {
        const game = { id: 1, title: `Souvenir photo du jour ${photo.day || 'inconnu'}` };
        const initialNoteContent = `[IMAGE]${photo.webContentLink}[/IMAGE]\n\n√Ä propos de cette photo : ${photo.filename}`;
        onCreateSession({ type: 'game', game: game, postContent: initialNoteContent });
    };
    const handlePhotoSelect = (index, source) => {
        setSelectedPhotoIndex(index);
        setPhotoSource(source);
    };
    const handlePhotoNavigate = (direction) => {
        const photos = photoSource === 'blog' ? blogPhotos : dayPhotos;
        if (direction === 'prev' && selectedPhotoIndex > 0) setSelectedPhotoIndex(selectedPhotoIndex - 1);
        else if (direction === 'next' && selectedPhotoIndex < photos.length - 1) setSelectedPhotoIndex(selectedPhotoIndex + 1);
    };

    if (isCreatingSession) return <LoadingSpinner message="Cr√©ation de session..." size="large" />;

    return (
        <div className="space-y-6 fade-in">
            <Timeline currentDay={currentDay} maxDay={mastodonStats?.dayRange?.max || 275} onDaySelect={handleDaySelect} />
            <div className="flex justify-center border-b border-gray-200">
                <button onClick={() => setActiveTab('blog')} className={`px-6 py-3 text-sm font-semibold ${activeTab === 'blog' ? 'border-b-2 border-amber-500 text-amber-600' : 'text-gray-500'}`} disabled={!isMastodonImported}><BookOpen className="w-5 h-5 inline mr-2" />Blog</button>
                <button onClick={() => setActiveTab('photos')} className={`px-6 py-3 text-sm font-semibold ${activeTab === 'photos' ? 'border-b-2 border-amber-500 text-amber-600' : 'text-gray-500'}`} disabled={!isPhotoIndexImported}><Camera className="w-5 h-5 inline mr-2" />Photos</button>
            </div>
            <div className="bg-white p-4 sm:p-6 rounded-lg border border-gray-200 min-h-[300px]">
                {activeTab === 'photos' ? (
                    isLoadingPhotos ? <LoadingSpinner message="Chargement des photos..." /> : <PhotoGrid photos={dayPhotos} onPhotoSelect={(index) => handlePhotoSelect(index, 'day')} />
                ) : (
                    currentPost ? (
                        <div>
                            <div className="flex justify-between items-start mb-4">
                                <div className="flex flex-col">
                                    <h3 className="text-xl font-bold text-amber-900">{currentPost.title || `Jour ${currentPost.dayNumber}`}</h3>
                                    {blogPhotos.length > 0 && (
                                        <span className="text-sm text-gray-500 mt-1">
                                            <Camera className="w-4 h-4 inline mr-1" />
                                            {blogPhotos.length} photo{blogPhotos.length > 1 ? 's' : ''} associ√©e{blogPhotos.length > 1 ? 's' : ''}
                                        </span>
                                    )}
                                </div>
                                <button onClick={() => createSessionFromPost(currentPost)} className="flex items-center space-x-2 px-3 py-2 bg-green-500 text-white rounded-lg text-sm"><Plus className="w-4 h-4" /><span>Session</span></button>
                            </div>
                            <div className="prose max-w-none mb-6">
                                <p>{currentPost.content}</p>
                            </div>

                            {/* Section pour les miniatures du blog */}
                            {blogPhotos.length > 0 && (
                                <div className="grid grid-cols-4 sm:grid-cols-6 md:grid-cols-8 gap-2 mt-4">
                                    {blogPhotos.map((photo, index) => (
                                        <button
                                            key={photo.filename}
                                            onClick={() => handlePhotoSelect(index, 'blog')}
                                            className="aspect-square bg-gray-200 rounded-md overflow-hidden hover:opacity-80 transition-opacity focus:outline-none focus:ring-2 focus:ring-amber-500"
                                        >
                                            <img
                                                src={photo.thumbnailLink}
                                                alt={`Thumbnail of ${photo.filename}`}
                                                className="w-full h-full object-cover"
                                            />
                                        </button>
                                    ))}
                                </div>
                            )}
                        </div>
                    ) : (
                        <div className="text-center py-12 text-gray-500"><BookOpen className="w-12 h-12 mx-auto mb-3 opacity-30" /><p>Aucun post de blog pour ce jour.</p></div>
                    )
                )}
            </div>
            {selectedPhotoIndex !== null && (
                <PhotoViewer
                    photos={photoSource === 'blog' ? blogPhotos : dayPhotos}
                    selectedIndex={selectedPhotoIndex}
                    onClose={() => setSelectedPhotoIndex(null)}
                    onNavigate={handlePhotoNavigate}
                    onCreateSession={createSessionFromPhoto}
                />
            )}
        </div>
    );
};
		
		
// ====Pages Config r√©glages Settings  =====		
const SettingsPage = ({ onReset, googleAuth, onGoogleDisconnect }) => {
    const [mastodonImportStatus, setMastodonImportStatus] = React.useState('');
    const [isImportingMastodon, setIsImportingMastodon] = React.useState(false);
    const mastodonFileInputRef = React.useRef(null);

    // √âtats pour l'import de l'index des photos
    const [photoImportStatus, setPhotoImportStatus] = React.useState('');
    const [isImportingPhotos, setIsImportingPhotos] = React.useState(false);
    const photoFileInputRef = React.useRef(null);

    const { isConnected, isLoading, userInfo, signIn, signOut } = googleAuth;

    const mastodonStats = MastodonData.getStats();
    const isMastodonImported = MastodonData.isImported();
    
    // Stats pour les photos
    const photoStats = PhotoData.getStats();
    const isPhotoIndexImported = PhotoData.isImported();

    const handleMastodonImport = async (event) => {
        const file = event.target.files[0];
        if (!file) return;

        setIsImportingMastodon(true);
        setMastodonImportStatus('Lecture du fichier...');
        try {
            const text = await file.text();
            setMastodonImportStatus('Analyse des donn√©es...');
            const posts = MastodonData.parseOutbox(text);
            MastodonData.savePosts(posts);
            setMastodonImportStatus(`Succ√®s ! ${posts.length} posts import√©s`);
            setTimeout(() => setMastodonImportStatus(''), 3000);
        } catch (error) {
            setMastodonImportStatus(`Erreur: ${error.message}`);
        } finally {
            setIsImportingMastodon(false);
            if (mastodonFileInputRef.current) {
                mastodonFileInputRef.current.value = '';
            }
        }
    };

    const handleMastodonDriveImport = async () => {
        if (!isConnected) {
            setMastodonImportStatus("Veuillez vous connecter √† Google Drive d'abord.");
            return;
        }
        setIsImportingMastodon(true);
        setMastodonImportStatus('Recherche du fichier outbox.json sur votre Drive...');
        try {
            const jsonData = await GoogleDriveAPI.loadJsonFile('outbox.json');
            if (!jsonData) {
                throw new Error("Fichier 'outbox.json' introuvable √† la racine de votre Google Drive.");
            }
            setMastodonImportStatus('Analyse des posts...');
            const posts = MastodonData.parseOutbox(jsonData);
            MastodonData.savePosts(posts);
            setMastodonImportStatus(`Succ√®s ! ${posts.length} posts import√©s.`);
        } catch (error) {
            setMastodonImportStatus(`Erreur: ${error.message}`);
        } finally {
            setIsImportingMastodon(false);
        }
    };
    
    const clearMastodonData = () => {
        if (confirm('Supprimer toutes les donn√©es Mastodon import√©es ?')) {
            Storage.remove('mastodon_posts');
            Storage.remove('mastodon_imported_at');
            setMastodonImportStatus('Donn√©es Mastodon supprim√©es');
            setTimeout(() => setMastodonImportStatus(''), 2000);
        }
    };
    
    const handlePhotoIndexImport = async () => {
        if (!isConnected) {
            setPhotoImportStatus("Veuillez vous connecter √† Google Drive d'abord.");
            return;
        }
        setIsImportingPhotos(true);
        setPhotoImportStatus('Recherche du fichier photos_index_clean.json sur votre Drive...');
        try {
            const jsonData = await GoogleDriveAPI.loadJsonFile('photos_index_clean.json');
            if (!jsonData) {
                throw new Error("Fichier 'photos_index_clean.json' introuvable √† la racine de votre Google Drive.");
            }
            setPhotoImportStatus('Analyse de l\'index...');
            const indexData = PhotoData.parsePhotoIndex(jsonData);
            PhotoData.saveIndex(indexData);
            setPhotoImportStatus(`Succ√®s ! ${indexData.allPhotos.length} photos index√©es.`);
        } catch (error) {
            setPhotoImportStatus(`Erreur: ${error.message}`);
        } finally {
            setIsImportingPhotos(false);
        }
    };
    
    const handlePhotoIndexLocalImport = async (event) => {
        const file = event.target.files[0];
        if (!file) return;
        
        setIsImportingPhotos(true);
        setPhotoImportStatus('Lecture du fichier...');
        try {
            const text = await file.text();
            setPhotoImportStatus('Analyse de l\'index...');
            const indexData = PhotoData.parsePhotoIndex(text);
            PhotoData.saveIndex(indexData);
            setPhotoImportStatus(`Succ√®s ! ${indexData.allPhotos.length} photos index√©es.`);
            setTimeout(() => setPhotoImportStatus(''), 3000);
        } catch (error) {
            setPhotoImportStatus(`Erreur: ${error.message}`);
        } finally {
            setIsImportingPhotos(false);
            if (photoFileInputRef.current) {
                photoFileInputRef.current.value = '';
            }
        }
    };

    const clearPhotoData = () => {
        if (confirm('Supprimer l\'index des photos import√©es ?')) {
            Storage.remove('photo_index');
            Storage.remove('photo_index_imported_at');
            setPhotoImportStatus('Index des photos supprim√©');
            setTimeout(() => setPhotoImportStatus(''), 2000);
        }
    };

    return (
        <div className="space-y-6 fade-in">
            <GoogleConnection 
                isConnected={isConnected}
                isLoading={isLoading}
                userInfo={userInfo}
                onSignIn={signIn}
                onSignOut={onGoogleDisconnect || signOut}
            />

            <div className="bg-white p-6 rounded-lg shadow-md space-y-4">
                <h3 className="text-lg font-semibold text-gray-900">Index des Photos</h3>
                {isPhotoIndexImported ? (
                     <div className="bg-green-50 border border-green-200 p-4 rounded-lg">
                        <div className="flex items-center justify-between">
                            <div>
                                <div className="font-medium text-green-900">Index des photos import√©</div>
                                <div className="text-sm text-green-700">
                                    {photoStats.totalPhotos} photos sur {photoStats.totalDays} jours
                                </div>
                                <div className="text-xs text-green-600 mt-1">
                                    Import√© le {new Date(photoStats.importedAt).toLocaleDateString('fr-FR')}
                                </div>
                            </div>
                            <button onClick={clearPhotoData} className="px-3 py-1 bg-red-100 hover:bg-red-200 text-red-700 rounded text-sm">
                                Supprimer
                            </button>
                        </div>
                    </div>
                ) : (
                    <div className="space-y-4">
                        <p className="text-gray-600">
                            Importez l'index de vos photos depuis le fichier `photos_index_clean.json`.
                        </p>
                         <button
                            onClick={handlePhotoIndexImport}
                            disabled={isImportingPhotos || !isConnected}
                            className="w-full flex items-center justify-center space-x-2 px-4 py-3 bg-blue-500 hover:bg-blue-600 text-white rounded-lg font-semibold shadow disabled:bg-gray-400"
                        >
                            {isImportingPhotos ? 
                                <div className="animate-spin w-5 h-5 border-2 border-white border-t-transparent rounded-full"></div> :
                                <Cloud className="w-5 h-5" />
                            }
                            <span>{isImportingPhotos ? 'Import en cours...' : 'Importer depuis Google Drive'}</span>
                        </button>
                         <p className="text-center text-gray-500 my-2">ou</p>
                        <div className="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center">
                            <input
                                ref={photoFileInputRef}
                                type="file"
                                accept=".json"
                                onChange={handlePhotoIndexLocalImport}
                                className="hidden"
                                id="photo-file"
                                disabled={isImportingPhotos}
                            />
                            <label htmlFor="photo-file" className={`cursor-pointer flex flex-col items-center ${isImportingPhotos ? 'opacity-50 cursor-not-allowed' : ''}`}>
                                <Upload className="w-12 h-12 text-gray-400 mb-3" />
                                <div className="text-lg font-medium text-gray-700">
                                    {isImportingPhotos ? 'Import en cours...' : 'S√©lectionner photos_index_clean.json'}
                                </div>
                                <div className="text-sm text-gray-500 mt-1">
                                    Cliquez pour parcourir vos fichiers
                                </div>
                            </label>
                        </div>
                    </div>
                )}
                 {photoImportStatus && (
                    <div className={`p-3 rounded-lg text-sm ${
                        photoImportStatus.includes('Erreur') ? 'bg-red-100 text-red-700' : 
                        photoImportStatus.includes('Succ√®s') ? 'bg-green-100 text-green-700' : 'bg-blue-100 text-blue-700'
                    }`}>
                        {photoImportStatus}
                    </div>
                )}
            </div>
            
            <div className="bg-white p-6 rounded-lg shadow-md space-y-4">
                <h3 className="text-lg font-semibold text-gray-900">Blog Mastodon</h3>
                {isMastodonImported ? (
                    <div className="bg-green-50 border border-green-200 p-4 rounded-lg">
                        <div className="flex items-center justify-between">
                            <div>
                                <div className="font-medium text-green-900">Blog import√© avec succ√®s</div>
                                <div className="text-sm text-green-700">
                                    {mastodonStats.totalPosts} posts ‚Ä¢ Jours {mastodonStats.dayRange?.min}-{mastodonStats.dayRange?.max}
                                </div>
                                <div className="text-xs text-green-600 mt-1">
                                    Import√© le {new Date(mastodonStats.importedAt).toLocaleDateString('fr-FR')}
                                </div>
                            </div>
                            <button onClick={clearMastodonData} className="px-3 py-1 bg-red-100 hover:bg-red-200 text-red-700 rounded text-sm">
                                Supprimer
                            </button>
                        </div>
                    </div>
                ) : (
                    <div className="space-y-4">
                        <p className="text-gray-600">
                            Importez votre fichier `outbox.json` pour explorer vos posts Mastodon.
                        </p>
                         <button
                            onClick={handleMastodonDriveImport}
                            disabled={isImportingMastodon || !isConnected}
                            className="w-full flex items-center justify-center space-x-2 px-4 py-3 bg-blue-500 hover:bg-blue-600 text-white rounded-lg font-semibold shadow disabled:bg-gray-400"
                        >
                            {isImportingMastodon ?
                                <div className="animate-spin w-5 h-5 border-2 border-white border-t-transparent rounded-full"></div> :
                                <Cloud className="w-5 h-5" />
                            }
                            <span>{isImportingMastodon ? 'Import en cours...' : 'Importer depuis Google Drive'}</span>
                        </button>
                         <p className="text-center text-gray-500 my-2">ou</p>
                        <div className="border-2 border-dashed border-gray-300 rounded-lg p-6 text-center">
                            <input
                                ref={mastodonFileInputRef}
                                type="file"
                                accept=".json"
                                onChange={handleMastodonImport}
                                className="hidden"
                                id="mastodon-file"
                                disabled={isImportingMastodon}
                            />
                            <label htmlFor="mastodon-file" className={`cursor-pointer flex flex-col items-center ${isImportingMastodon ? 'opacity-50 cursor-not-allowed' : ''}`}>
                                <Upload className="w-12 h-12 text-gray-400 mb-3" />
                                <div className="text-lg font-medium text-gray-700">
                                    {isImportingMastodon ? 'Import en cours...' : 'S√©lectionner outbox.json'}
                                </div>
                                <div className="text-sm text-gray-500 mt-1">
                                    Cliquez pour parcourir vos fichiers
                                </div>
                            </label>
                        </div>
                    </div>
                )}
                {mastodonImportStatus && (
                    <div className={`p-3 rounded-lg text-sm ${
                        mastodonImportStatus.includes('Erreur') ? 'bg-red-100 text-red-700' : 
                        mastodonImportStatus.includes('Succ√®s') ? 'bg-green-100 text-green-700' : 'bg-blue-100 text-blue-700'
                    }`}>
                        {mastodonImportStatus}
                    </div>
                )}
            </div>

            <div className="bg-white p-6 rounded-lg shadow-md space-y-4">
                <h3 className="text-lg font-semibold text-gray-900">Donn√©es G√©n√©rales</h3>
                <div>
                    <button 
                        onClick={() => {
                            if (confirm('Effacer toutes les donn√©es sauvegard√©es (sessions, utilisateur, etc.) ?')) onReset();
                        }}
                        className="px-4 py-2 bg-red-500 hover:bg-red-600 text-white rounded-lg text-sm font-medium"
                    >
                        Reset complet de l'application
                    </button>
                </div>
            </div>
        </div>
    );
};
		

// ===== MAIN APP - TIMING CREATION CORRIGE =====
// ===== MAIN APP - AVEC ETAT CREATION LOCAL =====
const MemoireMekong = () => {
    const {
        currentPage, setCurrentPage,
        currentUser, setCurrentUser,
        resetApp
    } = useAppState();

    const { 
        isConnected, isLoading, userInfo, hasEverBeenConnected, connectionMode, lastConnectionError,
        signIn, signOut, forceDisconnect, testConnection 
    } = useGoogleAuth();
    
    const { sessions, setSessions, updateSession, createSession, syncSessions } = useSessionState();

    const [currentChatSession, setCurrentChatSession] = React.useState(null);
    const [toast, setToast] = React.useState({ message: '', type: '' });
    const [isCreatingSession, setIsCreatingSession] = React.useState(false);

    // Configurer le callback de d√©tection de d√©connexion
    React.useEffect(() => {
        CloudSessionStorage.onConnectionLost = (reason) => {
            console.log('üî¥ CloudSessionStorage d√©tecte une d√©connexion:', reason);
            forceDisconnect(reason);
            setToast({ 
                message: `üî¥ ${reason}`, 
                type: 'error' 
            });
        };

        return () => {
            CloudSessionStorage.onConnectionLost = null;
        };
    }, [forceDisconnect]);

    // Synchronisation automatique au chargement et lors de la connexion
    React.useEffect(() => {
        let isMounted = true;
        
        const autoSync = async () => {
            if (isConnected && !isLoading && connectionMode === 'connected') {
                try {
                    console.log('üîÑ Synchronisation automatique...');
                    if (isMounted) {
                        await syncSessions();
                        console.log('‚úÖ Synchronisation termin√©e');
                    }
                } catch (error) {
                    console.warn('‚ö†Ô∏è Sync auto √©chou√©e:', error.message);
                    if (isMounted) {
                        if (connectionMode === 'connected') {
                            setToast({ message: "Synchronisation automatique √©chou√©e", type: 'error' });
                        }
                    }
                }
            }
        };

        const timeoutId = setTimeout(autoSync, 500);
        
        return () => {
            isMounted = false;
            clearTimeout(timeoutId);
        };
    }, [isConnected, isLoading, connectionMode, syncSessions]);

    // Test p√©riodique de connexion
    React.useEffect(() => {
        if (connectionMode !== 'connected') return;

        const intervalId = setInterval(async () => {
            console.log('üîç Test p√©riodique de connexion...');
            await testConnection();
        }, 5 * 60 * 1000);

        return () => clearInterval(intervalId);
    }, [connectionMode, testConnection]);

    const handleSessionSelect = (session) => {
        setCurrentChatSession(null);
        setTimeout(() => {
            setCurrentChatSession(session);
            setCurrentPage('chat');
        }, 50);
    };

    const handleBackToSessions = () => {
        setCurrentChatSession(null);
        setCurrentPage('sessions');
    };

    const handleUpdateSession = async (updatedSession) => {
        try {
            await updateSession(updatedSession);
            setCurrentChatSession(updatedSession);
        } catch (error) {
            if (error.message.includes('Connexion Google Drive perdue')) {
                console.log('üíæ Session mise √† jour localement suite √† d√©connexion');
            } else {
                setToast({ message: error.message, type: 'error' });
            }
            
            const localSessions = Storage.get('sessions', []);
            setSessions(localSessions); 
            setCurrentChatSession(updatedSession);
        }
    };

    // Gestion des actions Google Drive
    const handleGoogleAction = async () => {
        if (connectionMode === 'never-connected' || connectionMode === 'disconnected') {
            try {
                const result = await signIn();
                if (result === true) {
                    setToast({ message: "Connexion Google Drive r√©ussie !", type: 'success' });
                    
                    try {
                        await syncSessions();
                        setToast({ message: "Reconnexion et synchronisation r√©ussies !", type: 'success' });
                    } catch (syncError) {
                        setToast({ message: "Reconnect√© mais synchronisation √©chou√©e", type: 'error' });
                    }
                } else if (result && result.error) {
                    setToast({ message: `Erreur de connexion: ${result.error}`, type: 'error' });
                }
            } catch (error) {
                setToast({ message: "Erreur de connexion Google Drive", type: 'error' });
            }
        } else if (connectionMode === 'connected') {
            setCurrentPage('settings');
        }
    };

    const handleGameSelect = async (game) => {
        console.log('üéÆ S√©lection jeu:', game.title);
        
        if (connectionMode === 'disconnected') {
            setToast({ 
                message: "‚ö†Ô∏è Session cr√©√©e en mode local - ne sera pas synchronis√©e", 
                type: 'error' 
            });
        }
        
        setIsCreatingSession(true);
        
        try {
            console.log('üîÑ D√©but cr√©ation session...');
            const newSession = await createSession(game, currentUser);
            console.log('‚úÖ Session cr√©√©e:', newSession?.id);
            
            if (newSession) {
                if (window.pendingGameSession) {
                    delete window.pendingGameSession;
                }
                
                setCurrentChatSession(newSession);
                setCurrentPage('chat');
            }
        } catch (error) {
            console.error('‚ùå Erreur cr√©ation session:', error);
            setToast({ message: "Erreur lors de la cr√©ation de session", type: 'error' });
        } finally {
            setIsCreatingSession(false);
        }
    };

    const handleCreateSessionFromMemory = async (sessionData) => {
        if (sessionData.type === 'game') {
            setIsCreatingSession(true);
            
            try {
                if (sessionData.postContent) {
                    window.pendingGameSession = { 
                        game: sessionData.game, 
                        user: currentUser, 
                        postChapo: sessionData.postContent 
                    };
                }
                
                const newSession = await createSession(sessionData.game, currentUser);
                
                if (newSession) {
                    setCurrentChatSession(newSession);
                    setCurrentPage('chat');
                }
            } catch (error) {
                setToast({ message: "Erreur lors de la cr√©ation de session", type: 'error' });
            } finally {
                setIsCreatingSession(false);
            }
        } else {
            setCurrentPage(sessionData);
        }
    };

    const pageRequiresConnection = (page) => {
        return ['sessions', 'chat'].includes(page);
    };

    React.useEffect(() => {
        if (connectionMode === 'disconnected' && pageRequiresConnection(currentPage)) {
            setToast({ 
                message: "Fonctionnalit√© limit√©e en mode d√©connect√©. Reconnectez-vous pour une synchronisation compl√®te.", 
                type: 'error' 
            });
        }
    }, [connectionMode, currentPage]);

    React.useEffect(() => {
        if (lastConnectionError && connectionMode === 'disconnected') {
            setToast({ 
                message: `Probl√®me de connexion: ${lastConnectionError}`, 
                type: 'error' 
            });
        }
    }, [lastConnectionError, connectionMode]);

    return (
        <div className="min-h-screen bg-gradient-to-br from-amber-50 to-orange-100">
            
            <TopBar
                currentPage={currentPage}
                currentUser={currentUser}
                onUserChange={setCurrentUser}
                onPageChange={setCurrentPage}
                connectionMode={connectionMode}
                googleAuth={{ isConnected, isLoading, userInfo, signIn, signOut }}
                onGoogleAction={handleGoogleAction}
            />

            <main className="p-4 pb-24">
                <div className="max-w-6xl mx-auto">
                    <div className="bg-white/80 backdrop-blur rounded-xl shadow-lg p-6">
                        {currentPage === 'home' && (
                            <HomePage 
                                currentUser={currentUser}
                                onUserChange={setCurrentUser}
                                onPageChange={setCurrentPage}
                                connectionMode={connectionMode}
                                googleAuth={{ isConnected, isLoading, userInfo, signIn, signOut }}
                            />
                        )}
                        {currentPage === 'games' && (
                            <GamesPage 
                                currentUser={currentUser}
                                onPageChange={setCurrentPage}
                                onGameSelect={handleGameSelect}
                                isCreatingSession={isCreatingSession}
                            />
                        )}
                        {currentPage === 'sessions' && (
                            <SessionsPage 
                                currentUser={currentUser} 
                                onPageChange={setCurrentPage}
                                onSessionSelect={handleSessionSelect}
                            />
                        )}
                        {currentPage === 'chat' && (
                            <ChatPage 
                                currentUser={currentUser}
                                currentSession={currentChatSession}
                                onUpdateSession={handleUpdateSession}
                                onBackToSessions={handleBackToSessions}
                            />
                        )}
                        {currentPage === 'memories' && (
    <MemoriesPage 
        currentUser={currentUser}
        onCreateSession={handleCreateSessionFromMemory}
        isCreatingSession={isCreatingSession}
    />
)}
                        {currentPage === 'settings' && (
                            <SettingsPage 
                                onReset={resetApp}
                                googleAuth={{
                                    isConnected: isConnected,
                                    isLoading: isLoading,
                                    userInfo: userInfo,
                                    signIn: signIn,
                                    signOut: signOut
                                }}
                                onGoogleDisconnect={async () => {
                                    await signOut();
                                    setToast({ message: "D√©connexion r√©ussie", type: 'success' });
                                }}
                            />
                        )}
                        {currentPage === 'users' && (
                            <UsersPage 
                                currentUser={currentUser}
                                onUserChange={setCurrentUser}
                                onPageChange={setCurrentPage}
                            />
                        )}
                    </div>
                </div>
            </main>
            
            <BottomNavBar
                currentPage={currentPage}
                onPageChange={setCurrentPage}
                currentUser={currentUser}
            />

            <Toast 
                message={toast.message} 
                type={toast.type} 
                onDismiss={() => setToast({ message: '', type: '' })} 
            />
        </div>
    );
};
		
        // ===== RENDER =====
        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(React.createElement(MemoireMekong));
    </script>
</body>
</html>
